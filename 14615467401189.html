<!DOCTYPE html>
<html>

<head>
    <title>
         Swift 学习笔记：协议 - Hack Notes 
    </title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="asset/yue.css">
    <link rel="stylesheet" type="text/css" href="asset/main.css">
    <link rel="stylesheet" type="text/css" href="asset/tomorrow.css">

    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Hack Notes">

    <script src="asset/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="yue site-header">
        <div class="wrapper">
            <a class="site-title" href="index.html">Hack Notes</a>
            <nav class="site-nav">
                <a href="#" class="menu-icon">
                    
                    <svg viewBox="0 0 18 15">
                        <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"
                        />
                        <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"
                        />
                        <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"
                        />
                    </svg>

                </a>
                <div class="trigger">
                    
                        <a class="page-link" href="index.html">HOME</a>
                    
                        <a class="page-link" href="tech.html">TECH</a>
                    
                        <a class="page-link" href="essay.html">ESSAY</a>
                    
                        <a class="page-link" href="atom.xml">RSS</a>
                    
                </div>
            </nav>
        </div>
    </header>
</body>

</html> <div class="page-content yue">
    <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
            <header class="post-header">
                <h1 class="post-title" itemprop="name headline">Swift 学习笔记：协议</h1>
                <p class="post-meta">
                    <time class="post-time" datetime="2016-04-25T09:12:20+08:00" itemprop="datePublished">2016/4/25</time>
                </p>
            </header>
            <div class="post-content" itemprop="articleBody">
                <p>Notes on Swift.</p>

<span id="more"></span><!-- more -->

<p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。</p>

<h2 id="toc_0">协议语法</h2>

<p>拥有父类的类在采纳协议时，应该将父类名放在协议名之前，以逗号分隔。</p>

<h2 id="toc_1">属性要求</h2>

<p>协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型。此外，协议还指定属性是可读还是可读可写的。</p>

<p>如果要求属性是可读可写的，那么该属性不能是常量属性或只读的计算属性；如果协议要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p>

<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型后面加上 <code>{set get}</code> 来表示属性是可读可写的，可读属性则用 <code>{ get }</code> 来表示。</p>

<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。</p>

<h2 id="toc_2">方法要求</h2>

<p>在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。</p>

<h2 id="toc_3">Mutating 方法要求</h2>

<p>有时需要在方法中改变方法所属的实例。将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属性的实例以及实例的任意属性的值。</p>

<p>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p>

<h2 id="toc_4">构造器要求</h2>

<p>协议可以要求采纳协议的类型实现制定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但是不需要写花括号和构造器实体。</p>

<h2 id="toc_5">构造器要求在类中的实现</h2>

<p>你可以在采纳协议的类中实现构造器，无论是作为制定构造器，还是作为便利构造器，你都必须为构造器实现表上 <code>required</code> 修饰符。</p>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符。</p>

<h2 id="toc_6">可失败构造器要求</h2>

<h2 id="toc_7">协议作为类型</h2>

<p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用：</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中得元素类型</li>
</ul>

<h2 id="toc_8">委托（代理）模式</h2>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</p>

<p>委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些类型。委托模式可以用来响应特定的动作，或者接受外部数据源提供的数据，而无需关心外部数据源的类型。</p>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。</p>

<p>通过扩展采纳并符合协议，和在原始定义中采纳并符合协议的效果完全相同。</p>

<h2 id="toc_10">通过扩展采纳协议</h2>

<p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议。</p>

<h2 id="toc_11">协议类型的集合</h2>

<p>协议类型可以在数组或者字典这样的集合中使用。</p>

<h2 id="toc_12">协议的继承</h2>

<p>协议能够继承一个或者多个其他协议，可以在继承的协议的基础上正价新的要求。</p>

<h2 id="toc_13">类类型专属协议</h2>

<p>你可以在洗衣的继承列表中，通过添加 <code>class</code> 关键字来限制协议只能被类类型采纳，而结构体或枚举不能采纳该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前。</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<h2 id="toc_14">协议合成</h2>

<p>有时候需要同时采纳多个协议，你可以将多个协议采用 <code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code> 这样的格式进行组合，称为协议合成（protocol composition）。你可以在<code>&lt;&gt;</code>张罗列任意多个你想要采纳的协议，以逗号分隔。</p>

<p>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个旨在局部作用域中的有效临时协议中。</p>

<h2 id="toc_15">检查协议一致性</h2>

<p>你可以使用类型转换中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否符合某协议，并且可以转换到制定的协议类型。</p>

<ul>
<li><code>is</code> 用来检查视力是否符合某个协议，符合返回 <code>true</code>。</li>
<li><code>as?</code> 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>。</li>
<li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>
</ul>

<h2 id="toc_16">可选的协议要求</h2>

<p>协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>

<p>可选的协议要求只能用在标记 <code>@objc</code> 特性的协议中。该特性表示协议将暴露给 Objective-C 代码。即使你不打算和 OC 有什么交互，如果你想要指定可选的协议要求，都那么还是要为协议加上 <code>@obj</code> 特性。</p>

<h2 id="toc_17">协议扩展</h2>

<p>协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需再每个采纳协议的类型中都重复同样的实现，也无需使用全局函数。</p>

<h2 id="toc_18">提供默认实现</h2>

<p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果采纳协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中默认实现被使用。</p>

<h2 id="toc_19">为协议扩展添加限制条件</h2>

<p>在扩展协议的时候，可以指定一些限制条件，只有采纳协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述。</p>

            </div>
            <div>
                <script type="text/javascript">
    var disqus_shortname = 'tisogasnotes'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?001e800887eba2f8f57ec8059aafdad6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
                
                    <div id="disqus_thread"></div>
                
                
            </div>
        </article>
    </div>
</div>  <footer id="footer" class="yue">
    <div class="wrapper">
        <p>© Copyright 2014 - 2017 by <a href="https://twitter.com/Tisoga">@Tisoga</a>.</p>
    </div>
</footer>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
