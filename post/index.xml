<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jiayuan Thoughts</title>
    <link>http://blog.jiayuanzhang.com/post/</link>
    <description>Recent content in Posts on Jiayuan Thoughts</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 12 Jan 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://blog.jiayuanzhang.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>利用 Twitter 来进行低成本写作</title>
      <link>http://blog.jiayuanzhang.com/post/low-cost-writing-with-twitter/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/low-cost-writing-with-twitter/</guid>
      <description>&lt;p&gt;碎片化时代，阅读长篇的文章已经成了一件困难的事，更不用提写长篇的博客文章了。在过去的 2020 年里，总共也只发表了 7 篇文章，其中上大部分都是阅读分享。但是在 Twitter 上，却分享了非常多的内容，在 &lt;a href=&#34;https://threadreaderapp.com/user/Tisoga&#34;&gt;Thread Reader&lt;/a&gt; 上总共 unroll 了 9 篇长 thread，总的阅读量加起来差不多有 100 万。&lt;/p&gt;
&lt;p&gt;在我看来，在 Twitter 上写作属于一种「低成本写作」的方式，因为：&lt;/p&gt;
&lt;p&gt;1）碎片化写作，想到什么写什么，没有写长篇文章的压力；&lt;/p&gt;
&lt;p&gt;2）这是一种 &lt;a href=&#34;https://twitter.com/Tisoga/status/1207327379321847809&#34;&gt;Show Your Work&lt;/a&gt; 的写作方式，不断地向大家展示自己的思考过程；&lt;/p&gt;
&lt;p&gt;3）可以基于自己和别人的 Tweet 进行衍生、再创作，把 Twitter 变成一个&lt;a href=&#34;https://twitter.com/Tisoga/status/1264791291352637440&#34;&gt;卡片知识库&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;4）可以获得即时反馈，随时和读者进行互动交流；&lt;/p&gt;
&lt;p&gt;为了提升 Twitter 的写作体验，这里也给出几个建议：&lt;/p&gt;
&lt;p&gt;1）使用 Twitter 的高级搜索功能，可以快速搜索指定人发的推，可以参考我的方法，设定一个 &lt;a href=&#34;https://twitter.com/Tisoga/status/1218448399948636160&#34;&gt;Alfred Workflow&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;2）使用 &lt;a href=&#34;https://threadreaderapp.com/&#34;&gt;Thread Reader&lt;/a&gt; 来把长推转成一篇文章；&lt;/p&gt;
&lt;p&gt;3）定期 Review 之前发过的推，可以在此基础上进行进一步演绎；&lt;/p&gt;
&lt;p&gt;4）设定一个 &lt;a href=&#34;https://twitter.com/Tisoga/status/1264921247348977670&#34;&gt;Index&lt;/a&gt;，方便读者查阅。&lt;/p&gt;
&lt;p&gt;另外，写博客也不一定要写长文，比如说这篇。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分享 | 这周我在读什么 #005</title>
      <link>http://blog.jiayuanzhang.com/post/my-reading-list-005/</link>
      <pubDate>Sat, 13 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/my-reading-list-005/</guid>
      <description>&lt;p&gt;关于此系列：我会每周分享我这周正在读的书、文章和其他一些有意思的东西，主题不限，每周不定期更新。&lt;/p&gt;
&lt;p&gt;这是第 5 期的阅读报告，拖更了 n 周。从这期开始，每周阅读推荐将被分成几个小栏目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jiayuan Thoughts：这周我写了什么文章，包括发表在自己的博客、这个公众号和其他网站上的一些内容，如果这周没有写新东西，那我会分享一篇之前写的文章。&lt;/li&gt;
&lt;li&gt;Books：这周我读了什么书，如果没有读新的书，我会推荐之前读过的一些书。&lt;/li&gt;
&lt;li&gt;Explore：这周看/听到的有意思的文章、视频。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ok，下面是第 5 期的内容。&lt;/p&gt;
&lt;h3 id=&#34;jiayuan-thoughts&#34;&gt;Jiayuan Thoughts&lt;/h3&gt;
&lt;p&gt;这周没有写新的文章，所以分享一篇之前写的文章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://blog.jiayuanzhang.com/post/meta-knowledge-how-to-search-informations/&#34;&gt;元知识：信息检索指南&lt;/a&gt;&lt;/strong&gt; 毫无疑问，21 世纪是一个信息爆炸的时代，「信息检索」应该是数字时代公民应该掌握的基本技能。我理解的「元知识」是各个领域都通用的技能，例如交流的能力、搜索信息的能力、语言的能力等，不管从事什么行业的工作，这些都是必备的技能。而学会「信息检索」的一个前提就是先要&lt;strong&gt;定义好问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;books&#34;&gt;Books&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;《巨人的工具》&lt;/strong&gt; by Tim Ferriss，我在前面几次的阅读报告中提到过很多次 Tim Ferriss 了，这次分享的是由他的播客 &lt;em&gt;The Tim Ferriss Show&lt;/em&gt; 集结而成的一本书。这本书是在今年去北京参加公司年会的高铁上读完的，总共有 700 多页，是一本砖头书，光笔记就记了上万字。这本书在豆瓣上的评价两级分化严重，但是在我看来，这是一本价值被低估的书，一档播客的质量好坏，很大程度上是由参与的嘉宾决定的，而 &lt;em&gt;The Tim Ferriss Show&lt;/em&gt; 的嘉宾阵容可以说是非常豪华：PayPal 的创始人 Peter Thiel（没错，就是美剧《硅谷》里的那个 Peter Thiel 的原型，在 Stanford 上了一门课 &lt;em&gt;How to Start a Startup&lt;/em&gt;，后来学生的笔记整理成了《从零到一》这本书）；冰人 Wim Hof；演员、加州州长施瓦辛格等等。在我看来，这本书唯一的缺点就是太散了，不像其他的书有一个明确的主题和结构，这也是播客的弊端之一，为此，我才做了大量的笔记。总之，非常推荐大家去读一下，不用从头到尾读，可以挑一些感兴趣的人来阅读。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;How to Take Smart Notes&lt;/strong&gt;&lt;/em&gt; by Sonke Ahrens，这是一本教你如何做笔记的书，没错，一整本书都在教你怎么做笔记（和写作）。这本书应该是我最近几年来读过的最有价值的一本书之一，我每天会做大量的笔记，所以这本书对我的笔记系统的改进起到了非常大的帮助。书中提到了一种类似于 GTD 的的笔记处理工作流：&lt;/p&gt;
&lt;p&gt;1）第一步，在需要做笔记的时候先把想要记录的内容写下来，不要在乎笔记的格式、写作的工具，也不要管这个笔记有没有用，先写下来再说，这相当于 GTD 中的 Inbox；&lt;/p&gt;
&lt;p&gt;2）第二步，也是最重要的一步，把上面记录的这些笔记转化为 Permanent Notes（永久笔记？或者你有更好的翻译可以告诉我），什么是 Permanent Notes 呢，简单来讲，就是像写文章一样来写笔记，想象你正在像某人讲述这个东西，你应该怎么讲？这种笔记的方式和「费曼技巧」非常像。这一步相当于 GTD 中的 Process。&lt;/p&gt;
&lt;p&gt;当然，一本书的内容没办法用短短的几百字来解释清楚，这里只是简单介绍了一下书中的核心内容：2 步式笔记处理工作流。我会在接下来的一段时间里写一些文章来来介绍书中的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/DraggedImage.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为我在 Roam Research 中所记的笔记，统计了一下，有 3000 字左右）&lt;/p&gt;
&lt;h3 id=&#34;explore&#34;&gt;Explore&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://jeffhuang.com/productivity_text_file/&#34;&gt;My productivity app is a single .txt file&lt;/a&gt;&lt;/strong&gt; by Jeff Huang，作者是布朗大学的计算机科学教授，在这篇文章里，他介绍了使用了 12 年的效率工具：一个简单的 txt 文件。现在市面上的各种时间管理工具层出不穷，包括 OmniFocus、Todoist、滴答清单等等，很多人花费了大量的时间在捣腾这些工具上（包括我），但是实际的效率并没有提高多少。也许，对于大部分人来说，一个简单的文件、一个便利贴就足够了。每天的产出不应该是以数量来定义的，而是&lt;strong&gt;重要的事完成了哪些&lt;/strong&gt;，在我看来，一张便利贴，每天写上三件最重要的事，就是最好的时间管理方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://m.signalvnoise.com/remote-working-the-home-office-desks-of-basecamp/&#34;&gt;Remote Working: The home office desks of Basecamp&lt;/a&gt;&lt;/strong&gt; by Basecamp，Basecamp 是我非常喜欢的一家公司，在前面几期的 newsletter 中我也提到过。Basecamp 几乎全员都是远程工作，所以此次疫情也没有影响到他们的工作方式，这篇文章中，Basecamp 的一众员工纷纷展示了自己 work-from-home 的工作台，其中最亮眼的应该是 DHH (David Heinemeier Hansson) 的工作台了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200613210514.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（图片为 DHH 的工作台）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.listennotes.com/blog/why-podcasts-are-my-new-wikipedia-the-perfect-41/&#34;&gt;Why Podcasts Are My New Wikipedia —the  Perfect Informal Learning Resource&lt;/a&gt;&lt;/strong&gt; by Wenbin Fang. 作者是 Listen Notes 的创始人，在&lt;a href=&#34;http://blog.jiayuanzhang.com/post/my-reading-list-003/&#34;&gt;分享 | 这周我在读什么 #003&lt;/a&gt;中，我曾经分享过他的一另一篇文章：&lt;a href=&#34;https://www.listennotes.com/blog/the-boring-technology-behind-a-one-person-23/&#34;&gt;The boring technology behind a one-person Internet company&lt;/a&gt;，介绍的是一个人的公司所使用的技术是什么样的。在今天这篇文章中，作者分享了自己听播客的一种方法，把「稍后读」的概念搬到听播客上，不再是定于一个个的 Podcast 频道来听，而是找到某个频道中想听的内容，添加到自己的「稍后听」列表中，Listen Notes 的网站上就支持创建这样的稍后听 playlist，然后我会使用 Overcast 客户端来订阅这个 playlist，这样就创建了一个你自己独有的频道。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分享 | 这周我在读什么 #004</title>
      <link>http://blog.jiayuanzhang.com/post/my-reading-list-004/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/my-reading-list-004/</guid>
      <description>&lt;p&gt;（本文首发于微信公众号，搜索「直觉泵 Intuition Pumps」或「intuition_pumps」关注）&lt;/p&gt;
&lt;p&gt;关于此系列：我会每周分享我这周正在读的书、文章和其他一些有意思的东西，主题不限，每周不定期更新。&lt;/p&gt;
&lt;p&gt;这是第 4 期的阅读报告，不知不觉已经写了一个月了。写阅读报告的一个显而易见的好处就是可以 push 你每周都去读一些东西，否则就没什么东西可写。另外阅读是一种输入的过程，而讲给别人听是一种输出的过程，从「&lt;a href=&#34;https://en.wikipedia.org/wiki/Learning_pyramid&#34;&gt;学习金字塔&lt;/a&gt;」上来看，Teaching 也是一种最高级别的学习方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200316195439.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，阅读的留存率只有 10%，最低的是听，只有 5%，这也是我为什么不听书的原因之一。&lt;/p&gt;
&lt;p&gt;实践高留存率的一个非常好的方法就是「费曼技巧（Feynman Technique）」，下面我就用「费曼技巧」来解释一下「费曼技巧」：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;费曼是一个物理学家，费曼方法是他用来学习新东西的方式；&lt;/li&gt;
&lt;li&gt;对于一个新的知识点，使用通俗的话来讲给别人听，不要使用专业术语；&lt;/li&gt;
&lt;li&gt;如果讲给别人听的过程中卡壳了，就去重新学习这部分卡壳的内容，直到理解，然后重复上一个步骤；&lt;/li&gt;
&lt;li&gt;可以使用类比法，把一些未知的内容类比到已知的内容上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是这期的具体内容：&lt;/p&gt;
&lt;p&gt;这周没有读完任何一本书，所以书评部分暂停一周。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://tim.blog/2020/01/08/reading-recommendations/&#34;&gt;The Best Books and Articles I Read in 2019 – The Blog of Author Tim Ferriss&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt; Tim 在这篇文章中总结了 2019 年读过的一些比较好的书和文章，他每周也会推荐一些在阅读的内容。这篇文章中，我比较感兴趣的是 Tim 的阅读方式：&lt;/p&gt;
&lt;p&gt;1）对于想读的文章，全部用 &lt;a href=&#34;https://www.yinxiang.com/&#34;&gt;Evernote&lt;/a&gt; 的 Web Clipper 工具剪裁下来，然后在 Evernote 中阅读，边读边 Highlight，并在 Highlight 添加特殊的记号，这样就可以通过搜索特殊记号的方式来快速找到这些高亮的内容；&lt;/p&gt;
&lt;p&gt;2）几乎所有的书都在 Kindle 上阅读，在读的过程中划线高亮，Amazon.com 提供工具可以将书中高亮的内容导出（中国区没有提供，但是可以通过 App 导出），他会把这些导出的内容保存到 Evernote 中，然后重复（1）的步骤；&lt;/p&gt;
&lt;p&gt;3）对于纸质书，他会手动制作一个索引卡（index），把书中重要的内容的页码写下来（可以参考一些书后面的索引），然后把这个索引卡扫描到 Evernote 中。&lt;/p&gt;
&lt;p&gt;可以看出来，Tim 将 Evernote 作为几乎所有信息来源的终端，所有想读或者读过的内容都可以在 Evernote 中搜索到。然后，他会利用邮件列表的形式每周发送一篇阅读分享，完成了输入和输出的闭环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200316195522.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为 Tim Ferriss 每周发送的阅读报告）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://www-cs-faculty.stanford.edu/~knuth/email.html&#34;&gt;Email (let&amp;rsquo;s drop the hyphen)&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt; 著名的计算机科学家 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3&#34;&gt;Knuth&lt;/a&gt; 在这篇文章里面说明了自己为什么不用 Email。他提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Email is a wonderful thing for people whose role in life is to be on top of things. But not for me; my role is to be on the bottom of things. &lt;strong&gt;What I do takes long hours of studying and uninterruptible concentration&lt;/strong&gt;. I try to learn certain areas of computer science exhaustively; then I try to digest that knowledge into a form that is accessible to people who don&amp;rsquo;t have time for such study.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概意思就是「我的工作是去研究那些你们没时间研究的东西，所以需要保持专心。」希望老爷子有生之年能把 TAOCP（ &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming&#34;&gt;The Art of Computer Programming&lt;/a&gt;&lt;/em&gt; ）这套书写完。比尔盖茨曾说过谁读完了这套书就请直接给他发简历吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200316195601.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（感受一下 TAOCP 的厚度）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.thepaper.cn/newsDetail_forward_5500279&#34;&gt;书单｜在村上春树的小说中寻找他的私人阅读书单&lt;/a&gt;&lt;/strong&gt; 村上春树是我很喜欢的一个作家，他的阅读品味全写在他的小说里面了。看这篇文章的时候我去翻了一下当时读书时候做的笔记，他读费兹杰拉德的&lt;a href=&#34;https://book.douban.com/subject/1008988/&#34;&gt;《了不起的盖茨比》&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论班里还是宿舍院内，我没发现一个人喜欢这类小说。他们读的大多是高桥和巳、大江健三郎和三岛由纪夫，或者法国当代作家。这样，说话当然说不到一起，我只能一个人默默阅读。而且读了好几遍，时而合上眼睛，深深地把书的香气吸人肺腑。我只消嗅一下书香，抚摸一下书页，便油然生出一股幸福之感。——《挪威的森林》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;向往的周末生活：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嘈杂的周日街头使我的心头舒展开来。我在通勤电车一样拥挤不堪的纪伊国屋书店买了一本福克纳的《八月之光》。然后挑一家声音听起来尽可能大的爵士酒吧走进去，一边听奥尔德·科尔曼和巴顿·帕维尔洛的唱片，一边喝又热又不好喝的咖啡，随即翻看刚买的书。５点半时，合上书，出门吃了简单的晚饭。我不由心想：这样的星期日以后将重复几十次、几百次吧？&amp;ldquo;安静的、平和的、孤独的星期日&amp;rdquo;&amp;mdash;&amp;mdash;我出声说道。星期天我是不上发条的。——《挪威的森林》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Farnam Street Blog&lt;/strong&gt;&lt;/em&gt; 上周的「这周我在读什么 #003」分享过我在读的 Naval Ravikant 的采访稿，里面介绍了 Farnam Street 这个博客，这次的分享再次推荐一下这个博客，里面的内容太丰富了，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何阅读：&lt;em&gt;&lt;a href=&#34;https://fs.blog/reading/&#34;&gt;A Helpful Guide to Reading Better&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;109 个思维模型：&lt;em&gt;&lt;a href=&#34;https://fs.blog/mental-models/&#34;&gt;Mental Models: The Best Way to Make Intelligent Decisions (109 Models Explained)&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Knowledge Project 这个播客也采访了很多硅谷和华尔街的大佬。我付费（一百多刀）加入了 Farnam Street 的 Membership，是我 2020 年来买到的最有价值的知识付费内容，其中 The Knowledge Project 播客的文字稿就已经值回这个价格。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;看了我前面几期的的读者们可能会发现，我推荐的大部分内容都是英文的，所以最后我想简单来谈一谈英文阅读。&lt;/p&gt;
&lt;p&gt;如果你从事的是互联网相关的职业，那么毫无疑问，第一手的消息肯定都是英文的，在之前，这些消息被翻译成英文可能需要一两年（例如一些书籍），近些年因为国内自媒体的发展，让很多国外比较火的内容能够被很快被翻译到国内，但是翻译毕竟需要时间，而且不是一手的信息，所以我这里还是推荐大家尽量去读原文。&lt;/p&gt;
&lt;p&gt;科技类的英文文章并没有那么难读，最简单的方法就是安装一个可以屏幕取词的词典，然后去找感兴趣的内容，最重要的是一定要读感兴趣的内容，这样才不会变成「学习英语」，而是「获取信息」。&lt;/p&gt;
&lt;p&gt;刚开始可以看 &lt;a href=&#34;https://www.quora.com/&#34;&gt;Quora&lt;/a&gt;、&lt;a href=&#34;https://news.ycombinator.com/&#34;&gt;Hacker News&lt;/a&gt; 上的一些内容，或者我推荐的一些文章，都是比较好读的。等阅读量上来了可以去读一些比较严肃的内容，例如 &lt;a href=&#34;https://www.nytimes.com/&#34;&gt;New York Times&lt;/a&gt;（不是纽约时报中文网）、&lt;a href=&#34;https://www.economist.com/&#34;&gt;The Economist&lt;/a&gt;、&lt;a href=&#34;https://www.theguardian.com/uk&#34;&gt;The Guardian&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果大家感兴趣，我可以之后写一篇文章具体讲一下该如何提高英文阅读技能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分享 | 这周我在读什么 #003</title>
      <link>http://blog.jiayuanzhang.com/post/my-reading-list-003/</link>
      <pubDate>Sun, 08 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/my-reading-list-003/</guid>
      <description>&lt;p&gt;（本文首发于微信公众号，搜索「直觉泵 Intuition Pumps」或「intuition_pumps」关注）&lt;/p&gt;
&lt;p&gt;关于此系列：我会每周分享我这周正在读的书、文章和其他一些有意思的东西，主题不限，每周不定期更新。&lt;/p&gt;
&lt;p&gt;这是第 3 期的阅读报告，在开始之前，我先来回答之前读者问的几个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你是如何有时间读这么多东西的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实我每周的阅读量并不是特别大，书顶多读 2 本，然后外加一些文章，如果每天有 1-2 个小时在阅读上，非常容易做到。这里有两个可供参考的建议：&lt;/p&gt;
&lt;p&gt;1）固定时间阅读。每天固定拿出 30 分钟或者 1 个小时来阅读，我比较推荐睡前阅读，还可以作为催眠的工具；&lt;/p&gt;
&lt;p&gt;2）碎片时间阅读。如果你细心观察，每天会有大量的碎片时间（等车、等电梯、排队、通勤等等），这些时间加起来估计也有好几个小时。因为我目前只读电子书，所以可以很方便地使用 Kindle 看书或者手机上的 Instapaper 来读一些文章，积少成多，每周也能看完大量的内容。&lt;/p&gt;
&lt;p&gt;另外，我不听书，因为读书还是一件需要脑力的活动，听书的过程中很难做到只专心听书，但是我会在做家务等不需要耗费脑力的时候听一些信息量不那么大的播客，以此作为一种冥想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你是如何做笔记的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我看来，笔记分成两类：&lt;/p&gt;
&lt;p&gt;1）项目笔记，这部分笔记一般某个项目结束后就可以直接归档，不需要再次使用；&lt;/p&gt;
&lt;p&gt;2）创意笔记，这部分笔记我会记下所有的灵感、书中的 quotes、自己的想法等等创造性的内容。&lt;/p&gt;
&lt;p&gt;第一种项目笔记直接记就可以了，没什么特别的格式要求。&lt;/p&gt;
&lt;p&gt;第二种创意笔记我使用「卡片笔记」的方式，每张卡片只记录一个主题的内容，我拿读书笔记来举个例子，读书的过程中肯定会有很多划线和笔记的地方，一般我用 Kindle 阅读，划线的部分我会直接在 Kindle 中高亮，笔记我会额外写在一些小卡片上。每读完一本书，我会等一周的时间再去整理笔记（目的是让大脑冷静下来），整理笔记的过程又是重读这本书的过程（这也是为什么每本书至少会读两遍的原因），对于划线的部分，我会用自己的话复述到笔记里，对于其他的笔记，直接整理到笔记软件中就可以了，我用 Notion 来作为卡片笔记的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/4AFA92A8-A277-4CE1-9419-4D5A29B4448E_1_102_a.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为原始的卡片笔记，阅读过程中记录）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200309145604.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为读完《富兰克林自传》后整理的卡片笔记）&lt;/p&gt;
&lt;p&gt;关于如何做笔记的内容，使用短短的几段文字肯定无法解释清楚，我之后会写一篇文章具体地讲一下，我做笔记的原则在读了 &lt;em&gt;&lt;a href=&#34;https://book.douban.com/subject/30216624/&#34;&gt;How to Take Smart Notes&lt;/a&gt;&lt;/em&gt; 这本书后得到了很多改进，有兴趣的也可以去读一下。&lt;/p&gt;
&lt;p&gt;下面是本期的内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://book.douban.com/subject/1033778/&#34;&gt;《富爸爸穷爸爸》&lt;/a&gt;&lt;/strong&gt; by Robert Kiyosaki，上周读了《小狗钱钱》，这周读了这本，和《小狗钱钱》一样，是一本通过讲故事来讲述理财知识的书，不得不说，书写得是很好的，但是读的时候也不能完全照搬书中的内容，要知道这本书的写作背景是 20 年前的美国，和现在的中国国情还是有很大差别的。如果学过会计学里的复式记账法，会对这本书有更多的思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/111489443&#34;&gt;17年前，在电子词典上做《伏魔记》的开发者&lt;/a&gt;&lt;/strong&gt; by L4ughing，步步高学习机几乎是我的编程启蒙，学会的第一门语言便是运行在步步高上的 BBK Basic（Basic 语言的一门方言），这篇文章回忆了通宵虫和南方小鬼开发《伏魔记》前前后后的故事，独属于九零年代的记忆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.listennotes.com/blog/the-boring-technology-behind-a-one-person-23/&#34;&gt;The boring technology behind Listen Notes&lt;/a&gt;&lt;/strong&gt; by Wenbin Fang，一人公司背后的技术架构是什么样的？作者是 Listen Notes 的创始人，这篇文章介绍了 Listen Notes 背后的种种技术细节，没有花哨的微服务，不追求新技术，目标是完成功能，毕竟一个人精力有限，还要陪家人，怎么简单怎么来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://liqi.io/liucixin/&#34;&gt;如何写一部雨果奖作品？《三体》刘慈欣分享了他的工具｜利器×刘慈欣&lt;/a&gt;&lt;/strong&gt; by 利器，刘慈欣写出了雨果奖的《三体》，肯定有什么能极大提高工作效率的工具吧？「没有，我用的都是人尽皆知的东西。」&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://wxn.qq.com/cmsid/CUL2014111500869501&#34;&gt;钱锺书是这样做读书笔记的&lt;/a&gt;&lt;/strong&gt; by 杨绛，这篇文章是《钱钟书手稿》的序言，钱钟书做笔记要比读书多花一倍的时间，可见笔记在他心中是多么重要，「书非借不能读」，有书赶紧读，读完赶紧做笔记。「无数的书在我家流进流出，存留的只是笔记，所以我家没有大量藏书。」&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://fs.blog/wp-content/uploads/2017/02/Naval-Ravikant-TKP.pdf?utm_source=wanqu.co&amp;amp;utm_campaign=Wanqu+Daily&amp;amp;utm_medium=website&#34;&gt;Naval Ravikant 播客文字稿&lt;/a&gt;&lt;/strong&gt; by Farnam Street，播客原文地址&lt;a href=&#34;https://fs.blog/knowledge-project/naval-ravikant/&#34;&gt;见这里&lt;/a&gt;，这份文字稿总共有 45 页，我还没有读完。Naval Ravikant 是 &lt;a href=&#34;https://angel.co/&#34;&gt;AngelList&lt;/a&gt; 的创始人，同时也是硅谷著名的投资人，他投资的公司有 Twitter、Uber、Stack Overflow，光看他投资的公司就知道是一个牛人了。他在这期播客里面讲了自己关于工作和生活的一些原则，播客的一个缺点是比较零碎，所以等我读完会提炼一些精华写篇文章。另外推荐 &lt;a href=&#34;https://fs.blog/&#34;&gt;Farnam Street&lt;/a&gt; 这个博客，博主是巴菲特和查理芒格的头号粉丝，上面有非常多高价值的内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分享 | 这周我在读什么 #002</title>
      <link>http://blog.jiayuanzhang.com/post/my-reading-list-002/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/my-reading-list-002/</guid>
      <description>&lt;p&gt;（本文首发于微信公众号，搜索「直觉泵 Intuition Pumps」关注）&lt;/p&gt;
&lt;p&gt;关于此系列：我会每周分享我这周正在读的书、文章和其他一些有意思的东西，主题不限，每周日更新。&lt;/p&gt;
&lt;p&gt;这是第 2 期的「每周我在读什么」，因为上周日带猫猫去做绝育手术，所以没有来得急更新，今天补上。&lt;/p&gt;
&lt;p&gt;最近一段时间，我每天几乎不读新闻了，甚至连疫情的数字也是几天才看一次，相比较一月底到二月初，基本上每天都要花大量的时间在刷疫情相关的新闻上，带来的只有愤怒和焦虑感。在不刷新闻后，这种感觉削减了很多。&lt;/p&gt;
&lt;p&gt;对于新闻，我有两点看法：1）对新闻要有自己的判断，有时候听取两方的意见可能会给自己带来更加客观的看法；2）真正重要的新闻你不去看也会知道（朋友圈、闲聊）。&lt;/p&gt;
&lt;p&gt;ok，下面是本期正式的内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://book.douban.com/subject/1095634/&#34;&gt;《小狗钱钱》&lt;/a&gt;&lt;/strong&gt; by 博多·舍费尔，今年的阅读计划里有一个主题是「理财投资」，所以这本书算是这个 Reading List 里的第一本，非常轻松易读，作者以一种童话的方式给大家讲述了理财的基本知识，比如多账户的思维、什么是股票和基金、如何投资等等。除了理财投资的内容，书中还介绍了一种非常有效的获取幸福感的方法：写成功日记，即每天写下几件觉得做得还不错的事。这个方法我在之前就在某个朋友那里学到了，并把它作为了我日记模板里的一个项目，实践了这么长时间，确实非常有效，我的关注点更多的放在了我做得好的地方，而不是有缺陷的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200304132601.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为这周某一天的成功日记和感恩日记）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://dev.to/devteam/the-dev-team-is-now-100-distributed-1g2e&#34;&gt;The DEV Team is now 100% Distributed&lt;/a&gt;&lt;/em&gt; by Jess Lee，最近因为疫情的原因国内的很多公司都开始实践远程工作，其实远程工作在国外并不是一个很新的东西，很多公司都是可以 work from home（例如 Google）或者 full-remote（例如 Basecamp），上一期我分享了一篇介绍 PingCAP 是如何进行远程工作的文章，今天分享的这篇是来自国外的一个开发者社区 DEV 的远程工作经验分享，DEV 的团队规模很小，只有几个人，所以对于一些初创的小规模团队有很好的借鉴意义。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://blog.janestreet.com/what-a-jane-street-dev-interview-is-like/&#34;&gt;What a Jane Street software engineering interview is like&lt;/a&gt;&lt;/em&gt; by Sebastian Funk，这篇文章介绍了 Jane Street 是如何做技术面试的，如果熟悉量化交易的同学肯定都知道这家华尔街非常著名的金融公司（公司的技术栈以 OCaml 语言为主）。企业招人的目的更多的是为了寻找一个 problem fixer（问题的解决者），那么如何才能找到一个合格的 problem fixer 呢？在双方信息都不对称的情况下，面试是一个最好的解决办法，所以说「面试」是一种解决双方信息不对称的办法，而不是目的。但是如果你通过某些手段，例如在程序员里面比较常见的刷题，就掩盖了面试真正的目的。所以 Jane Street 建议大家不要刷题，也不要面试完把题目公开给别人，他们看重的不是解出某道题这个结果（result），而是解题的过程（progress）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://austinkleon.com/2019/03/21/how-to-read-more-3/&#34;&gt;How to Read More&lt;/a&gt;&lt;/em&gt; by Austin Kleon，Austin 是一个设计师，同时也是一个畅销书作家：&lt;em&gt;Steal Like An Artist&lt;/em&gt;, &lt;em&gt;Show Your Work&lt;/em&gt;, &lt;em&gt;Keep Going&lt;/em&gt;，我前段时间刚读完了 &lt;em&gt;Show Your Work&lt;/em&gt; 这本书，他的书有一个非常鲜明的特点：有非常多的手绘图，并且阅读起来都比较轻松，如果你之前没有读过英文原版书，从他的书开始读起会是一个不错的选择。在这篇文章里，他介绍了自己多读书的一些经验，其中最重要的一点就是：读自己喜欢的书，如果你对一本书不感兴趣，就不要读它。我的经验是每天固定一个时间来读书（比如睡觉前），然后其他时间利用碎片时间来读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200304132629.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Austin Kleon 的 5 条多读书的建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你发现不喜欢这本书，就不要再读了（即使没读完！）&lt;/li&gt;
&lt;li&gt;随身携带一本书（推荐电子书）&lt;/li&gt;
&lt;li&gt;手机设置成飞行模式&lt;/li&gt;
&lt;li&gt;经常去逛书店（我会每天逛一下 Amazon Kindle 书城）&lt;/li&gt;
&lt;li&gt;分享你喜欢的书给别人&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://blog.samaltman.com/productivity&#34;&gt;Productivity&lt;/a&gt;&lt;/em&gt; by Sam Altman，Sam 是 Y Combinator 的前 CEO，去年卸任去了 Open AI（这也导致了 YC China 的解散，现在 YC China 改名为奇迹创坛）。这篇文章介绍了他的一些效率工具和方法，其中最重要的一点就是明确你要 focus 的内容，如果你在一条错误的道路上，那么走再远也是没有用的。其实生活中很多人追求各种提高效率的工具和方法，但是他们可能最简单的一点都没有做到，那就是找到最重要的事，「要事先行」可以说是任何高效的前提。我自己的看法是，每天明确三件（不要贪多，三件已经很多了）最重要的事，然后今天把精力都 focus 在这些事上就可以了，事实证明，大部分时候我只能完成其中的 1-2 件，但这已经算是很成功了。了解过时间管理的大概都清楚 GTD 这个理论，在使用了「要事先行」原则后，你会发现 GTD 中保存的那些可做可不做的事情，都可以不做，按照《精要主义》这本书里所说，「对于一件事，只有明确的 Yes 和坚决的 No」。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分享 | 这周我在读什么 #001</title>
      <link>http://blog.jiayuanzhang.com/post/my-reading-list-001/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/my-reading-list-001/</guid>
      <description>&lt;p&gt;（本文首发于微信公众号，搜索「直觉泵 Intuition Pumps」关注）&lt;/p&gt;
&lt;p&gt;这是第一期的「这周我在读什么」，每期文章我将分享一些我最近读（看）的觉得还不错的书籍或文章（视频）。因为每周我会阅读大量不同类型的内容，所以这个系列没有一个特定的主题，仅仅是分享我觉得比较有意思的东西。&lt;/p&gt;
&lt;p&gt;书籍阅读上，我每周会读 1-2 本书，大部分都是在 Kindle 上阅读，对于一些比较喜欢的书，我会买纸质版。基本上每本书我会读至少两遍：一遍阅读，一遍做笔记。&lt;/p&gt;
&lt;p&gt;文章阅读上，基本上只读 Instapaper&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;（一个稍后读工具）中保存的文章，每周一，Instapaper 会将未读的 50 篇文章打包成一本文集发送到我的 Kindle 中&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，然后接下来这一周我只需要读这个文集就可以了，阅读文章的方法同阅读书籍的方法。&lt;/p&gt;
&lt;p&gt;接下来就是本期的内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《每周工作 4 小时》&lt;/strong&gt;&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; by Tim Ferriss，Tim 是我最近两年比较喜欢的一个作家，之前看完了他根据播客访谈整理的《巨人的工具》&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;，做了大量的笔记。这本书读了大概有一个多月，中间断断续续，这周总算读完了。看了一下原版 &lt;em&gt;The 4-Hour Workweek&lt;/em&gt; 的出版日期，最早是 2007 年出版的，所以书中介绍的一些实操方法在现在看来已经见怪不怪了，比如说外包、无供应链销售（淘宝上大量的店铺都是直接把订单从阿里巴巴的货源发到买家手里）。但是其中的一些理念我觉得还是很有启发性的，书中提到的「迷你退休」的方式可以尝试一下：不要想着工作几十年然后等着退休，而是在工作的过程中进行间断性的迷你退休（几周到几个月）。最近的一些事实也表明，大部分人如果没有了工作其实是很无聊的，没有工作在家呆几十天就已经有点受不了了，更何况是几十年呢？ &lt;em&gt;The 4-Hour&lt;/em&gt; 系列的其他几本书也在我的阅读清单中： &lt;em&gt;The 4-Hour Body&lt;/em&gt;, &lt;em&gt;The 4-Hour Chef&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;这周另外在读的几本书是《伊利亚特》（荷马史诗）、 &lt;em&gt;How to Take Smart Notes&lt;/em&gt; 、 &lt;em&gt;Why We Sleep&lt;/em&gt; ，等读完了再来写推荐语。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Print Out Your Kid&amp;rsquo;s Nonfiction eBooks&lt;/strong&gt;&lt;/em&gt;&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; by Michelle Woo，这篇文章的一个观点是：你应该给你的孩子阅读纸质书。我虽然大部分的阅读都在 Kindle 上，但是仍然会买很多纸质书来收藏（或者重读），电子书现阶段在某些方面仍然比不上纸质书，比如说书籍的排版和装帧（新版的《穷查理宝典》&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;Kindle 版会让你觉得前后文不知所云，看了纸质版就知道了，那些突然插进来的都是页边的注释和小故事），更重要的一点是，纸质书被赋予了一种「教育意义」，阅读纸质书本身对于孩子来说就是一种教育行为，但是阅读电子书可能只会给孩子留下「爸爸一直在玩 iPad」的印象，也就起不到「多读书」的这种正面示范。所以，如果有条件，还是应该在家里有一面书墙，光想着有那么多书就是一件非常开心的事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/IMG_9475.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为我在上海的小屋，可以看到桌子上堆了很多纸质书）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;So You Want To Be A Writer? That&amp;rsquo;s Mistake #1&lt;/strong&gt;&lt;/em&gt;&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; by Ryan Holiday，Ryan Holiday 是亚马逊 Bussiness 分类中排名前 6 的畅销书作家，在这篇文章中，他指出了你不应该为了「成为一名作家」而写作，而是应该因为「发现了有趣的东西想要分享」来写作，这也是我写作的目标。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Here (with 2 Years of Exhausting Photographic Detail) Is How to Write A Book&lt;/strong&gt;&lt;/em&gt;&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt; by Ryan Holiday，另外一篇 Ryan 的文章（可能是读 Ryan 的博客时在 Instapaper 中保存了很多篇）。如果你想写一本书或者一篇论文，这篇文章会是一个很好的指南。另外，Ryan 还在文章中分享了他做 research 的利器：卡片笔记。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Here&amp;rsquo;s How Maria Popova of Brain Pickings Writes&lt;/strong&gt;&lt;/em&gt;&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt; by Copyblogger，如果你阅读英美文学比较多的话，那么你一定知道 &lt;em&gt;Brain Pickings&lt;/em&gt; 这个博客。我知道 Maria Popova 这个人是因为《巨人的工具》这本书，Tim Ferriss 的播客 &lt;em&gt;The Tim Ferriss Show&lt;/em&gt;&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt; 对 Maria Popova 有一期访谈。这篇文章 Maria 介绍了她是如何进行如此高产（每天更新 3 篇文章）的写作的：事先计划好每天要发布的文章，然后提前写好，当天发布即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PingCAP 的 5 年远程办公实践&lt;/strong&gt;&lt;sup id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;11&lt;/a&gt;&lt;/sup&gt; by 黄东旭，PingCAP 是我认为国内比较像 Basecamp 风格的一家公司，这篇文章中，PingCAP 的 CTO 黄东旭分享了他们是如何进行远程工作的。因为最近疫情的影响，很多公司都开始了远程工作，对于这种在国内还不是特别流行的工作方式，这篇文章给了很多实践方面的指导。我的观点是如果仅仅是因为疫情而进行远程工作，并不需要方方面面都做得很好，毕竟等疫情结束了还是要回到公司工作。远程工作更加适合规模比较小的团队，Basecamp 写的 &lt;em&gt;Remote&lt;/em&gt;&lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt; 这本书给了非常详细的指导。另外，Basecamp 在去年秋天发布了一本新书 &lt;em&gt;Shape Up&lt;/em&gt;&lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;，接受了 Basecamp 是如何以远程的方式开发产品的，目前还没有出版，我已经看完了，并且正在翻译中，有感兴趣的读者可以一起参与。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://instapaper.com&#34;&gt;https://instapaper.com&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.guidingtech.com/29107/instapaper-kindle-merits/&#34;&gt;https://www.guidingtech.com/29107/instapaper-kindle-merits/&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/10786476/&#34;&gt;https://book.douban.com/subject/10786476/&lt;/a&gt; &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/30400712/&#34;&gt;https://book.douban.com/subject/30400712/&lt;/a&gt; &lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://offspring.lifehacker.com/print-out-your-kids-nonfiction-ebooks-1837210172&#34;&gt;https://offspring.lifehacker.com/print-out-your-kids-nonfiction-ebooks-1837210172&lt;/a&gt; &lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.cn/dp/B07CSP9GDD/&#34;&gt;https://www.amazon.cn/dp/B07CSP9GDD/&lt;/a&gt; &lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://ryanholiday.net/so-you-want-to-be-a-writer-thats-mistake-1/&#34;&gt;https://ryanholiday.net/so-you-want-to-be-a-writer-thats-mistake-1/&lt;/a&gt; &lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/the-mission/here-with-2-years-of-exhausting-photographic-detail-is-how-to-write-a-book-fda1a6b40802&#34;&gt;https://medium.com/the-mission/here-with-2-years-of-exhausting-photographic-detail-is-how-to-write-a-book-fda1a6b40802&lt;/a&gt; &lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://copyblogger.com/how-maria-popova-writes/&#34;&gt;https://copyblogger.com/how-maria-popova-writes/&lt;/a&gt; &lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://tim.blog/podcast/&#34;&gt;https://tim.blog/podcast/&lt;/a&gt; &lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:11&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/104184804&#34;&gt;https://zhuanlan.zhihu.com/p/104184804&lt;/a&gt; &lt;a href=&#34;#fnref:11&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:12&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/25861795/&#34;&gt;https://book.douban.com/subject/25861795/&lt;/a&gt; &lt;a href=&#34;#fnref:12&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:13&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://basecamp.com/shapeup&#34;&gt;https://basecamp.com/shapeup&lt;/a&gt; &lt;a href=&#34;#fnref:13&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>直觉泵 Intuition Pumps | 快时代深度思考笔记</title>
      <link>http://blog.jiayuanzhang.com/post/wechat-intuition-pumps/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/wechat-intuition-pumps/</guid>
      <description>&lt;p&gt;（本文首发于微信公众号，搜索「直觉泵 Intuition Pumps」关注）&lt;/p&gt;
&lt;p&gt;我终于开始写微信公众号了。&lt;/p&gt;
&lt;p&gt;过去的几年中，很多人都问我为什么不开一个微信公众号？其实我是一直是排斥微信公众号这种媒介的，原因有三点：&lt;/p&gt;
&lt;p&gt;1）微信公众号是一个封闭的信息平台，不利于通用搜索引擎的检索。也就是说你在微信公众号中发布的文章，除了朋友圈分享或者直接复制链接，是很难在互联网中再次搜索到的，你分享的内容只会在某一段时间内被其他人看到，一旦热度过了，就（几乎）没有人能再看到你的文章了；&lt;/p&gt;
&lt;p&gt;2）除了不能在搜索引擎中搜索到公众号的文章，公众号中也没办法超链接到外部地址，除了其他的公众号文章，你很难引用其他的链接。写过论文的都清楚，一篇文章的引用是非常重要的，因为这给论述提供了事实论据来源，同时也是尊重别人劳动成果的一种体现；&lt;/p&gt;
&lt;p&gt;3）微信公众号上的文章控制权不在你自己手上。&lt;/p&gt;
&lt;p&gt;基于这上面三个原因，虽然我很早就注册了微信公众号，但是一直迟迟没有动笔，而是发表在自己的博客、知乎和其他一些平台上&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;但是最近在重新阅读了《富兰克林自传》之后，改变了这个看法。富兰克林在 1732 年以理查·桑德斯之名出版了《格言历书》，这本书有趣而又实用，很快就供不应求。&lt;/p&gt;
&lt;p&gt;他在书中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我看到人们纷纷阅读《格言历书》，几乎在宾夕法尼亚的每一个地方都能发现它的踪影。我认为它是对普通民众进行教诲熏陶的恰当工具，因为普通民众除了历书，基本不买任何书籍。于是我便在历书中那些重要日子的空白处嵌入了一些格言式的语句，灌输将勤奋和节俭作为致富之道的观念，以此保证人们的道德水准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这本《格言历书》出版后的几年时间里，宾夕法尼亚的财富增长有了极大的提升。&lt;/p&gt;
&lt;p&gt;这一段对我的触动特别大，我在当时的笔记中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个时代的传播媒介决定了这个时代大部分人能获取的信息来源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一个例子是春节回家发现我妈竟然也是抖音的用户，而且很大一部分信息来源都是从抖音上看来的。这又一次改变了我之前的看法，之前我对待抖音的态度一直是「蚕食注意力的危险产品」，这种「知乎精英式」&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;的思维完全没有看到抖音、快手这类产品的另一面：在某些群体中，它也可以充当一个传播知识的信息媒介，就如富兰克林的《格言历书》一样。&lt;/p&gt;
&lt;p&gt;「为了能让我写的文字被更多的人看到」，这就是我决定开始写这个公众号的原因。&lt;/p&gt;
&lt;p&gt;上面提到三个问题依然存在，但是也有解决办法：即不把公众号作为唯一的发布平台，这样可以避免信息封闭，我会在公众号文章发布后同步在博客中发布一篇存档（我使用 Ulysses 来编写文章，所以只需要导出两种不同的格式即可）。对于公众号上的不能引用外部连接的问题，我会采用脚注的方式&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;我把公众号的名字改成了「直觉泵 Intuition Pumps」，借用了丹尼尔•丹尼特（Daniel C. Dennett）所著的《直觉泵和其他思考工具》一书，「直觉泵」的含义即「思想实验」，在这本书中，丹尼尔融通计算机科学、心理学、神经科学、语言学、人工智能，倾囊相授他一生至今所搜集的各种好用的思考工具。&lt;/p&gt;
&lt;p&gt;这个公众号的定位是「快时代深入思考笔记」，是「笔记」，不是「指南」、「权威」、「专家」，所以可能对你有用，也可能无用。我的职业是一名程序员，但是在这里我不打算写太多涉及具体编程知识方面的内容，一来移动端并不适合代码的阅读，二来在专业领域方面写得比我好的太多了。我更想写一些在自己专业领域外的思考：&lt;/p&gt;
&lt;p&gt;1）阅读分享。阅读是一种输入的过程，为了避免「勤于动手，懒于动脑」，我会把阅读过的一些书分享给大家，这些书评会更侧重与我自己的阅读感想；&lt;/p&gt;
&lt;p&gt;2）思考笔记。除了阅读书籍和文章产生的思考外，我还会从从这些笔记中孵化出自己的思考内容，我称之为思考笔记；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200204174522.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图为我在 Notion 中记录的思考笔记）&lt;/p&gt;
&lt;p&gt;3）创业笔记。这里的创业并不仅仅是是创立一家公司，运营好自己这个个体也算是一种 startup；&lt;/p&gt;
&lt;p&gt;4）效率。过去的几篇关于个人效率提升的文章在全网都有几十万的阅读&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;，所以我会写一些在效率提升方面的心得。&lt;/p&gt;
&lt;p&gt;我不会做什么？&lt;/p&gt;
&lt;p&gt;1）广告。写微信公众号并不是我的一个收入来源，更多的是作为一种扩大影响力的工具&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;，所以我不会在我的文章中给别人做广告；&lt;/p&gt;
&lt;p&gt;2）迎合读者。基于上条，我的写作不对读者有义务，所以我不会因为读者喜欢看什么就写什么，「为自己写作」是这个公众号的前提；&lt;/p&gt;
&lt;p&gt;3）追热点。虽然追热点的文章短时间内能够获取大量的流量&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;，但这和「为自己写作」这个原则不符，除非是我想写东西。&lt;/p&gt;
&lt;p&gt;虽然我的文字并不能和丹尼尔的著作比肩，但是我相信每一个人的思考过程和结果都是有价值的，即使这部分价值的受益群体很小。我的目标就是让这个群体变得更大一些。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;博客：http://blog.jiayuanzhang.com; 知乎：https://www.zhihu.com/people/forrest-chang &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;抖音是否正在毁掉中国部分的年轻人？ &lt;a href=&#34;https://www.zhihu.com/question/319258164&#34;&gt;https://www.zhihu.com/question/319258164&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;例如这就是一个脚注。 &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;用 OmniFocus 3 完成了上千个任务后，我总结出了这些经验 &lt;a href=&#34;https://sspai.com/post/49105&#34;&gt;https://sspai.com/post/49105&lt;/a&gt; &lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;11 Reasons Not to Become Famous (or “A Few Lessons Learned Since 2007”) &lt;a href=&#34;https://tim.blog/2020/02/02/reasons-to-not-become-famous/&#34;&gt;https://tim.blog/2020/02/02/reasons-to-not-become-famous/&lt;/a&gt; &lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;《柳叶刀》发表关于 2019-nCoV 新型冠状肺炎的专刊时，我写了一篇论文分析，一天的时间就获得了十几万的阅读量，&lt;a href=&#34;https://twitter.com/Tisoga/status/1220881796142895106&#34;&gt;https://twitter.com/Tisoga/status/1220881796142895106&lt;/a&gt; &lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>2020 二月阅读计划</title>
      <link>http://blog.jiayuanzhang.com/post/2020-02-reading-plan/</link>
      <pubDate>Sun, 19 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2020-02-reading-plan/</guid>
      <description>&lt;p&gt;Austin Kleon 在 &lt;em&gt;Show Your Work&lt;/em&gt; 中说过：“Shall something small everyday.“ 所以之后会每个月分享一下我自己的阅读计划，并简单说一下为什么要读这本书。&lt;/p&gt;
&lt;p&gt;因为一月份还只剩下 10 天，所以一并放到二月的读书计划中。今年的一个目标是开启自己的副业，所以大部分数目也是和这个相关的。&lt;/p&gt;
&lt;p&gt;另外，我建立了一个 Mail List，每周会分享一些书籍和文章的阅读感想，感兴趣的欢迎订阅：&lt;a href=&#34;https://tinyletter.com/JiayuanZhang&#34;&gt;https://tinyletter.com/JiayuanZhang&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;每周工作-4-小时by-tim-ferriss&#34;&gt;《每周工作 4 小时》by Tim Ferriss&lt;/h2&gt;
&lt;p&gt;一月份刚读完 &lt;a href=&#34;https://tim.blog/&#34;&gt;Tim Ferriss&lt;/a&gt; 的《巨人的工具》，一本 700 多页的访谈录合集，几乎都是 Tim 在 &lt;a href=&#34;https://tim.blog/podcast/&#34;&gt;&lt;em&gt;The Tim Ferriss Show&lt;/em&gt;&lt;/a&gt; 上的采访整理。另一本类似的书是&lt;a href=&#34;https://book.douban.com/subject/27182667/&#34;&gt;&lt;em&gt;Tribe of Mentors&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;《每周工作 4 小时》（&lt;em&gt;The 4-hour Workweek&lt;/em&gt;）这本书是 Tim 10 年前写的了，一直在各个榜单的畅销列表中。书中提到的「&lt;a href=&#34;https://en.wikipedia.org/wiki/Digital_nomad&#34;&gt;数字游民&lt;/a&gt;」的方式一直是我梦想的工作方式，另一个原因是今年的目标是在现有工作的基础上开启一个 side project，希望能从这本书中获取一些灵感。&lt;/p&gt;
&lt;p&gt;亚马逊没有电子版卖，所以买的纸质版，但是看的还是从某处找来的电子版。&lt;/p&gt;
&lt;h2 id=&#34;鞋狗by-phil-knight&#34;&gt;《鞋狗》by Phil Knight&lt;/h2&gt;
&lt;p&gt;这本书一直躺在我的待读清单里面，好几次逛书店都看到了，但是因为纸质版开本太大的原因并没有买。&lt;/p&gt;
&lt;p&gt;这本书吸引我的原因是它并不是讲 Nike 是如何叱咤商界的，而是一个普通人平凡的创业故事。书中所写到 Nike 上市之前就戛然而止了，而 Nike 的股价从上市到现在已经涨了 600 多倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20200119184535.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Phil Knight 的文笔也非常好，和读&lt;a href=&#34;https://book.douban.com/subject/26759508//&#34;&gt;《硅谷钢铁侠》&lt;/a&gt;完全是两种感觉（后者感觉有点偏流水账），不论是作为一个 Nike 或 AJ 粉，还是一个想要学习创业经验的初学者，这本书都是一个不错的推荐。&lt;/p&gt;
&lt;p&gt;读的 Kindle 版。&lt;/p&gt;
&lt;h2 id=&#34;设计冲刺by-jake-knapp&#34;&gt;《设计冲刺》by Jake Knapp&lt;/h2&gt;
&lt;p&gt;之前读过 &lt;a href=&#34;https://jakeknapp.com/&#34;&gt;Jake Knapp&lt;/a&gt; 的另一本书&lt;a href=&#34;https://book.douban.com/subject/30327043/&#34;&gt;&lt;em&gt;Make Time&lt;/em&gt;&lt;/a&gt;，这本书讲的是如何用 5 天的时间快速 Shape 一个产品原型。Sprint 中文翻译过来就是「加速」。&lt;/p&gt;
&lt;p&gt;Basecamp 在 2019 年也写了一本如何快速开发产品原型的书：&lt;a href=&#34;https://basecamp.com/shapeup&#34;&gt;&lt;em&gt;Shape Up&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在的互联网公司开发产品都比较遵循 MVP&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 的原则：先做出一个最小可用产品，然后放到市场中看看效果，再进行迭代改进。&lt;/p&gt;
&lt;p&gt;读的 Kindle 版。&lt;/p&gt;
&lt;h2 id=&#34;穷查理宝典by-charlie-munger&#34;&gt;《穷查理宝典》by Charlie Munger&lt;/h2&gt;
&lt;p&gt;这本书从 2019 年 12 月份就开始读了，读到现在还没有读完。在《巨人的工具》中是推荐次数最多的书之一。&lt;/p&gt;
&lt;p&gt;纸质版的装帧比电子版好太多了，就是开本比较大，不适合携带，所以还是读 Kindle 版，也方便整理笔记。&lt;/p&gt;
&lt;p&gt;这本书也不是需要从头到尾读的，例如一些关于投资的，对于目前的我来说并没有什么特别的用处，所以可以快速略过，以后需要的时候再回来看。&lt;/p&gt;
&lt;h2 id=&#34;why-we-sleep-by-matthew-walker&#34;&gt;&lt;em&gt;Why We Sleep&lt;/em&gt; by Matthew Walker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.gatesnotes.com/Books&#34;&gt;Bill Gates&lt;/a&gt; 推荐过，他的&lt;a href=&#34;https://www.gatesnotes.com/Books/Why-We-Sleep&#34;&gt;书评&lt;/a&gt;。Bill 这种时间非常宝贵的人推荐的书无脑读就是了。&lt;/p&gt;
&lt;p&gt;读的 Kindle 版。&lt;/p&gt;
&lt;h2 id=&#34;how-to-take-smart-notes-by-sönke-ahrens&#34;&gt;&lt;em&gt;How to Take Smart Notes&lt;/em&gt; by Sönke Ahrens&lt;/h2&gt;
&lt;p&gt;这本书是无意中发现的，利用理发的时间看了一章，发现非常有趣。书中提到的关于做笔记的方法和我使用的卡片笔记非常类似，但是更加系统。打算读完了之后根据这本书中所说的方法重新改进一下自己的卡片笔记系统。&lt;/p&gt;
&lt;p&gt;书中有些地方写得比较啰嗦，例如一些 why 的内容，只想看如何实践的话可以跳过这部分内容。&lt;/p&gt;
&lt;p&gt;读的 Kindle 版。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Minimum Viable Product, &lt;a href=&#34;https://en.wikipedia.org/wiki/Minimum_viable_product&#34;&gt;https://en.wikipedia.org/wiki/Minimum_viable_product&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>每周总结 2019 Week 50</title>
      <link>http://blog.jiayuanzhang.com/post/2019-week-50-review/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2019-week-50-review/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1512820790803-83ca734da794?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=2574&amp;amp;q=80&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;大概在上周末的时候，和朋友们制定了一个每月挑战的计划（输的人请其他参与人吃饭），我的挑战是一个月内读完 5 本书，写 2 篇书评。截止到目前为止，已经完成了 3/5，进度还是挺快的。&lt;/p&gt;
&lt;p&gt;另外这篇文章大部分是在碎片时间内写的，比如中午吃饭的时候、等咖啡的时候，这些时间里写完了大部分的内容。&lt;/p&gt;
&lt;h2 id=&#34;做计划的-11-个流程&#34;&gt;做计划的 11 个流程&lt;/h2&gt;
&lt;p&gt;接近 2020 年了，如何制定新的一年的计划？最近在 YouTube 上看到了一个关于如何制定计划的视频，分享一下其中的观点，用 11 个步骤来制定计划。&lt;/p&gt;
&lt;p&gt;视频地址：&lt;a href=&#34;https://youtu.be/QyS2P-oDaK4&#34;&gt;https://youtu.be/QyS2P-oDaK4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）把目标写下来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果只是把目标放在脑子里，肯定会忘记，所以制定计划的第一步就是把目标写下来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）在各个方向设定目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视频里面提到了四个方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;健康&lt;/li&gt;
&lt;li&gt;财富&lt;/li&gt;
&lt;li&gt;爱&lt;/li&gt;
&lt;li&gt;快乐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我认为这四个方向是纯目标导向的，例如工作会带来财富，和家人相处会带来爱等。&lt;/p&gt;
&lt;p&gt;你也可以按照领域来进行划分，例如工作、学习、生活、兴趣等。&lt;/p&gt;
&lt;p&gt;一定要把目标写得清楚，这样完成的概率才更高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）写下为什么要完成这些目标，赋予意义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一点作者参考了 Tony Robbins 的 &lt;a href=&#34;https://www.tonyrobbins.com/pdfs/Workbook-Time-of-your-Life.pdf&#34;&gt;RPM&lt;/a&gt; 目标设定方法。什么意思呢，你需要问一下自己，为什么需要设定这个目标（Why）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）为目标设定完成期限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有 Deadline 的目标注定不会完成。所以需要为目标设定 Deadline，对于比较小的目标，可以直接设定一个 Deadline，对于更大一些的目标，可以分解成一个一个的小目标来设定 Deadline。&lt;/p&gt;
&lt;p&gt;例如 2020 年我有一个目标是「读完 100 本书」，这个目标很大，可以把它分解成：每个季度阅读 25 本书，然后这个目标的 Deadline 就是每个季度末。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）检视目前阻碍目标完成的点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了完成这个目标，有什么弱点、阻碍的地方是我需要先去解决的？&lt;/p&gt;
&lt;p&gt;例如我有一个目标是在投资领域有一点成果，阻碍我的点事我对金融投资了解非常少，这是我的短板，是需要去解决的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6）针对这些阻碍点，你需要什么样的环境、资源，做什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面说了，「我对金融投资领域了解过少」是一个阻碍点，那么为了增强短板，我需要做些什么呢？一个可行的解决方法就是去阅读一些关于投资的书籍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7）把目标分解成行动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目标是一个结果为导向的东西，它本身是 undoable 的，那么我们需要把目标具化成具体的行动。&lt;/p&gt;
&lt;p&gt;还是针对上面的一个投资的例子，可以具化成下面几个具体的行动（仅仅是举例）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-2月阅读关于投资的书籍&lt;/li&gt;
&lt;li&gt;3 月梳理自己的资产结构&lt;/li&gt;
&lt;li&gt;4 月挑选合适的投资产品&lt;/li&gt;
&lt;li&gt;5 月形成自己的投资模式&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;8）把目标进行排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目标可能会设定很多，但是并不是所有的都值得完成，你需要把时间放在那些优先级更高的目标上。对目标进行排序，优先去完成优先级更高的目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9）让计划变成生活习惯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计划如果写完了就放在那里，很可能什么都完不成，所以我们需要把目标变成生活中的习惯。&lt;/p&gt;
&lt;p&gt;例如「阅读 100 本书」这个目标，可以编程「每天阅读 1h」这样的习惯。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10）马上行动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行力比什么都重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11）每天早上、晚上重新看一遍自己写的目标，做视觉化练习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目标需要时时刻刻放在大脑里，可以把这一条放在每天早上和晚上的流程中，例如早上起来就先 Review 一下今年的目标。&lt;/p&gt;
&lt;p&gt;什么是视觉化练习呢？可以想象一下完成了这个目标是什么样子的，这样可以让目标在大脑中记忆得更加深刻。&lt;/p&gt;
&lt;p&gt;如果你有用 Anki 的习惯，还可以把目标加到 Anki 中来时时复习。&lt;/p&gt;
&lt;h2 id=&#34;用一张便利贴来规划一天的工作&#34;&gt;用一张便利贴来规划一天的工作&lt;/h2&gt;
&lt;p&gt;这个方法是我在《Make Time》这本书中学到的，目的是聚焦每天最重要的事情。因为 todo list 太多了，要做完几乎不可能，所以我们优先把其中最重要的事情做完就可以了。&lt;/p&gt;
&lt;p&gt;使用方法也非常简单，把一个便利贴分成 4 个部分，最上面的写下今天要做的最重要的事（One Big Thing），下面写上三件次重要的事（3 Medium Things）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20191216115620.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;例如，下面这个是我今天的一页便利贴：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20191216115545.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我今天最重要的事就是写这篇博客。&lt;/p&gt;
&lt;p&gt;这个方法和我&lt;a href=&#34;http://blog.jiayuanzhang.com/post/2019-week-49-review/&#34;&gt;上周总结&lt;/a&gt;里所写的「每日三件事」也非常类似，主要的原理就是聚焦最重要的事情。&lt;/p&gt;
&lt;p&gt;如果便利贴上的事情都做完了怎么办？《Make Time》中给出的建议是今天可以先不再做其他事了，或者找一些比较轻松的事情来做，因为今天已经把最重要的事情做完了，已经是一个 High Productive 的一天（想象一下，之前有多少天是每天都完成了最重要的事呢）。&lt;/p&gt;
&lt;p&gt;我的实践是如果还在工作中，我会挑一些不那么耗费脑力的工作来做，例如开会、评审需求之类的。另外要确保每天的 One Big Thing 确实是有一点挑战的，要不然太容易就太容易完成了（刚开始可以从简单的一个小事做起）。&lt;/p&gt;
&lt;h2 id=&#34;3wh2t-阅读笔记法&#34;&gt;3WH2T 阅读笔记法&lt;/h2&gt;
&lt;p&gt;这个方法是我自己在阅读的过程中摸索出来的方法（Google 了之后还没有发现有相同的），和&lt;a href=&#34;https://wiki.mbalib.com/wiki/5w1H&#34;&gt;5W1H 分析法&lt;/a&gt;类似。&lt;/p&gt;
&lt;p&gt;具体含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Who：这本书是谁写的？或者这本书的主人公是谁？&lt;/li&gt;
&lt;li&gt;Why：为什么要读这本书？&lt;/li&gt;
&lt;li&gt;What：这本书讲了什么？&lt;/li&gt;
&lt;li&gt;How：这本书提供了哪些行动指南？&lt;/li&gt;
&lt;li&gt;Think：读完这本书我自己的想法是什么？&lt;/li&gt;
&lt;li&gt;Todo：读完这本书之后我想做什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/%E9%BA%A6%E8%82%AF%E9%94%A1%E7%B2%BE%E8%8B%B1%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BB%E6%B3%95.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（上图是我读《麦肯锡精英高效阅读法》所做的一个 3WH2T 笔记）&lt;/p&gt;
&lt;p&gt;这种笔记的好处是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让你保持主动阅读的状态，带着问题去驱动阅读；&lt;/li&gt;
&lt;li&gt;可以在之后快速回顾一本书，好的书是读一遍不够的，这种方法使你不需要再去读原书，直接看笔记就可以了；&lt;/li&gt;
&lt;li&gt;把书中的内容转换成行动，读书的目的如果不是为了消遣，肯定是想要有所得的。而最好的办法就是去实践书中的东西，所以读完一本书后要想想去做些什么。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个笔记还只是原材料，是给自己看的，如果想给别人看，还需要从笔记中提炼出一些观点来，例如写一篇书评。&lt;/p&gt;
&lt;h2 id=&#34;不要给-evernote-分类&#34;&gt;不要给 Evernote 分类&lt;/h2&gt;
&lt;p&gt;在过去使用 Evernote 的 5 年时间里，我重构了不下 10 次笔记本的分类方法，因为 Evernote 不支持无限层级的笔记本，所以还特地使用了&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9D%9C%E5%A8%81%E5%8D%81%E8%BF%9B%E5%88%B6%E5%9B%BE%E4%B9%A6%E5%88%86%E7%B1%BB%E6%B3%95&#34;&gt;杜威十进制图书分类法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20191216141838.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是，这些分类真的有意义吗？在这么长的使用时间里，很少出现点击到某个分类中去查看笔记的情形，大部分情况还是通过搜索来完成。后来在看奥野宣之的《如何有效阅读一本书》的时候，他的观点是笔记本不需要分类，这样做的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么笔记都可以往里面塞，写笔记前不需要思考过多；&lt;/li&gt;
&lt;li&gt;没有分类才更加活用，而且避免陷入「不知道放在哪个笔记本」的分类困境；&lt;/li&gt;
&lt;li&gt;避免完美主义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;纸质笔记本尚有这些优点，更别提 Evernote 了，完全可以借助搜索找到任何内容。我现在使用三个笔记本来分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20191216140625.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A@Inbox：所有的笔记先放到 Inbox 中；&lt;/li&gt;
&lt;li&gt;B@Notes：所有我自己写的内容；&lt;/li&gt;
&lt;li&gt;C@References：所有别人写的内容（摘录、Web Clip 的内容）；&lt;/li&gt;
&lt;li&gt;Z@External：外部笔记本（多看、Kindle 笔记同步等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用这个笔记本体系再也不需要管分类了，需要用的时候直接 &lt;code&gt;CMD+J&lt;/code&gt; 呼出搜索框搜索。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20191216140850.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;不要陷入完美主义的陷阱。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>每周总结 2019 Week 49</title>
      <link>http://blog.jiayuanzhang.com/post/2019-week-49-review/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2019-week-49-review/</guid>
      <description>&lt;p&gt;最近一年，长文写得少了，大部分时间都是在 Twitter 上输出观点，这存在两个缺点：1）思考过于碎片化；2）思考的内容过于浅显，没有深入。但是如果每个观点都需要输出一篇长文的话，我实在也做不到（博客的 Draft 里面躺了几十篇草稿，还有几十个 Idea 等着去写）。所以可以取一个中间值，在博客上记录下每周的思考、见闻、阅读感想以及做了什么，这比 Twitter 上的一百多字要好了许多。&lt;/p&gt;
&lt;h2 id=&#34;重新阅读书籍&#34;&gt;重新阅读书籍&lt;/h2&gt;
&lt;p&gt;过去一年，被碎片化的内容占去了太多时间，虽然每天还保持着阅读的习惯，但是书籍的阅读量下降了很多，大部分时间都在阅读保存在 Instapaper 中的稍后读文章。阅读单篇文章的一个坏处就是无法形成一个体系化的知识结构，可能我读了几十篇关于 Startup 的文章都不如去把《从零到一》读一遍来得有效。&lt;/p&gt;
&lt;p&gt;但是稍后读还是有它的作用的：&lt;/p&gt;
&lt;p&gt;1）获取资讯。稍后读的内容一般半衰期都比较短，偏向于时效性比较强的内容，可以很快速的反应一段时间的热点是什么。例如，经常看 36kr 话，虽然不会有什么太多营养价值的内容，但是可以知道最近的行业动态以及资本方向。&lt;/p&gt;
&lt;p&gt;2）知道别人是怎么做的。学习别人的经验是很重要的一件事，这也是我很喜欢阅读个人博客的原因，学习别人对待某件事的看法可以给自己提供一个新的思考角度。&lt;/p&gt;
&lt;p&gt;另外，稍后读除了纯「碎片化」阅读之外，也可以进行主题阅读，例如我订阅了 Instapaper 会员之后，是支持全文搜索的，所以如果我想快速了解某个领域的知识/动向的话，我会从我的稍后读保存的文章里进行全文搜索，然后再依次阅读，这比漫无目的的碎片化阅读来的有效的多，也比直接阅读一本书来的快速。&lt;/p&gt;
&lt;p&gt;为了让自己保持一个系统性的阅读，最近几周的时间内又重新开始阅读书籍了，到目前为止，已经读完了《ReWork》、《Shape Up》（Basecamp 新出的书，目前还没出版）、《麦肯锡精英的高效阅读法》，正在读《穷查理宝典》、《硅谷钢铁侠》，基本上一周两本书的速度。&lt;/p&gt;
&lt;h2 id=&#34;和伟人做朋友&#34;&gt;和伟人做朋友&lt;/h2&gt;
&lt;p&gt;在我的阅读内容中，最喜欢阅读的一个类型就是传记类作品了，包括一些日记、随笔集。你可以深入伟人们的生活，去看看他们在某些情况下是怎么做的。和富兰克林做朋友不太可能，但是你可以阅读他的传记，你可以从传记中知道为什么他会有这么多的成就，他在遇到一些困难的时候是如何解决问题的。经验是一件非常宝贵的东西，更何况是伟人们的经验。&lt;/p&gt;
&lt;p&gt;为此，我在 Evernote 中建立了一个 Notebook 叫「Make Friends with Great」，目的就是记录一些传记的摘录和网上搜集的轶事。今天在阅读《穷查理宝典》的时候，发现查理竟然和我有相同的想法！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本杰明·富兰克林的职业生涯横跨政府、商业、金融业和工业多个部门；每当公开发表演讲或找到听众的时候，不管何时也无论听众是多是少，查理总是流露出对他的仰慕。在喜诗糖果公司 75 周年庆典上，查理说：「我本人是个传记爱好者。我认为当你试图让人们学到有用的伟大概念时，最好是将这些概念和提出它们的伟人的生活与个性联系起来。我想你要是能够和亚当·斯密交朋友，那你的经济学肯定可以学得更好。和「已逝的伟人」交朋友，这听起来很好玩，但如果你确实在生活中与那些有杰出思想的已逝的伟人称为朋友，那么我认为你会过上更好的生活，得到更好的教育。这种方法比简单地给出一些基本概念好很多。」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;如何做读书笔记&#34;&gt;如何做读书笔记&lt;/h2&gt;
&lt;p&gt;如果阅读一本书不能给你留下什么，那么相当于没有读，所以我的宗旨是：阅读一定要做笔记。如何做笔记是一件非常复杂的事情，除了要考虑不同的阅读介质外（Kindle、纸质书），还需要考虑到做笔记的时间成本。&lt;/p&gt;
&lt;p&gt;一个重要的前提是，所有的笔记都要能够搜索，如果笔记不能搜索，那么想要快速找到一年前某本书中的某个令你精神一振的段落变得几乎不可能。所以我这里推荐使用 Evernote 或其他能够进行全文搜索的工具（Evernote 除了能保存你的阅读笔记外，还可以保存任何你想要搜索的知识，可以作为你的第二大脑，这一点上，Bear、Notion、Notes 等工具是比不了的）。&lt;/p&gt;
&lt;p&gt;所以不管是纸质书还是 Kindle 中的笔记，都需要整理到 Evernote 中。Kindle 如果是在 KPW 或其他阅读器上阅读的话，可以生成一份 clipping.txt，然后借助 clippings.io 这个网站就可以导出笔记，然后并导入到 Evernote 中。但是如果是在 Mac 或 iOS 版上阅读的话，只能够通过 Kindle 内置的 APP 来进行笔记导出，但是这种导出存在一个问题，内容是不完整的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20191203140050.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，可以看出每条笔记最后都缺失了，不知道是 Bug 还是 Amazon 有意为之（版权问题？）。这样会导致一个问题，为了笔记的完整性，我只能通过 Kindle 来阅读，Mac 和 iOS 版的 Kindle APP 只能作为一个查询的工具。&lt;/p&gt;
&lt;p&gt;纸质书的话，做笔记是非常方便，直接拿笔写就好了，我一般为了保证阅读的连贯性，只会用笔划线。但是电子化是个问题，我先在的解决办法是等一本书读完了之后找时间统一把笔记抄到 Evernote 上去（虽然我打字速度很快，但是也要花挺长时间），这样也可以算作一种重读。&lt;/p&gt;
&lt;p&gt;不管是电子书还是纸质书，读完了我都会写一份简单的笔记，这个是除了摘录外自己的观点输出。&lt;/p&gt;
&lt;h2 id=&#34;电子书-vs-纸质书&#34;&gt;电子书 vs 纸质书&lt;/h2&gt;
&lt;p&gt;作为一个实用主义者，我是比较偏爱电子书的。因为读书的目的是为了获取知识或提升心智，一个很重要的功能就是能够搜索到以前读的内容（我记性很差，上个月看的书已经忘记讲什么了，除了一些特别有趣的东西）。&lt;/p&gt;
&lt;p&gt;但是纸质书比电子书好的地方有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纸质书的排版要远远优秀于电子书&lt;/li&gt;
&lt;li&gt;可以看到厚度，可以闻到书香&lt;/li&gt;
&lt;li&gt;可以收藏，也可以作为礼物&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然上面几个功能对一个实用主义者而言，作用并不是太大，但是能够给阅读带来一种强烈的仪式感。&lt;/p&gt;
&lt;p&gt;李如一曾在一天世界的一期博客中说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、我不希望多年后自己的藏书只是一堆数字文件；&lt;/p&gt;
&lt;p&gt;二、如果我大部分时间读电子书，从我女儿的角度看，我就只是长时间盯着 iPad 看而已。我没有提供「正在阅读的人类」这一原型供她模仿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的解决办法是主力阅读电子书，然后发现比较好的书买一本纸质书进行收藏，在微信读书上几乎不需要花钱买书，这样只需要花一分钱买纸质书了。但是并不是所有书都是由电子版的，所以还是需要去阅读纸质书。&lt;/p&gt;
&lt;p&gt;唯一需要注意的是，保持一本书只在一个平台或介质上阅读，这样可以保证笔记不会一半在纸质书上，一半在电子书里。&lt;/p&gt;
&lt;p&gt;之前某天在 Evernote 中写过一篇笔记来分析到底是阅读纸质书还是电子书：&lt;a href=&#34;https://www.evernote.com/l/AqCDWgWYwnZPX4d17p3tfMv-YXpxuM7wNsc&#34;&gt;https://www.evernote.com/l/AqCDWgWYwnZPX4d17p3tfMv-YXpxuM7wNsc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;阅读工具的选择&#34;&gt;阅读工具的选择&lt;/h2&gt;
&lt;p&gt;这几天体验下来，发现还是使用 Kindle 阅读比较方便：&lt;/p&gt;
&lt;p&gt;1）墨水屏，和纸张更为接近。虽然微信读书和多看提供更好的排版，但是使用手机来阅读长时间眼镜还是有点酸的，手机上的干扰也比较多。&lt;/p&gt;
&lt;p&gt;2）Amazon 商城提供了很好的购书体验，我同时订阅了 Kindle Unlimited，在 Kindle Unlimited 中没有的书我会直接购买，如果商城中也没有（比如说一些英文书），我会找资源发送到 Kindle 中。&lt;/p&gt;
&lt;p&gt;3）统一只使用 Kindle 来阅读。这样可以保证所有的笔记都在 Kindle 的 My Clippings.txt 文件中，然后借助 clippings.io 这个网站可以方便地导出到笔记到 Evernote 中。&lt;/p&gt;
&lt;h2 id=&#34;番茄工作法&#34;&gt;番茄工作法&lt;/h2&gt;
&lt;p&gt;虽然我工作的时候会计时（使用 Toggl），但是很少用到番茄工作法，普通的番茄工作法在我看来有一个弊端:&lt;/p&gt;
&lt;p&gt;每个番茄 25 分钟，时间过短。25 分钟基本上做不了什么事情，或者刚刚进入工作的状态，这个时候再休息 5 分钟会打破这种工作的的状态。所以最好一个番茄的时间设定得更长一些，我设定的时间是 50 分钟，然后再休息 10 分钟。&lt;/p&gt;
&lt;p&gt;在看《Shape Up》这本书的过程中，学到的一个最重要的方法就是给要做的事情设定 Appetite（期望），而不是根据这个任务的工作量来设定时间。这样做的好处很明显，限定时间内完成某件事，目标更加明确，避免慢慢悠悠做事，而且也会防止陷入完美主义的时间旋涡中。《Shape Up》这本书想写介绍了 Basecamp 公司的工作方法，之后可能会写篇书评。&lt;/p&gt;
&lt;h2 id=&#34;每天最重要的三件事&#34;&gt;每天最重要的三件事&lt;/h2&gt;
&lt;p&gt;我通常使用 OmniFocus 来管理需要完成的任务，但是随着时间的累计，OmniFocus 中囤积的任务会越来越多，很多任务都是以后可能会做的（GTD 中的 Someday/Maybe），这些任务其实不做也没事，按照巴菲特的双清单法则，这些任务应该直接删掉不要做。&lt;/p&gt;
&lt;p&gt;所以这周我尝试了一下新的任务管理方法，主动写下今天要做的最重要的三件事，然后早上去公司就直接开始做，做完了这三件事就证明我这一天是高效的，这之后随便做什么都 OK 了。&lt;/p&gt;
&lt;p&gt;实践下来有几点建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最重要的事不一定是最紧急的，你肯定能区分的出来。如果某件事让你犹豫它重不重要，那它大概率是不重要的；&lt;/li&gt;
&lt;li&gt;最开始不要给自己设定太大的目标，三件事的可以先简单一些，我的三件事情基本都可以在半天内做完，这样保证了一天的开始就是高效的，然后想划水就可以划水了。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>每周评论 第一期</title>
      <link>http://blog.jiayuanzhang.com/post/weekly-readings-review-01/</link>
      <pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/weekly-readings-review-01/</guid>
      <description>&lt;p&gt;两年前曾经写过类似的文章：&lt;a href=&#34;http://blog.jiayuanzhang.com/post/weekly-reading-report-issue-01/&#34;&gt;这周在读什么 Issue#1&lt;/a&gt;，主要是为了分享一下最近在读、或者是看到的比较好的内容，但是没能坚持写下去，草稿箱里还躺着几篇未发布的阅读分享。这一次打算重写开始写，阮一峰老师已经写了&lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/06/weekly-issue-60.html&#34;&gt;60 期&lt;/a&gt;了。&lt;/p&gt;
&lt;p&gt;分享些什么内容？我的主要阅读来源是 Hacker News 和一些订阅的网站（我使用
inoreader RSS 服务），所以可能分享的大部分内容都是英文的，主题主要涵盖 &lt;strong&gt;编程&lt;/strong&gt; 、 &lt;strong&gt;创业&lt;/strong&gt; 、 &lt;strong&gt;效率&lt;/strong&gt; 这三个方面，每一次分享我会分别推荐几篇文章并写一些简单的评论，这些文章并不一定是最近发布的，主要看我阅读的时间。&lt;/p&gt;
&lt;p&gt;发布时间不定，但是保证一周至少发布一篇文章。&lt;/p&gt;
&lt;p&gt;我的稍后读流程（之后会写一篇文章来详细说明）：&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/%e9%98%85%e8%af%bb%e6%b5%81%e7%a8%8b.jpg&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;「每周评论」的标题借用陈独秀和李大钊在 1918 年创办的期刊 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编程&#34;&gt;编程&lt;/h2&gt;
&lt;h3 id=&#34;hacker-tools-hacker-tools&#34;&gt;&lt;a href=&#34;https://hacker-tools.github.io/&#34;&gt;Hacker Tools · hacker tools&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是 MIT 开设的一门课程，主要介绍了一些程序员使用的工具。计算机作为我们使用的工具，肯定是越高效越好，如何才能变得高效？在我看来，主要有这几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把重复性工作自动化，如果需要每天都重复做的事情，不如写几行脚本自动化；&lt;/li&gt;
&lt;li&gt;使用开源的工具，如果工具不适应你的工作流，完全可以自己动手改造它；&lt;/li&gt;
&lt;li&gt;KISS（Keep It Simple, Stupid）&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，例如命令行工具是符合 KISS 的，但是可以通过组合不同的 KISS 工具实现复杂的功能（例如管道）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Emacs 是一个 Hacker&amp;rsquo;s Tool，这门课程中推荐使用 Vim（我推荐 Emacs 和 Vim 双修，使用 Emacs 的 Evil 模式）。&lt;/p&gt;
&lt;p&gt;除了编辑器，这门课还讲了数据挖掘、版本控制系统、容器等内容，并且这门课在 Youtube
上有视频：&lt;a href=&#34;https://www.youtube.com/playlist?list=PLyzOVJj3bHQuiujH1lpn8cA9dsyulbYRv&#34;&gt;6.HT 2019 - YouTube&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;创业&#34;&gt;创业&lt;/h2&gt;
&lt;h3 id=&#34;there-were-17-000-youtubes-before-youtube&#34;&gt;&lt;a href=&#34;https://thenextweb.com/boris/2013/10/28/17000-youtubes-youtube/&#34;&gt;There were 17,000 YouTubes Before YouTube&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 Google launch 之前有 18 家做搜索引擎的，至少有两家和 Google 是做完全一样的业务；在 YouTube 之前有 17000 家（夸张？）做在线视频分享的服务；在 Facebook 前有
myspace、ICQ、MSN。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In other words; nothing is new, everything is a copy of something, or at least
an iteration on a previous idea.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Idea 被做过又怎么样，关键看你能不能有所创新或抓住时机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Their value is not in the idea itself, but the perfect timing and excution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;吸取别人失败的经验，站在巨人的肩膀上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal isn’t to reinvent the wheel or come up with an idea that no one else
has ever come up with. You can be very successful just taking something that
someone else failed at and do a better version, at a better time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;as-a-startup-founder-what-are-the-pros-and-cons-of-building-something-you-would-want-to-use-yourself&#34;&gt;&lt;a href=&#34;https://www.quora.com/As-a-startup-founder-what-are-the-pros-and-cons-of-building-something-you-would-want-to-use-yourself&#34;&gt;As a startup founder, what are the pros and cons of building something you would want to use yourself?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;创业做自己想用的东西有什么优缺点？Quora 的 Founder 给出了回答。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Building a product you would want to use yourself is motivating.&lt;/p&gt;
&lt;p&gt;It’s rare to hear about people who create software for fun that they themselves won’t use.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Motivation 可以让工作变得更加 enjoyable，连续加班也不觉得累，这是成功和个人发展的决定性因素。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Second, if you use a product yourself, your intuition will point more closely
toward the right strategy for the business.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说，没有什么坏处，都是显而易见的好处。&lt;/p&gt;
&lt;p&gt;为了创业而创业就会陷入下面的境地：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are not a typical customer of your product, you can build up this
intuition over time as you run a company, but you won’t start out with it,
because you haven’t been exposed to customers’ preferences in a deep way. This
can make it a lot harder to get initial traction or funding.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;效率&#34;&gt;效率&lt;/h2&gt;
&lt;h3 id=&#34;augmenting-long-term-memory&#34;&gt;&lt;a href=&#34;http://augmentingcognition.com/ltm.html&#34;&gt;Augmenting Long-term Memory&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Anki 是一个 Flashcard 软件，类似于 Supermemo，一般大家都用来背单词。这篇文章作者（是一个量子物理学家）介绍了他是如何用 Anki 来阅读论文的，包括如何在短时间内阅读并理解 AlphaGo 的论文。&lt;/p&gt;
&lt;p&gt;Anki 是一个长期记忆的工具，你可以用它来记住任何东西。Anki 的算法完全是开源的，你可以在 GitHub 上看到它的源码：&lt;a href=&#34;https://github.com/dae/anki&#34;&gt;https://github.com/dae/anki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人使用 Anki 的经验：&lt;/p&gt;
&lt;p&gt;作为背单词的工具，可以配置 Chrome 或 Firefox 的插件「Anki 划词制卡助手」，可以在阅读网页的过程中自动查词并保存到 Anki 对应的 Deck 中，还包含了阅读时的上下文。&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190726124109.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;图中绿框内即为当时阅读时的上下文，这种情境式背单词的方法比直接拿一本单词书来背效果好太多。&lt;/p&gt;
&lt;p&gt;除了用 Anki 来背单词，还可以用它来做卡片笔记，纳博科夫&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;就是使用卡片笔记来写作的。这种单个的卡片笔记方便记忆（一张卡片就一个知识点），例如下面是我记的一个卡片笔记：&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190726124607.png&#34;/&gt; 
&lt;/figure&gt;

&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;: &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%AF%8F%E5%91%A8%E8%AF%84%E8%AE%BA&#34;&gt;每周评论 - 维基百科，自由的百科全书&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;: &lt;a href=&#34;https://en.wikipedia.org/wiki/KISS%5Fprinciple&#34;&gt;KISS principle - Wikipedia&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;: &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%BC%97%E6%8B%89%E5%9F%BA%E7%B1%B3%E7%88%BE%C2%B7%E5%BC%97%E6%8B%89%E5%9F%BA%E7%B1%B3%E7%BE%85%E7%B6%AD%E5%A5%87%C2%B7%E7%B4%8D%E5%8D%9A%E7%A7%91%E5%A4%AB&#34;&gt;弗拉基米爾·弗拉基米羅維奇·納博科夫&lt;/a&gt; &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>给博客添加了全文 RSS</title>
      <link>http://blog.jiayuanzhang.com/post/add-full-content-rss/</link>
      <pubDate>Wed, 24 Jul 2019 21:59:00 +0800</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/add-full-content-rss/</guid>
      <description>&lt;p&gt;之前博客虽然也有 RSS，但是不是全文索引的，为了方便读者能够直接在 RSS 阅读器中阅读，花了点时间给博客添加了全文 RSS 输出。&lt;/p&gt;
&lt;p&gt;查阅文档&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;可知，Hugo 的 RSS 模板搜索顺序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34; data-lang=&#34;nil&#34;&gt;[layouts/index.rss.xml
layouts/home.rss.xml
layouts/rss.xml
layouts/list.rss.xml
layouts/index.xml
layouts/home.xml
layouts/list.xml
layouts/_default/index.rss.xml
layouts/_default/home.rss.xml
layouts/_default/rss.xml
layouts/_default/list.rss.xml
layouts/_default/index.xml
layouts/_default/home.xml
layouts/_default/list.xml
layouts/_internal/_default/rss.xml]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们随便按照顺序建立一个 xml 模板文件即可，例如，我们这里建立
&lt;code&gt;layouts/index.rss.xml&lt;/code&gt; 文件，使用 Hugo 官方提供的 RSS 模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;{{ printf &amp;#34;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=\&amp;#34;1.0\&amp;#34; encoding=\&amp;#34;utf-8\&amp;#34; standalone=\&amp;#34;yes\&amp;#34; ?&amp;gt;&lt;/span&gt;&amp;#34; | safeHTML }}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;rss&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;version&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2.0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:atom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.w3.org/2005/Atom&amp;#34;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;channel&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;{{ if eq  .Title  .Site.Title }}{{ .Site.Title }}{{ else }}{{ with .Title }}{{.}} on {{ end }}{{ .Site.Title }}{{ end }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;link&lt;/span&gt;&amp;gt;{{ .Permalink }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;link&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;&amp;gt;Recent content {{ if ne  .Title  .Site.Title }}{{ with .Title }}in {{.}} {{ end }}{{ end }}on {{ .Site.Title }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;generator&lt;/span&gt;&amp;gt;Hugo -- gohugo.io&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;generator&lt;/span&gt;&amp;gt;{{ with .Site.LanguageCode }}
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;language&lt;/span&gt;&amp;gt;{{.}}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;language&lt;/span&gt;&amp;gt;{{end}}{{ with .Site.Author.email }}
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;managingEditor&lt;/span&gt;&amp;gt;{{.}}{{ with $.Site.Author.name }} ({{.}}){{end}}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;managingEditor&lt;/span&gt;&amp;gt;{{end}}{{ with .Site.Author.email }}
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;webMaster&lt;/span&gt;&amp;gt;{{.}}{{ with $.Site.Author.name }} ({{.}}){{end}}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;webMaster&lt;/span&gt;&amp;gt;{{end}}{{ with .Site.Copyright }}
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;copyright&lt;/span&gt;&amp;gt;{{.}}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;copyright&lt;/span&gt;&amp;gt;{{end}}{{ if not .Date.IsZero }}
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;lastBuildDate&lt;/span&gt;&amp;gt;{{ .Date.Format &amp;#34;Mon, 02 Jan 2006 15:04:05 -0700&amp;#34; | safeHTML }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;lastBuildDate&lt;/span&gt;&amp;gt;{{ end }}
    {{ with .OutputFormats.Get &amp;#34;RSS&amp;#34; }}
        {{ printf &amp;#34;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;atom:link&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%q&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rel&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\&amp;#34;self\&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%q&lt;/span&gt; /&amp;gt;&amp;#34; .Permalink .MediaType | safeHTML }}
    {{ end }}
    {{ range .Pages }}
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;item&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;{{ .Title }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;link&lt;/span&gt;&amp;gt;{{ .Permalink }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;link&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;pubDate&lt;/span&gt;&amp;gt;{{ .Date.Format &amp;#34;Mon, 02 Jan 2006 15:04:05 -0700&amp;#34; | safeHTML }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;pubDate&lt;/span&gt;&amp;gt;
      {{ with .Site.Author.email }}&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;author&lt;/span&gt;&amp;gt;{{.}}{{ with $.Site.Author.name }} ({{.}}){{end}}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;author&lt;/span&gt;&amp;gt;{{end}}
      &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;guid&lt;/span&gt;&amp;gt;{{ .Permalink }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;guid&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;&amp;gt;{{ .Summary | html }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;item&lt;/span&gt;&amp;gt;
    {{ end }}
  &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;channel&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;rss&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，我们需要全局输出，只需要修改 &lt;code&gt;&amp;lt;description&amp;gt;{{ .Summary | html }}&amp;lt;/description&amp;gt;&lt;/code&gt; 为 &lt;code&gt;&amp;lt;description&amp;gt;{{ .Content | html }}&amp;lt;/description&amp;gt;&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt; 配置中的一些字段可以用来控制 RSS 的输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rssLimit&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 限制 RSS 文章输出的数量&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;languageCode&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en-us&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;copyright&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.&amp;#34;&lt;/span&gt;

[&lt;span style=&#34;color:#a6e22e&#34;&gt;author&lt;/span&gt;]
    &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;My Name Here&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最开始的时候生成 RSS 会抛出一些异常：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language&#34; data-lang=&#34;language&#34;&gt; error on line 455 at column 40: PCDATA invalid Char value 8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般来说，出现这些问题是因为 Markdown 文件中存在一些特殊字符，例如 &lt;code&gt;^H&lt;/code&gt;、&lt;code&gt;^E&lt;/code&gt; 等字符，解决办法有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 Hugo 的正则表达式替换掉特殊字符，参考文档&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;在 markdown 源文件中把特殊字符删除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，可以通过这个链接来订阅本博客：&lt;a href=&#34;http://blog.jiayuanzhang.com/post/index.xml&#34;&gt;http://blog.jiayuanzhang.com/post/index.xml&lt;/a&gt;&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/templates/rss/&#34;&gt;https://gohugo.io/templates/rss/&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/functions/replacere/#readout&#34;&gt;https://gohugo.io/functions/replacere/#readout&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>使用 Emacs &#43; ox-hugo 来写博客</title>
      <link>http://blog.jiayuanzhang.com/post/blog-with-ox-hugo/</link>
      <pubDate>Sun, 14 Jul 2019 00:31:00 +0800</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/blog-with-ox-hugo/</guid>
      <description>&lt;p&gt;最近开始重新使用 org-mode，在这之前大概有一年左右的时间，慢慢把一些东西从
org-mode 转移到别的工具上了，比如利用 OmniFocus 来管理任务，用 Devonthink 来管理笔记，用 Ulysses 来写作。虽然这些工具非常好用，但是总能找到一两个不满意的点，为此还写了不少脚本进行优化（这些 App 均支持 AppleScript），既然都是要写代码才能完全满足使用需求，不如直接使用 Emacs 来做这些事好了（目前已经将任务管理系统又迁移到 org-mode 上来了）。&lt;/p&gt;
&lt;p&gt;从 &lt;a href=&#34;http://blog.jiayuanzhang.com/post/use-devonthink-to-write-blog/&#34;&gt;上篇文章&lt;/a&gt; 可以知道，我开始使用 Devonthink 来写博客，配合 Alfred 的 Workflow 可以方便地生成 Hugo 的博客文章，其实就是简单地将 Devonthink 中的 Metadata 生成
YAML 格式的内容插入到 Markdown 文件中。&lt;/p&gt;
&lt;p&gt;如果你只使用 Markdown 来写作的话，这种写博客的流程是非常好的，配合一个 Markdown
编辑器（推荐 iA Writer），Devonthink 可以方便的作为管理博客文章的前端，另外再配合我写的 Alfred 全局搜索（支持拼音） Workflow，可以快速地找到所写的内容。&lt;/p&gt;
&lt;p&gt;但是，比起 Markdown，我更喜欢用 org-mode 来写东西。所以，我需要对上面这些流程做一些 Hack，其实也非常简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Devonthink 中建立 org 格式的文件（在 Devonthink 显示为 plain-text）；&lt;/li&gt;
&lt;li&gt;调用 Emacs 来打开这个文件（Open with Emacs，或者可以写一个脚本用 Alfred 来调用打开）；&lt;/li&gt;
&lt;li&gt;在 Emacs 中使用 org-mode 来完成写作；&lt;/li&gt;
&lt;li&gt;修改之前的 Alfred Workflow，检测到是 &lt;code&gt;.org&lt;/code&gt; 格式的文件就用 Pandoc 转换为 Markdown；&lt;/li&gt;
&lt;li&gt;利用 Hugo 生成博客内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然都使用 Emacs 来写了，不如直接舍弃 Devonthink 这个前端（Emacs 同样支持拼音搜索等功能），搜索了一下，发现了 ox-hugo 这个 Emacs package，这个 package 的优点在于：不需要舍弃掉之前用 Markdown 写的文章，可以在这个基础上继续用 org-mode 来写，即使之后想放弃 ox-hugo 了，也可以继续修改生成的 Markdown 文件。&lt;/p&gt;
&lt;p&gt;这篇文章我主要介绍一下如何使用 ox-hugo 来写博客，顺便介绍一下我的博客工作流，如果你是使用 Emacs 自带的 org-publish 而不是 Hugo 等外部静态网站生成工具的话，可以参考我几年前写的一篇文章：&lt;a href=&#34;http://blog.jiayuanzhang.com/post/how-to-use-emacs-and-org-mode-to-build-a-blog/&#34;&gt;使用 Emacs Org-mode + GitHub Pages 来写博客 -
Jiayuan&amp;rsquo;s Blog&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;主要用到的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Emacs + org-mode：写作 &amp;amp; 管理工具&lt;/li&gt;
&lt;li&gt;Alfred：脚本快速执行工具&lt;/li&gt;
&lt;li&gt;PicGo：图床工具&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190606165847.png&#34;/&gt; 
&lt;/figure&gt;

&lt;h2 id=&#34;安装与配置-ox-hugo&#34;&gt;安装与配置 ox-hugo&lt;/h2&gt;
&lt;p&gt;我使用的 Emacs 配置是 &lt;a href=&#34;https://github.com/hlissner/doom-emacs/tree/develop/&#34;&gt;Doom Emacs&lt;/a&gt;，我在 &lt;a href=&#34;https://www.bilibili.com/video/av54257764&#34;&gt;Hacking log #001 编写 Doom Emacs
private module&lt;/a&gt; 这个视频里有详细讲解如何使用 Doom Emacs 来安装第三方的 Package 以及如何编写自己的 module。这里我们把 ox-hugo 添加到自己的 &lt;code&gt;my-org&lt;/code&gt; module 中，非
Doom Emacs 的用户可以参考官方文档来进行配置：&lt;a href=&#34;https://ox-hugo.scripter.co/&#34;&gt;ox-hugo - Org to Hugo exporter&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;首先在 &lt;code&gt;my-org/packages.el&lt;/code&gt; 中添加 ox-hugo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-elisp&#34; data-lang=&#34;elisp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;;; packages.el&lt;/span&gt;
(package! ox-hugo)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后修改 &lt;code&gt;my-org/configle.&lt;/code&gt; ，使用 Doom Emacs 自定义的 &lt;code&gt;def-package!&lt;/code&gt; macro，其他用户可以使用 &lt;code&gt;use-package&lt;/code&gt; 或者直接使用 &lt;code&gt;require&lt;/code&gt; 来进行导入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-elisp&#34; data-lang=&#34;elisp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;;; config.el&lt;/span&gt;
(def-package! ox-hugo
  :after ox
  )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;开始写作&#34;&gt;开始写作&lt;/h2&gt;
&lt;p&gt;ox-hugo 支持两种方式来管理 org 格式的博客文章，一种是所有的文章都放在同一个 org
文件里，另一种是对不同的文章使用独立的 org 文件。因为最终都是导出 Markdown 格式的文件，所以这两种方法本质上并没有什么区别。&lt;/p&gt;
&lt;p&gt;这里推荐对于非长篇类的文章可以使用同一个 org 文件进行管理，这种方法可以方便地使用 org-mode 提供的 Tag 继承功能；针对于长篇的文章，可以直接使用单独的 org 文件。&lt;/p&gt;
&lt;p&gt;这边简单介绍一下如何使用单个的 org 文件来管理博客文章，首先需要两个全局的
Property： &lt;code&gt;HUGO_SECTION&lt;/code&gt; 和 &lt;code&gt;HUGO_BASE_DIR&lt;/code&gt; ，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HUGO_SECTION&lt;/code&gt;: 这个是指定导出的内容在 content 目录所在的路径，例如我的博客文章的 Markdown 文件是放在 &lt;code&gt;/content/post&lt;/code&gt; 下的，那么这边的值就是 &lt;code&gt;post&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HUGO_BASE_DIR&lt;/code&gt;: 博客的根目录，例如我的 Hugo 博客是在 &lt;code&gt;~/Dropbox/blog&lt;/code&gt; 下，那么这边的值就是 &lt;code&gt;~/Dorpbox/blog&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他一些设定可以参考我的 &lt;a href=&#34;https://raw.githubusercontent.com/forrestchang/blog-raw/master/content-org/post.org?token=AB36HZWPBHGMFX4PTQUDJB247MWO4&#34;&gt;org raw file&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;ox-hugo 使用 org-mode 中的 Tag 来标记文章的 Category 和 Tags，使用 &lt;code&gt;@&lt;/code&gt; 开头的
Tag 为 Category，其他的为普通的 Tags，利用 org-mode 的特性，我们可以方便地继承上级的 Tag，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-org&#34; data-lang=&#34;org&#34;&gt;*&lt;span style=&#34;font-weight:bold&#34;&gt; Programming&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt; :@Programming:&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; TODO&lt;/span&gt; New post
&lt;span style=&#34;color:#75715e&#34;&gt;:PROPERTIES:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;:EXPORT_FILE_NAME: new-post
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;:END:&lt;/span&gt;
This is a test post.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;Programming&lt;/code&gt; 下的文章都会被分类到 &lt;code&gt;Programming&lt;/code&gt; Category 中去。&lt;/p&gt;
&lt;p&gt;一篇文章有两个状态： &lt;code&gt;TODO&lt;/code&gt; 和 &lt;code&gt;DONE&lt;/code&gt; ，TODO 代表的是未发布的文章，在生成的
Markdown 元数据中 &lt;code&gt;draft=true&lt;/code&gt; ，DONE 代表已完成的文章，DONE Date 会被作为发表的时间戳。TODO 和 DONE 的关键字是可以自己指定的，具体可以参考官方文档：&lt;a href=&#34;https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/&#34;&gt;Org
meta-data to Hugo front-matter — ox-hugo - Org to Hugo exporter&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;另一个比较重要的参数是 &lt;code&gt;EXPORT_FILE_NAME&lt;/code&gt; ，这个参数控制了导出时的文件名，例如上面这个例子中导出后就为 &lt;code&gt;new-post.md&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;ox-hugo 的导出方式也非常简单，使用 &lt;code&gt;C-c C-e&lt;/code&gt; 就可以呼出导出菜单，然后选择 &lt;code&gt;H H&lt;/code&gt;
就会把当前文章导出到 Hugo 的目录下。&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190608114908.png&#34;/&gt; 
&lt;/figure&gt;

&lt;h2 id=&#34;开启自动-export&#34;&gt;开启自动 Export&lt;/h2&gt;
&lt;p&gt;ox-hugo 的官方文档中介绍了一种自动 Export 的方式，只要保存了 org 格式的文章，就可以直接导出 Hugo 中。&lt;/p&gt;
&lt;p&gt;首先需要在配置中 load org-hugo-auto-export-mode：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-elisp&#34; data-lang=&#34;elisp&#34;&gt;(def-package! org-hugo-auto-export-mode)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在 Hugo 的根目录下建立 &lt;code&gt;.dir-locals.el&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-elisp&#34; data-lang=&#34;elisp&#34;&gt;((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;content-org/&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; ((org-mode &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; ((&lt;span style=&#34;color:#a6e22e&#34;&gt;eval&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; (org-hugo-auto-export-mode)))))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Reload 一下 Emacs 的配置就可以自动 Export 了，配合 &lt;code&gt;hugo serve -D&lt;/code&gt; 命令，可以做到实时预览。&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190608115739.png&#34;/&gt; 
&lt;/figure&gt;

&lt;h2 id=&#34;使用-picgo-plus-github-来搭建图床&#34;&gt;使用 PicGo + GitHub 来搭建图床&lt;/h2&gt;
&lt;p&gt;博客的写作中难免会用到一些图片素材，目前我使用 PicGo + GitHub 来作为博客的图床，除了 GitHub 之外，PicGo 还支持很多其他图床。&lt;/p&gt;
&lt;p&gt;使用起来也非常简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用截图工具截图（图片自动保存到剪贴板中）&lt;/li&gt;
&lt;li&gt;调用快捷键使用 PicGo 上传图片到 GitHub（可以在 PicGo 中自定义）&lt;/li&gt;
&lt;li&gt;自动生成 org link 格式的图片链接地址到剪贴板中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的配置方法可以参照下面两个链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PicGo: &lt;a href=&#34;https://github.com/Molunerfinn/PicGo&#34;&gt;https://github.com/Molunerfinn/PicGo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub 图床的配置方法：&lt;a href=&#34;https://picgo.github.io/PicGo-Doc/zh/guide/config.html&#34;&gt;https://picgo.github.io/PicGo-Doc/zh/guide/config.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快速获取-chrome-超链接&#34;&gt;快速获取 Chrome 超链接&lt;/h2&gt;
&lt;p&gt;写文章的时候需要一些参考链接，这个可以借助 AppleScript 和 Alfred 来完成。&lt;/p&gt;
&lt;p&gt;实现方式非常简单，使用 AppleScript 获取当前 Chrome 的链接和 title，并组合成对应格式的链接地址（markdown 或者 org-mode）放到剪贴板中，然后使用 Alfred 来调用。&lt;/p&gt;
&lt;p&gt;生成 org-mode link 的代码可以参考我写的这个：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-applescript&#34; data-lang=&#34;applescript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;tell&lt;/span&gt; application &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Google Chrome&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; tab_link &lt;span style=&#34;color:#66d9ef&#34;&gt;to&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt; URL &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;active&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;tab&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; first &lt;span style=&#34;color:#a6e22e&#34;&gt;window&lt;/span&gt;)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; tab_title &lt;span style=&#34;color:#66d9ef&#34;&gt;to&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;active&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;tab&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; first &lt;span style=&#34;color:#a6e22e&#34;&gt;window&lt;/span&gt;)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; org_link &lt;span style=&#34;color:#66d9ef&#34;&gt;to&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; tab_link &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; tab_title &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;]]&amp;#34;&lt;/span&gt;)
  set the clipboard to org_link
  display notification org_link &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;成功复制当前标签页链接到剪贴板&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;tell&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>元知识：信息检索指南</title>
      <link>http://blog.jiayuanzhang.com/post/meta-knowledge-how-to-search-informations/</link>
      <pubDate>Mon, 01 Jul 2019 20:16:00 +0800</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/meta-knowledge-how-to-search-informations/</guid>
      <description>&lt;p&gt;什么是元知识，我的理解是各个领域都通用的知识，例如交流的能力，搜索信息的能力，语言的能力等，不管你是从事什么行业的工作，这些都是必备的技能（或可以增益的技能）。什么是领域知识，例如编程能力、运营能力，这些是在特定领域发挥作用的知识，虽然编程和运营都可以运用在别的领域中，但是都是比较简单的情况（产品经理如果想学习简单的数据分析知识，不需要去学习如何编写操作系统）。&lt;/p&gt;
&lt;p&gt;信息检索是所有元知识中最重要的一个，因为如果学会了这个，完全可以通过自学习的方式去学习其他元知识，所以可以被成为「元知识」的「元知识」。&lt;/p&gt;
&lt;h2 id=&#34;定义问题&#34;&gt;定义问题&lt;/h2&gt;
&lt;p&gt;在搜索信息之前我们首先要定义问题，你到底要搜索什么样的信息？&lt;/p&gt;
&lt;p&gt;很多人其实不会问问题，经常有网友给我发邮件或私信询问编程相关的问题，很多都是直接甩过来一张错误的截图，然后留一句怎么解决（有的甚至连这句话都没有）。最开始我还会仔细看一下问题中的具体报错是什么，久而久之，这种问题多了，我也就懒得回答了。有的人我告诉他把问题描述清楚，ta 还会说你摆架子。后来，对于这种问题，我直接删除扔进垃圾箱不再去管。&lt;/p&gt;
&lt;p&gt;相反的，另外一部分人很善于问问题，问题描述地非常清楚，包括产生错误的上下文，遇见错误后自己的解决办法，对于这种问题，经常是看了上下文就能找到问题出现在哪里，或者根据它的运行环境在本地测试一下就能 debug 出问题所在，对于这样的提问者，我通常非常乐于解答。&lt;/p&gt;
&lt;p&gt;好的提问和坏的提问，可以带来不一样的反馈。所以，下次在问问题之前可以先问问自己：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遇到的问题到底是什么？能否用简单的话描述？&lt;/li&gt;
&lt;li&gt;出现问题的上下文是什么？是否是某些失误导致的？&lt;/li&gt;
&lt;li&gt;我采取了哪些办法来解决问题？是否可行？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说不定在你想清楚这些事后，就能自己找到问题的解决方案了。&lt;/p&gt;
&lt;p&gt;关于定义问题的方法，推荐阅读一下波利亚的&lt;a href=&#34;https://book.douban.com/subject/2124114/&#34;&gt;《如何解题——数学思维的新方法》&lt;/a&gt;，这本简短的小册子介绍了如何定义问题、描述问题、抽象模型、解决问题，是一本对思维训练非常有帮助的书。&lt;/p&gt;
&lt;p&gt;Raymond Hettinger 在今年的 PyCon 上有一场演讲就是关于如何定义问题的，有兴趣的读者可以看一下：&lt;a href=&#34;https://www.youtube.com/watch?v=%5FGP9OpZPUYc&#34;&gt;Modern solvers: Problems well-defined are problems solved&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;学会提问&#34;&gt;学会提问&lt;/h2&gt;
&lt;p&gt;学会定义问题之后就要开始提问了，从上一节也可以看出来，不同的提问方式得到的解答也不一样。好的提问会得到积极的解答，不好的提问会得不到有效的反馈，被当成伸手党。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh%5FCN.md&#34;&gt;提问的智慧&lt;/a&gt; 这本小册子详细介绍了在互联网上应该如何提问，虽然很大程度上是编程领域的提问指南，但是对于其他领域也同样适用。&lt;/p&gt;
&lt;h2 id=&#34;使用搜索引擎&#34;&gt;使用搜索引擎&lt;/h2&gt;
&lt;p&gt;如果遇到一个自己无法解决的问题，第一件事应该是求助于搜索引擎。所有你能想到的问题，大体上别人也都问过了，搜索引擎是你最好的老师。&lt;/p&gt;
&lt;p&gt;如何用好搜索引擎？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的搜索引擎&lt;/li&gt;
&lt;li&gt;定义问题，分解关键词&lt;/li&gt;
&lt;li&gt;使用高级搜索&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以根据问题的不同来选择不同的搜索引擎，一般来说，中文的娱乐内容可以使用百度来搜索，其他严肃类的内容搜索，统一使用 Google。关于为什么严肃类内容不能使用百度来搜索，可以参考这篇文章：&lt;a href=&#34;https://www.huxiu.com/article/282406.html&#34;&gt;搜索引擎百度已死-虎嗅网&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;定义问题在第一节中已经讲到，将定义好的问题分解成关键词可以更好地搜索到想要的内容。例如「Python 如何使用标准库进行格式化时间字符串」可以分解为下面几个关键词：「Python」、「格式化」、「时间字符串」，还可以翻译成英文关键词：「Python」、「format」、「date string」，第一条就是 Stack Overflow 的解答：&lt;a href=&#34;https://stackoverflow.com/questions/14524322/how-to-convert-a-date-string-to-different-format&#34;&gt;python - How to convert a date string to different format - Stack Overflow&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;很多人使用搜索引擎都是简单的用关键词进行搜索，其实 Google 等搜索引擎都支持自定义的高级搜索，知乎的这篇回答详细介绍了如何使用 Google 的高级搜索语法：&lt;a href=&#34;https://www.zhihu.com/question/20161362&#34;&gt;如何用好谷歌等搜索引擎？ - 知乎&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;自动化你的搜索流程&#34;&gt;自动化你的搜索流程&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.alfredapp.com/&#34;&gt;Alfred&lt;/a&gt; 是 macOS 上的一个快速启动器，利用 Alfred Workflow，可以自定义你的搜索引擎工具箱。&lt;/p&gt;
&lt;p&gt;例如我经常会在 GitHub 上搜索一些代码片段，利用 Alfred 可以把流程简化为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快捷键呼出 Alfred 输入窗口；&lt;/li&gt;
&lt;li&gt;输入想要搜索的代码片段关键词（或从剪贴板粘贴）；&lt;/li&gt;
&lt;li&gt;回车！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结果会自动展示在浏览器的窗口中。&lt;/p&gt;
&lt;p&gt;Alfred 的设置如下（在新标签页中查看大图）：&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190701201021.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;其中，Search URL 填写的是想要搜索的地址， &lt;code&gt;query&lt;/code&gt; 是替换的搜索内容，打开 Alfred，输入 keyword 中的关键词就可以快速呼出这个搜索框了。&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190701201221.png&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;这只是 Alfred 基础功能的最简单使用，在之前的文章中我介绍过使用 Alfred 的
Workflow 来自动生成博客：&lt;a href=&#34;http://blog.jiayuanzhang.com/post/use-devonthink-to-write-blog/&#34;&gt;使用 Devonthink 来写博客&lt;/a&gt;，在后续的文章中，我将会介绍更多的 Alfred 高级使用技巧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>修改 OmniFocus 3 的主题</title>
      <link>http://blog.jiayuanzhang.com/post/how-to-modify-omnifocus-3-theme/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/how-to-modify-omnifocus-3-theme/</guid>
      <description>&lt;p&gt;OmniFocus 3 提供了 Dark Mode，但是却没有提供自定义主题的功能，Dark Mode 看久了也会腻，所以最近又切换到 Light Mode 下来了。搜索了一下，看到这篇讨论：&lt;a href=&#34;https://discourse.omnigroup.com/t/is-it-possible-to-reduce-fontsize-or-fontstyle-of-the-headline-of-a-perspective/44258/8?u=jannock&#34;&gt;Is it possible to reduce fontsize or fontstyle of the headline of a perspective?&lt;/a&gt;，可以通过修改配置的方式来修改 OmniFocus 的主题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190523111224.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的修改方法为：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/Applications/OmniFocus.app/Contents/Resources/ThemeResources/SystemFont&lt;/code&gt; 下面修改字体的大小和页边距，首先我们先修改边距大小，我默认选择的是 Extra Large 的字体，所以需要修改 &lt;code&gt;OFIExtraLargeLayoutConstraintConstants.plit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;找到以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;key&amp;gt;&lt;/span&gt;extraPaddingBelowNoteForActionCells&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;20&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;key&amp;gt;&lt;/span&gt;extraPaddingBelowNoteForColumnarActionCells&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;20&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;key&amp;gt;&lt;/span&gt;extraPaddingBelowNoteForProjectCells&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;20&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后把 &lt;code&gt;real&lt;/code&gt; 的值设定成自己想要的就好了，我这边设定为 20，最后看起来的效果还可以。&lt;/p&gt;
&lt;p&gt;然后修改 Note 的字体，打开 &lt;code&gt;OFIFontRegistry.plit&lt;/code&gt;，找到以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;key&amp;gt;&lt;/span&gt;OFITextStyleNoteBody&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content-sizes&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;13&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;13&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;14&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;15&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;real&amp;gt;&lt;/span&gt;16&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/real&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;key&amp;gt;&lt;/span&gt;font-name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;regular&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;依次修改 &lt;code&gt;real&lt;/code&gt; 的值，对应 OmniFocus 的以下配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190523112118.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Next Action, Due 和 Overdue 的颜色可以在 &lt;code&gt;/Applications/OmniFocus.app/Contents/Resources/ThemeResources/&lt;/code&gt; 下面修改，找到对应的主题，例如我现在使用的是 Light Mode，就修改 &lt;code&gt;30-Light-ColoredText/OFIThemeAppearance.plist&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;其中颜色的值使用的 NSColor HSB&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 格式的，需要对 RGB 或者 Hex 格式的颜色值做一下转换，可以找到喜欢的颜色值，然后在&lt;a href=&#34;https://rgb.to/&#34;&gt;这个网站&lt;/a&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;转换。&lt;/p&gt;
&lt;p&gt;把 Resource 中的配置文件浏览了一下，发现还是可以定制很多其他东西的，基于这个可以实现一个主题工具，但是不知道 OmniFocus 更新会不会把 Resource 文件覆盖掉，这个之后测试一下。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/appkit/nscolor&#34;&gt;NSColor - AppKit | Apple Developer Documentation&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://rgb.to/&#34;&gt;Convert Hex color #7ca746 to Rgb, Pantone, RAL, HSL, HSV, HSB, JSON. Get color scheme.&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>使用 Devonthink 来写博客</title>
      <link>http://blog.jiayuanzhang.com/post/use-devonthink-to-write-blog/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/use-devonthink-to-write-blog/</guid>
      <description>&lt;p&gt;虽然博客没有写太多篇，但是写博客的工具却折腾过不少。从最开始的 org-mode，到 Jekyll、Hexo，再到现在的 Hugo，一直没有找到一个满意的工作流。&lt;/p&gt;
&lt;p&gt;我的需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用统一的工具来管理笔记和写作的文章；&lt;/li&gt;
&lt;li&gt;能够多端同步；&lt;/li&gt;
&lt;li&gt;自动化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前使用 Hugo 写作的流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在命令行新建一篇文章；&lt;/li&gt;
&lt;li&gt;打开 Typora 进行写作；&lt;/li&gt;
&lt;li&gt;写完了再去命令行 generate 并 push 到 GitHub 上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后来使用 Ulysses 作为写作的工具，把 Hugo 的 post 文件夹作为 Ulysses 的外部文件夹来进行写作。Ulysses 是一个很强大的写作工具，但是唯一的缺点是它自带的 Markdown 语法与通用的 Markdown 语法不兼容，这导致了之前写的很多文章都需要转码一遍才能够正确在 Ulysses 中显示。&lt;/p&gt;
&lt;p&gt;Devonthink 是我用来做知识管理的工具，你可以把它看做是一个增强版的 Finder + Evernote，我主要用它来写笔记和剪裁网页，配合 Alfred 的搜索可以快速找到想要的内容，关于 Devonthink 的具体使用我之后会写一篇文章来介绍，如果你有疑问，可以先看一下这篇文章：&lt;a href=&#34;https://sspai.com/post/44774&#34;&gt;DEVONthink 和 Evernote，谁是更好的知识管理工具？ - 少数派&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;既然我把我写的和剪裁的东西都统一管理在 Devonthink 中，那么能不能把博客的写作流程也整合进去呢？&lt;/p&gt;
&lt;p&gt;搜索了一下，发现 Devonthink 能够支持 AppleScript 和 JavaScript for Automation（JXA），实现的思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用一个 Folder 统一管理写作的文章；&lt;/li&gt;
&lt;li&gt;读取这个 Folder 中的所有文章和元数据；&lt;/li&gt;
&lt;li&gt;把元数据生成 YAML 格式的内容插入到文章的开头；&lt;/li&gt;
&lt;li&gt;把新生成的文章写入到 Hugo 对应的文件夹下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现的逻辑很简单，困难点主要在于 JXA 的文档缺乏，有一些操作需要调用系统的 Objective-C Bridge 来进行（相当于在 JavaScript 中写 Objective-C 的代码）。&lt;/p&gt;
&lt;p&gt;我写了一个 Alfred Workflow 来完成这个功能，核心代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Constants
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;devonthink&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Application&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;DEVONthink 3&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPath&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/Users/jiayuan/Dropbox/personal-site/blog/content/post/&amp;#39;&lt;/span&gt;


&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Utils
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;formatTime&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cFormat&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cFormat&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{y}-{m}-{d} {h}:{i}:{s}&amp;#39;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;object&amp;#39;&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;
  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parseInt(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Date(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;)
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;formatObj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getFullYear&lt;/span&gt;(),
    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMonth&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDate&lt;/span&gt;(),
    &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getHours&lt;/span&gt;(),
    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMinutes&lt;/span&gt;(),
    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSeconds&lt;/span&gt;(),
    &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;date&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDay&lt;/span&gt;()
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time_str&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;replace&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;/{([ymdhisa])+}/g&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;) =&amp;gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;formatObj&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;一&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;二&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;三&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;四&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;五&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;六&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;日&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  })
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time_str&lt;/span&gt;
}


&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Functions
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;writeToFile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;filename&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;endsWith&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;filePath&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;filename&lt;/span&gt;

  &lt;span style=&#34;color:#a6e22e&#34;&gt;contentEncoded&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NSString&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;alloc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;initWithUTF8String&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;contentEncoded&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;writeToFileAtomicallyEncodingError&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;filePath&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NSUTF8StringEncoding&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getMetaData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;) {

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get created time
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createdTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;formatTime&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;creationDate&lt;/span&gt;(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{y}-{m}-{d}&amp;#39;&lt;/span&gt;)

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get updated time
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;updatedTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;formatTime&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;modificationDate&lt;/span&gt;(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{y}-{m}-{d}&amp;#39;&lt;/span&gt;)

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get file name
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customMetaData&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;customMetaData&lt;/span&gt;()
  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fileName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customMetaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mdblogfilename&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fileName&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;endsWith&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.md&amp;#39;&lt;/span&gt;)) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;fileName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fileName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.md&amp;#39;&lt;/span&gt;
  }

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get tags
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tags&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tags&lt;/span&gt;()

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get categories
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;category&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customMetaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mdcategory&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get draft info
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isDraft&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customMetaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mddraft&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;// Get title
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;()

  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;createdTime&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;updatedTime&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;fileName&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;tags&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;category&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;isDraft&lt;/span&gt;
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generateYamlMetaString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yamlMetaString&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`---
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;title: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;date: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createdTime&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;lastmod: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;updatedTime&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;categories: [&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;category&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;]
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;tags: [&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tags&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;]
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;draft: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isDraft&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;---
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  `&lt;/span&gt;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yamlMetaString&lt;/span&gt;
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPosts&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;devonthink&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;databases&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;byName&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;02.Writing&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;parents&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;byName&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Blog&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;()

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPosts&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;selectedRecord&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPosts&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;]

    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getMetaData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;selectedRecord&lt;/span&gt;)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yamlMetaString&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generateYamlMetaString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;selectedRecord&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;plainText&lt;/span&gt;()
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPostContent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;yamlMetaString&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;writeToFile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;metaData&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fileName&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPath&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;blogPostContent&lt;/span&gt;)
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Application&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;currentApplication&lt;/span&gt;()
  &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;includeStandardAdditions&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;

  &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;displayNotification&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`You have generated &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;blogPosts&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; articles.`&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;withTitle&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Success&amp;#39;&lt;/span&gt; })
}

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Main
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;源代码可以在这里看到：&lt;a href=&#34;https://github.com/forrestchang/alfred-workflows/tree/master/src/Devonthink-to-Hugo-Blog&#34;&gt;alfred-workflows/src/Devonthink-to-Hugo-Blog at master · forrestchang/alfred-workflows&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果你需要用到你的工作流中，需要配置以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hugo 的 &lt;code&gt;post&lt;/code&gt; 路径，在 &lt;code&gt;blogPath&lt;/code&gt; 中定义；&lt;/li&gt;
&lt;li&gt;Devonthink 中的 Blog 文件夹，在 &lt;code&gt;blogPosts&lt;/code&gt; 中定义；&lt;/li&gt;
&lt;li&gt;需要使用 Devonthink 3 的 Custom Metadata 功能，添加三个 Metadata：&lt;code&gt;Category&lt;/code&gt; 用来作为此篇博客的分类，&lt;code&gt;Blog File Name&lt;/code&gt; 用来作为生成的路径名，&lt;code&gt;Draft&lt;/code&gt; 用来判断是否是草稿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个脚本支持读取 Devonthink 的文章标题为博客标题，创建时间为博客的创建时间，Tags 为博客的 Tags，其他的 Metadata 也可以在 &lt;code&gt;getMetaData&lt;/code&gt; 这个函数中自行定义。&lt;/p&gt;
&lt;p&gt;现在这个脚本还不是特别完善，之后会添加一些错误处理的功能并支持 org-mode 格式的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190513165627.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>读《代码大全》</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-code-complete-part-1/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-code-complete-part-1/</guid>
      <description>&lt;p&gt;这本书最开始是大一的时候买的，买回来后翻了一些章节就成为了显示器的支架，直到最近工作了一段时间才重新开始读，这一次阅读和几年前初次阅读有很大不同，大一阅读时候的编码经验仅仅是局限于算法方面，对大型项目的构建没有特别多感触；这一次是在写了很多业务代码，积累了一定问题的基础上去阅读的，阅读的深度自然不是第一次阅读可以比较的。&lt;/p&gt;
&lt;p&gt;和这本书类似的还有一本叫做 &lt;a href=&#34;https://book.douban.com/subject/1152111/&#34;&gt;《程序员修炼之道——从小工到专家》&lt;/a&gt;（我也写过 &lt;a href=&#34;http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-1/&#34;&gt;笔记&lt;/a&gt;）。这本书讲了很多软件工程领域的行话和规则，比如熟悉的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1&#34;&gt;DRY 原则&lt;/a&gt;，如果觉得《代码大全》比较厚（大概九百多页），也可以先读一下这本书。&lt;/p&gt;
&lt;p&gt;《代码大全》并不是一本需要从头到尾依次阅读的书，章节和章节之间的联系也不是很大，完全可以随便挑选感兴趣的章节来阅读。这次阅读我主要遵从书上的建议，按照以下顺序来阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 11 章：变量名的力量&lt;/li&gt;
&lt;li&gt;第 8 章：防御式编程&lt;/li&gt;
&lt;li&gt;第 7 章：高质量的子程序&lt;/li&gt;
&lt;li&gt;第 18 章：表驱动法&lt;/li&gt;
&lt;li&gt;第 4 章：关键的「构建」决策&lt;/li&gt;
&lt;li&gt;第 33 章：个人性格&lt;/li&gt;
&lt;li&gt;第 32 章：自说明代码&lt;/li&gt;
&lt;li&gt;其他章节按照顺序或者兴趣度依次阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个「读《代码大全》」系列的文章主要是记录一些阅读笔记。之前的阅读笔记比较喜欢把书上的内容抄下来，但是实际上发现，「抄书」可能抄完就忘了，因为「抄」其实很简单，不需要动脑，打字快的话也不会觉得很累。这次阅读笔记主要是「问题 - 回答」的模式来写，在阅读每章之前，先提出几个问题，然后在阅读的过程中解决问题。&lt;/p&gt;
&lt;h2 id=&#34;第-11-章变量名的力量&#34;&gt;第 11 章：变量名的力量&lt;/h2&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎样给一个变量命名？&lt;/li&gt;
&lt;li&gt;长名字还是短名字？&lt;/li&gt;
&lt;li&gt;命名的最佳实践有哪些？&lt;/li&gt;
&lt;li&gt;有哪些常见的命名方法？&lt;/li&gt;
&lt;li&gt;在命名中应该要避免的东西有哪些？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;怎样给一个变量命名&#34;&gt;怎样给一个变量命名？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;通常，对变量的描述就是最佳的变量名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书中举了几个简单的例子，例如表示美国奥林匹克代表团成员数量的变量 &lt;code&gt;numberOfPeopleOnTheUsOlympicTeam&lt;/code&gt;，表示某国代表团在现代奥运会上获得的最高分数的变量 &lt;code&gt;maximumNumberOfPointsInModernOlympics&lt;/code&gt;。这种变量命名的好处是一眼就能看出这个变量表示的是什么，它们都是非常明确的。而像 &lt;code&gt;nums&lt;/code&gt; 和 &lt;code&gt;maxPoints&lt;/code&gt; 就相对来说没有那么明确，至于 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 这样的命名就是非常差的描述，移除了上下文根本无法理解。&lt;/p&gt;
&lt;p&gt;这种对变量描述的命名方法也有一个缺点：变量名太长了，这一点会之后讨论。&lt;/p&gt;
&lt;p&gt;另外一个命名的方法是「以问题为导向（Problem Orientation）」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个好名字通常表达的是「什么（what）」，而不是「如何（how）」。如果一个名字反映了计算的某些方面而不是问题本省，那么它反应的就是「how」，而不是「what」了，应该避免取这样的名字。
书中也举了几个例子，例如一条员工数据记录可以称作 &lt;code&gt;inputRec&lt;/code&gt; 或者 &lt;code&gt;employeeData&lt;/code&gt;，&lt;code&gt;inputRec&lt;/code&gt; 是一个反映输入、记录这些计算概念的计算机术语，二 &lt;code&gt;employeeData&lt;/code&gt; 则直指问题领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量命名中有很多的限定词，例如 &lt;code&gt;Total&lt;/code&gt;、&lt;code&gt;Sum&lt;/code&gt;、&lt;code&gt;Average&lt;/code&gt;、&lt;code&gt;Max&lt;/code&gt;、&lt;code&gt;Min&lt;/code&gt;、&lt;code&gt;Record&lt;/code&gt; 等。使用这样的限定词的时候，最好把这些限定词加到最后，这样做的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免歧义：&lt;code&gt;moneyTotal&lt;/code&gt; 和 &lt;code&gt;totalMoney&lt;/code&gt; 产生的歧义；&lt;/li&gt;
&lt;li&gt;一致性：&lt;code&gt;numberTotal&lt;/code&gt;、&lt;code&gt;moneyTotal&lt;/code&gt;、&lt;code&gt;costTotal&lt;/code&gt; 这样的命名具有一致性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用好「对仗词」也可以很好得提升变量的可读性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;begin/end&lt;/li&gt;
&lt;li&gt;first/last&lt;/li&gt;
&lt;li&gt;locked/unlocked&lt;/li&gt;
&lt;li&gt;min/max&lt;/li&gt;
&lt;li&gt;next/previous&lt;/li&gt;
&lt;li&gt;old/new&lt;/li&gt;
&lt;li&gt;opened/closed&lt;/li&gt;
&lt;li&gt;visible/invisible&lt;/li&gt;
&lt;li&gt;source/target&lt;/li&gt;
&lt;li&gt;source/destination&lt;/li&gt;
&lt;li&gt;up/down&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用名词来命名变量名，可以是 &lt;code&gt;adj + noun&lt;/code&gt; 这种格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;长名字还是短名字&#34;&gt;长名字还是短名字？&lt;/h3&gt;
&lt;p&gt;上一个问题里所讲的「对变量的描述就是最佳的变量名」这种命名方法很有可能会导致变量名过长，例如 &lt;code&gt;maximumNumberOfPointsInMordernOlympics&lt;/code&gt;，虽然现代的编辑器和 IDE 都拥有非常智能的补全，这些长名字的输入也不是什么问题，但是无疑会让代码看起来过于臃肿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gorla 和 Benander 发现，当变量名的平均长度在 10 到 16 个字符的时候，调试程序所花费的力气是最小的（1990）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如上面的这个变量名可以简化为 &lt;code&gt;maxPointsInOlympics&lt;/code&gt; ，这样既保留了变量的原本意思（参考上下文的情况下），又缩短的变量名的长度。&lt;/p&gt;
&lt;p&gt;在编写变量名的时候还需要考虑作用域的问题，一般来说，小作用域里的变量名可以简短一些，因为只作用于几行代码，例如 Python 中的列表推导式（Python 3，Python 2 中的列表推导式不是块级作用域）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;alist &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [do_something(elem) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; elem &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; some_list]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;甚至在不需要使用这个变量的时候可以把它忽略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 生成一个随机数列表&lt;/span&gt;
random_numbers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相反的，如果是一个全局作用域，变量名就需要取得独特一些，避免产生命名空间冲突。例如用户接口部分的雇员类可以命名为 &lt;code&gt;uiEmployee&lt;/code&gt;，数据库部分的雇员类可以命名为 &lt;code&gt;dbEmployee&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;命名的最佳实践有哪些&#34;&gt;命名的最佳实践有哪些？&lt;/h3&gt;
&lt;p&gt;程序中常见的变量类型有「循环变量」、「状态变量」、「临时变量」、「布尔变量」、「枚举变量」和「具名常量」，这一部分会针对这些不同的变量（常量）类型讨论最佳实践。&lt;/p&gt;
&lt;h4 id=&#34;循环变量&#34;&gt;循环变量&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;（不推荐）简单的循环可以使用 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; 来命名；&lt;/li&gt;
&lt;li&gt;复杂的循环或者循环变量需要在循环外使用的应该使用富有含义的命名。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，我需要便利一个用户列表信息来对每个用户的信息做处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; user_info &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; user_infos:
    do_something(user_info)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要注意的事，在 Python 中，&lt;code&gt;for&lt;/code&gt; 循环是不存在子作用域的，所以在循环外访问 &lt;code&gt;user_info&lt;/code&gt; 会获取 &lt;code&gt;user_infos&lt;/code&gt; 中的最后一个值。&lt;/p&gt;
&lt;p&gt;个人经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;便利下标可以使用 &lt;code&gt;idx&lt;/code&gt; 或者 &lt;code&gt;index&lt;/code&gt; 作为结尾，例如 &lt;code&gt;user_info_idx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;状态变量&#34;&gt;状态变量&lt;/h4&gt;
&lt;p&gt;状态变量一般用来描述程序的状态。最常用的状态变量名就是 &lt;code&gt;flag&lt;/code&gt;，但是这种命名方法缺少具体的含义，不推荐。&lt;/p&gt;
&lt;p&gt;最好的命名方法是名字中不含有 &lt;code&gt;flag&lt;/code&gt;，并且能够精准地表述状态。例如用来描述是否符合某一条件的变量名：&lt;code&gt;matched&lt;/code&gt;，它是一个布尔值。&lt;/p&gt;
&lt;p&gt;如果某个状态含有多个值，可以使用枚举值来代替。&lt;/p&gt;
&lt;h4 id=&#34;临时变量&#34;&gt;临时变量&lt;/h4&gt;
&lt;p&gt;临时变量用于存储计算的中间结果，它常被命名为 &lt;code&gt;temp&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; 等模糊且缺乏描述性的名字。&lt;/p&gt;
&lt;p&gt;虽然临时变量是「临时」使用的，但是也不应该随意给它们命名，赋予一个更有意义的名字会让程序更加可读。&lt;/p&gt;
&lt;p&gt;例如下面一段计算二元一次方程的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sqrt(b &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; c)
answer[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; temp) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a)
answer[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; temp) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然上面这段代码没有什么逻辑问题，但是 &lt;code&gt;temp&lt;/code&gt; 这个变量并不能很好的表述计算的中间结果，如果把 &lt;code&gt;temp&lt;/code&gt; 改为 &lt;code&gt;discriminant&lt;/code&gt;（判别式） 会更好。&lt;/p&gt;
&lt;h4 id=&#34;布尔变量&#34;&gt;布尔变量&lt;/h4&gt;
&lt;p&gt;一些常用的布尔变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;done：表示某件事已经完成。在完成之前把 done 的值设为 false；&lt;/li&gt;
&lt;li&gt;error：表示有错误发生。在错误发生之前把 error 的值设为 false；&lt;/li&gt;
&lt;li&gt;found：表示某个值已经找到了。在未找到之前把 found 的值设为 false；&lt;/li&gt;
&lt;li&gt;success/ok：表示某一项操作是否成功。在操作失败的情况下把它的值设为 false。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最佳实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给布尔变量赋于隐含「真/假」含义的名字；&lt;/li&gt;
&lt;li&gt;使用肯定的布尔变量名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在布尔变量之前添加 &lt;code&gt;is&lt;/code&gt; 前缀来区分，例如 &lt;code&gt;is_done&lt;/code&gt;，这样做法的唯一缺点是写在条件判断中不是那么清晰，&lt;code&gt;if (done)&lt;/code&gt; 要比 &lt;code&gt;if (is_done)&lt;/code&gt; 更加清晰一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;枚举变量&#34;&gt;枚举变量&lt;/h4&gt;
&lt;p&gt;在使用枚举类型的时候，可以通过使用组前缀，如 &lt;code&gt;Color_&lt;/code&gt;, &lt;code&gt;Planet_&lt;/code&gt; 等来明确表示该类型的成员属于同一个组。&lt;/p&gt;
&lt;h4 id=&#34;常量&#34;&gt;常量&lt;/h4&gt;
&lt;p&gt;常量应该始终大写，并使用有意义的值，避免在程序中使用魔法变量。&lt;/p&gt;
&lt;h3 id=&#34;有哪些常见的命名方法&#34;&gt;有哪些常见的命名方法？&lt;/h3&gt;
&lt;p&gt;命名规范首先应该参考项目的规范或者所编写的语言规范，例如 Java 通常使用的是驼峰命名法，Python 使用的是下划线命名法。&lt;/p&gt;
&lt;h4 id=&#34;驼峰命名法camelcase&#34;&gt;驼峰命名法（CamelCase）&lt;/h4&gt;
&lt;p&gt;驼峰命名法来源于 Perl 语言中普遍使用的大小写混合命名，而 Larry Wall 所著的《Programming Perl》的封面就是一匹骆驼。&lt;/p&gt;
&lt;p&gt;一般来说，变量名、函数使用小驼峰命名法（lowerCamelCase）；类使用大驼峰命名法（UpperCamelCase）。&lt;/p&gt;
&lt;p&gt;驼峰命名法常在 Java、JavaScript 等语言中被使用。&lt;/p&gt;
&lt;h4 id=&#34;下划线命名法underline_case&#34;&gt;下划线命名法（underline_case）&lt;/h4&gt;
&lt;p&gt;下划线命名法使用下划线 &lt;code&gt;_&lt;/code&gt; 来分隔多个单词。这种命名方式通常在 Python 等语言中被使用。它的缺点是会使含有多个单词的变量名的长度增加。&lt;/p&gt;
&lt;h4 id=&#34;匈牙利命名法&#34;&gt;匈牙利命名法&lt;/h4&gt;
&lt;p&gt;在匈牙利命名法中，一个变量由一个或多个小些字母开始，这些字母有助于记忆变量的类型和用途，紧跟着的就是程序员选择的任何名称。这个后半部分的首字母可以大写，以区别前面的类型指示字母。&lt;/p&gt;
&lt;p&gt;匈牙利命名法被广泛用在 Microsoft Windows 系统的开发中。但是目前这种命名方式已经被很少使用，不推荐。&lt;/p&gt;
&lt;h3 id=&#34;在命名中应该要避免的东西有哪些&#34;&gt;在命名中应该要避免的东西有哪些？&lt;/h3&gt;
&lt;p&gt;（这是《代码大全》中列出的指导原则。）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免使用令人误解的名字和缩写。要确保名字的含义是明确的。例如 FALSE 常用做 TRUE 的反义词，如果它用做「Fig and Almond Season」的缩写就很糟糕了；&lt;/li&gt;
&lt;li&gt;避免使用具有相似含义的名字。如果你能够交换两个变量的名字而不会妨碍对程序的理解，那么你就需要为这两个变量重新命名了。&lt;/li&gt;
&lt;li&gt;避免使用具有不同含义但却有相似名字的变量。如果你有两个名字相似但含义不同的变量，那么试着给其中之一重新命名。&lt;/li&gt;
&lt;li&gt;避免使用发音相近的名字。例如 wrap 和 rap，当你试图和别人讨论代码的时候，同音字会产生麻烦。&lt;/li&gt;
&lt;li&gt;避免在名字中使用数字。如果名字中的数字真的非常重要，可以使用数组来代替一组单个的变量。&lt;/li&gt;
&lt;li&gt;避免在名字中拼错单词。（后期要修改非常麻烦。）&lt;/li&gt;
&lt;li&gt;避免使用英语中常常拼错的单词。很多英语手册会包含一份常常拼错单词的清单，避免在你的变量名中使用这些单词。&lt;/li&gt;
&lt;li&gt;不要仅靠大小写来区分变量名。（大写仅作为常量命名。）&lt;/li&gt;
&lt;li&gt;避免使用多种自然语言。（统一使用标准现代英语，避免使用 emoji、中文和其他语言。）&lt;/li&gt;
&lt;li&gt;避免使用标准类型、变量和子程序的名字。所有的编程语言指南都会包含一份该语言保留的和预定的名字列表，不要使用列表上的名字作为变量名。&lt;/li&gt;
&lt;li&gt;不要使用与变量含义完全无关的名字。&lt;/li&gt;
&lt;li&gt;避免在名字中包含容易混淆的字符。要意识到有些字符看上去非常接近，很难把它们区分开来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;变量的命名是程序开发中非常小的一个环节，但是却能够发展出这么多的理论，原因之一就是「程序首先是给人阅读的，其次才是给机器执行的」。良好的命名方法可以让代码更加易于维护，也可以让别人更好地理解你的代码。&lt;/p&gt;
&lt;p&gt;变量的命名规范首先应当符合团队或者项目制定的编码规范，如果没有制定规范或者是个人项目，可以沿用社区的编码规范。下面列出一些常见语言的编码规范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python: &lt;a href=&#34;https://github.com/google/styleguide/blob/gh-pages/pyguide.md&#34;&gt;styleguide/pyguide.md at gh-pages · google/styleguide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java: &lt;a href=&#34;https://github.com/alibaba/p3c&#34;&gt;alibaba/p3c: Alibaba Java Coding Guidelines pmd implements and IDE plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScript: &lt;a href=&#34;https://github.com/airbnb/javascript&#34;&gt;airbnb/javascript: JavaScript Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C/C++: &lt;a href=&#34;https://google.github.io/styleguide/cppguide.html&#34;&gt;Google C++ Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Golang: &lt;a href=&#34;https://github.com/golang/go/wiki/CodeReviewComments&#34;&gt;CodeReviewComments · golang/go Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编码规范也不能够完全依靠文档来约束，集成到 IDE 或者 CI 中是更好的方式。各种语言都提供了各种 format 工具，例如 Python 的 &lt;a href=&#34;https://github.com/google/yapf&#34;&gt;yapf&lt;/a&gt;，Golang 的 &lt;a href=&#34;https://golang.org/cmd/gofmt/&#34;&gt;gofmt&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;IDE 和代码编辑器也提供了很好的格式化代码的功能，例如 Jebbrains 的 IDE 就可以通过导入 XML 格式的文件来进行配置格式化代码的风格。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;Don&amp;rsquo;t repeat yourself - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Camel_case&#34;&gt;Camel case - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hungarian_notation&#34;&gt;Hungarian notation - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670&#34;&gt;Code Complete: A Practical Handbook of Software Construction, Second Edition: Steve McConnell: 0790145196705: Amazon.com: Books&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SFTP 使用详解</title>
      <link>http://blog.jiayuanzhang.com/post/linux-command-sftp/</link>
      <pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/linux-command-sftp/</guid>
      <description>&lt;p&gt;「Linux 命令详解」这个系列的文章将会介绍 Linux/Unix/macOS 系统中使用到的常用命令，包括该命令的简单介绍、常用参数解释以及最佳实践，如果需要快速使用这个命令，直接跳到最佳实践部分即可。&lt;/p&gt;
&lt;p&gt;「Linux 命令详解」系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jiayuanzhang.com/linux-command-sftp/&#34;&gt;Linux命令详解：SFTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一介绍&#34;&gt;一、介绍&lt;/h2&gt;
&lt;p&gt;SFTP（Secure File Transfer Protocol，安全文件传输协议）是一种基于可靠数据流（data stream），提供文件存取和管理的网络传输协议，它在网络协议层的结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/sftp-layer.png&#34; alt=&#34;sftp-layer&#34;&gt;&lt;/p&gt;
&lt;p&gt;与 FTP 协议相比，SFTP 在客户端与服务器间提供了一种更为安全的文件传输方式，如果你还在使用 FTP 来进行文件传输，强烈建议切换到更为安全的 SFTP 上来。&lt;/p&gt;
&lt;p&gt;本篇文章将会介绍 SFTP 的链接，以及在交互式命令行中的一些常用命令，并对一些参数进行解释，最后给出实际使用中的最佳实践。目前已经有很多 GUI 客户端支持 SFTP 协议，但是不在本篇文章的讨论范围之内。&lt;/p&gt;
&lt;h2 id=&#34;二使用-sftp-进行连接&#34;&gt;二、使用 SFTP 进行连接&lt;/h2&gt;
&lt;p&gt;因为 SFTP 是基于 SSH 协议的，所以默认的身份认证方法与 SSH 协议保持一致。通常我们使用 SSH Key 来进行连接，如果你已经可以使用 SSH 连接到远程服务器上，那么可以使用以下命令来连接 SFTP：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp user_name@remote_server_address&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;:path&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果远程服务器自定义了连接的端口，可以使用 &lt;code&gt;-P&lt;/code&gt; 参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp -P remote_port user_name@remote_server_address&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;:path&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;连接成功后将进入一个 SFTP 的解释器，可以发现命令行提示符变成了 &lt;code&gt;sftp&amp;gt;&lt;/code&gt;，使用 &lt;code&gt;exit&lt;/code&gt; 命令可以退出连接。&lt;/p&gt;
&lt;p&gt;如果连接地址存在 &lt;code&gt;path&lt;/code&gt; 并且 &lt;code&gt;path&lt;/code&gt; 不是一个目录，那么 SFTP 会直接从服务器端取回这个文件。&lt;/p&gt;
&lt;h2 id=&#34;三连接参数详解&#34;&gt;三、连接参数详解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-B&lt;/code&gt;: buffer_size，制定传输 buffer 的大小，更大的 buffer 会消耗更多的内存，默认为 32768 bytes；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt;: port，制定连接的端口号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-R&lt;/code&gt;: num_requests，制定一次连接的请求数，可以略微提升传输速度，但是会增加内存的使用量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四目录管理&#34;&gt;四、目录管理&lt;/h2&gt;
&lt;p&gt;在 SFTP 解释器中可以使用 &lt;code&gt;help&lt;/code&gt; 命令来查看帮助文档。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt;
chgrp grp path                     Change group of file &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt; to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;grp&amp;#39;&lt;/span&gt;
chmod mode path                    Change permissions of file &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt; to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;
chown own path                     Change owner of file &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt; to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;own&amp;#39;&lt;/span&gt;
df &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-hi&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                    Display statistics &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; current directory or
                                   filesystem containing &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt;
exit                               Quit sftp
get &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-afPpRr&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; remote &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;local&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;       Download file
reget &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-fPpRr&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; remote &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;local&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;      Resume download file
reput &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-fPpRr&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;local&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; remote      Resume upload file
help                               Display this help text
lcd path                           Change local directory to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt;
lls &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ls-options &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;]]&lt;/span&gt;            Display local directory listing
lmkdir path                        Create local directory
ln &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-s&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; oldpath newpath            Link remote file &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;-s &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; symlink&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
lpwd                               Print local working directory
ls &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-1afhlnrSt&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;             Display remote directory listing
lumask umask                       Set local umask to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;umask&amp;#39;&lt;/span&gt;
mkdir path                         Create remote directory
progress                           Toggle display of progress meter
put &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-afPpRr&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; local &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;remote&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;       Upload file
pwd                                Display remote working directory
quit                               Quit sftp
rename oldpath newpath             Rename remote file
rm path                            Delete remote file
rmdir path                         Remove remote directory
symlink oldpath newpath            Symlink remote file
version                            Show SFTP version
!command                           Execute &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;command&amp;#39;&lt;/span&gt; in local shell
!                                  Escape to local shell
?                                  Synonym &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SFTP 解释器中预置了常用的命令，但是没有自带的 Bash 来得丰富。&lt;/p&gt;
&lt;p&gt;1）显示当前的工作目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; pwd
Remote working directory: /
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）查看当前目录的内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; ls
Summary.txt     info.html       temp.txt        testDirectory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3）使用 &lt;code&gt;-la&lt;/code&gt; 参数可以以列表形式查看，并显示隐藏文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; ls -la
drwxr-xr-x    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; demouser   demouser       &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:11 .
drwxr-xr-x    &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; root       root           &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:02 ..
-rw-------    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; demouser   demouser          &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:04 .bash_history
-rw-r--r--    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; demouser   demouser        &lt;span style=&#34;color:#ae81ff&#34;&gt;220&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:02 .bash_logout
-rw-r--r--    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; demouser   demouser       &lt;span style=&#34;color:#ae81ff&#34;&gt;3486&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:02 .bashrc
drwx------    &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; demouser   demouser       &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:04 .cache
-rw-r--r--    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; demouser   demouser        &lt;span style=&#34;color:#ae81ff&#34;&gt;675&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; 15:02 .profile
. . .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4）切换目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; cd testDirectory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5）建立文件夹：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; mkdir anotherDirectory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上的命令都是用来操作远程服务器的，如果想要操作本地目录呢？只需要在每个命令前添加 &lt;code&gt;l&lt;/code&gt; 即可，例如显示本地操作目录下的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; lls
localFiles
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;!&lt;/code&gt; 可以直接运行 Shell 中的指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; !df -h
Filesystem      Size   Used  Avail Capacity iused               ifree %iused  Mounted on
/dev/disk1s1   466Gi  360Gi  101Gi    79% &lt;span style=&#34;color:#ae81ff&#34;&gt;3642919&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9223372036851132888&lt;/span&gt;    0%   /
devfs          336Ki  336Ki    0Bi   100%    &lt;span style=&#34;color:#ae81ff&#34;&gt;1162&lt;/span&gt;                   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  100%   /dev
/dev/disk1s4   466Gi  4.0Gi  101Gi     4%       &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9223372036854775802&lt;/span&gt;    0%   /private/var/vm
map -hosts       0Bi    0Bi    0Bi   100%       &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;                   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  100%   /net
map auto_home    0Bi    0Bi    0Bi   100%       &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;                   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  100%   /home
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;五传输文件&#34;&gt;五、传输文件&lt;/h2&gt;
&lt;h3 id=&#34;51-从远程服务器拉取文件&#34;&gt;5.1 从远程服务器拉取文件&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;get&lt;/code&gt; 命令可以从远程服务器拉取文件到本地：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; get remoteFile &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;newName&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果不指定 &lt;code&gt;newName&lt;/code&gt;，将使用和远程服务器相同的文件名。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;-r&lt;/code&gt; 参数可以拉取整个目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; get -r remoteDirectory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;52-从本地上传文件到服务器&#34;&gt;5.2 从本地上传文件到服务器&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;put&lt;/code&gt; 命令可以从本地上传文件到服务器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; put localFile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样的，可以使用 &lt;code&gt;-r&lt;/code&gt; 参数来上传整个目录，但是有一点要注意，&lt;strong&gt;如果服务器上不存在这个目录需要首先新建&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp&amp;gt; mkdir folderName
sftp&amp;gt; put -r folderName
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;六最佳实践&#34;&gt;六、最佳实践&lt;/h2&gt;
&lt;p&gt;1）连接远程服务器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp remote_user@remote_host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）使用端口进行连接&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sftp -P remote_port remote_user@remote_host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3）从远程服务器拉取文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;get /path/remote_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4）上传本地文件到服务器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;put local_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5）查看远程服务器目录内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6）查看本地目录内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bassh&#34; data-lang=&#34;bassh&#34;&gt;lls
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7）执行本地 Shell 命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;!&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;command&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol&#34;&gt;SSH File Transfer Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server&#34;&gt;How To Use SFTP to Securely Transfer Files with a Remote Server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>跨域资源共享（CORS）详解</title>
      <link>http://blog.jiayuanzhang.com/post/cors-tutorial/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/cors-tutorial/</guid>
      <description>&lt;p&gt;Web 后端开发者很少会去充分了解跨域问题，原因是他们很少和 JavaScript 打交道。但是作为一个 Web 开发者，知道跨域请求和如何解决跨域问题可以和前端开发者在沟通上变得更为顺畅。&lt;/p&gt;
&lt;p&gt;这篇文章会介绍和跨域请求相关的一些概念，以及如何在后端（Python）解决浏览器的跨域请求问题。&lt;/p&gt;
&lt;h2 id=&#34;一什么是跨域请求&#34;&gt;一、什么是跨域请求&lt;/h2&gt;
&lt;p&gt;首先，我们要了解什么是跨域请求。简单来说，当一台服务器资源从另一台服务器（不同的域名或者端口）请求一个资源时，就会发起一个跨域 HTTP 请求。&lt;/p&gt;
&lt;p&gt;举个简单的例子，&lt;code&gt;http://example-a.com/index.html&lt;/code&gt; 这个 HTML 页面请求了 &lt;code&gt;http://example-b.com/resource/image.jpg&lt;/code&gt; 这个图片资源时（发起 Ajax 请求，非 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签），就是发起了一个跨域请求。&lt;/p&gt;
&lt;p&gt;在不做任何处理的情况下，这个跨域请求是无法被成功请求的，因为浏览器基于&lt;strong&gt;同源策略&lt;/strong&gt;会对跨域请求做一定的限制。&lt;/p&gt;
&lt;h2 id=&#34;二浏览器同源策略&#34;&gt;二、浏览器同源策略&lt;/h2&gt;
&lt;p&gt;这就引出了&lt;strong&gt;浏览器的同源策略（Same-origin policy）&lt;/strong&gt;，同源策略限制了从同一个源加载的文档或者脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/p&gt;
&lt;p&gt;什么是同源？同源需要同时满足三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求的协议相同（例如同为 http 协议）&lt;/li&gt;
&lt;li&gt;请求的域名相同（例如同为 &lt;code&gt;www.example.com&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;请求的端口相同（例如同为 80 端口）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 2 点需要注意的是，必须是域名完全相同，比如说 &lt;code&gt;blog.example.com&lt;/code&gt; 和 &lt;code&gt;mail.example.com&lt;/code&gt; 这两个域名，虽然它们的顶级域名和二级域名（均为 &lt;code&gt;example.com&lt;/code&gt;）都相同，但是三级域名（&lt;code&gt;blog&lt;/code&gt; 和 &lt;code&gt;mail&lt;/code&gt;）不相同，所以也不能算作域名相同。&lt;/p&gt;
&lt;p&gt;如果不同时满足这上面三个条件，那就不符合浏览器的同源策略。&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;document.domain&lt;/code&gt; 参数可以更改当前的源，例如 &lt;code&gt;blog.example.com&lt;/code&gt; 想要访问父域 &lt;code&gt;example.com&lt;/code&gt; 的资源时，可以执行以下 JavaScript 脚本来进行修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;domain&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;example.com&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是 &lt;code&gt;document.domain&lt;/code&gt; 不能被设置为 &lt;code&gt;foo.com&lt;/code&gt; 或者是 &lt;code&gt;bar.com&lt;/code&gt;，因为它们不是 &lt;code&gt;blog.example.com&lt;/code&gt; 的超级域。&lt;/p&gt;
&lt;p&gt;当然，也不是所有的交互都会被同源策略拦截下来，下面两种交互就不会触发同源策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨域写操作（Cross-origin writes），例如超链接、重定向以及表单的提交操作，特定少数的 HTTP 请求需要添加预检请求（preflight）；&lt;/li&gt;
&lt;li&gt;跨域资源嵌入（Cross-origin embedding）：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签嵌入的跨域脚本；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 标签嵌入的 CSS 文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签嵌入图片；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 标签嵌入多媒体资源；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 的插件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@font-face&lt;/code&gt; 引入的字体，一些浏览器允许跨域字体（cross-origin fonts），一些需要同源字体（same-origin fonts）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 载入的任何资源，站点可以使用 &lt;code&gt;X-Frame-Options&lt;/code&gt; 消息头来组织这种形式的跨域交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果浏览器缺失同源策略这种安全机制会怎么样呢？设想一下，当你登陆了 &lt;code&gt;www.bank.com&lt;/code&gt; 银行网站进行操作时，浏览器保存了你登录时的 Cookie 信息，如果没有同源策略，在访问其他网站时，其他网站就可以读取还未过期的 Cookie 信息，从而伪造登陆进行操作，造成财产损失。&lt;/p&gt;
&lt;h2 id=&#34;三corscross-origin-resource-sharing跨域资源共享&#34;&gt;三、CORS（Cross-origin resource sharing，跨域资源共享）&lt;/h2&gt;
&lt;p&gt;虽然同源策略一定程度上保证了安全性，但是如果是一个正常的请求需要跨域该怎么做呢？&lt;/p&gt;
&lt;p&gt;常见的方法有四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSONP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 标签&lt;/li&gt;
&lt;li&gt;CORS（Cross-origin resource sharing，跨域资源共享）&lt;/li&gt;
&lt;li&gt;代理服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前两种方式本质上是利用浏览器同源策略的漏洞来进行跨域请求，不是推荐的做法，只能作为低版本浏览器的缓兵之计。&lt;/p&gt;
&lt;p&gt;代理服务器的做法是让浏览器访问同源服务器，再由同源服务器去访问目标服务器，这样虽然可以避免跨域请求的问题，但是原本只需要一次的请求被请求了两次，无疑增加了时间的开销。&lt;/p&gt;
&lt;p&gt;目前主流的方法是使用 CORS 的方式，这也是下面主要讲的内容。&lt;/p&gt;
&lt;h3 id=&#34;31-什么是-cors&#34;&gt;3.1 什么是 CORS&lt;/h3&gt;
&lt;p&gt;CORS 其实是浏览器制定的一个规范，它的实现则主要在服务端，它通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。&lt;/p&gt;
&lt;p&gt;对于那些会对服务器数据产生副作用的 HTTP 请求，浏览器会使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发起一个预检请求（preflight request），从而可以获知服务器端是否允许该跨域请求，服务器端确认允许后，才会发起实际的请求。在预检请求的返回中，服务器端也可以告知客户端是否需要身份认证信息。&lt;/p&gt;
&lt;h3 id=&#34;32-简单请求simple-requests&#34;&gt;3.2 简单请求（Simple requests）&lt;/h3&gt;
&lt;p&gt;某些请求不会触发 CORS 预检请求，我们称这样的请求为简单请求。&lt;/p&gt;
&lt;p&gt;若请求满足下面所有条件，则该请求可视为简单请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; 方法之一；&lt;/li&gt;
&lt;li&gt;Header 仅有以下字段：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt; 为下面三者之一：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;text / plain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipart / form-data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application / x-www.form-urlencoded&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DPR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Downloadlink&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Save-Data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Viewport-Width&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Width&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请求中的任意 &lt;code&gt;XMLHttpRequestUpload&lt;/code&gt; 对象均没有注册任何事件监听器，&lt;code&gt;XMLHttpRequestUpload&lt;/code&gt; 对象可以使用 &lt;code&gt;XMLHttpRequest.upload&lt;/code&gt; 属性访问；&lt;/li&gt;
&lt;li&gt;请求中没有使用 &lt;code&gt;ReadableStream&lt;/code&gt; 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举一个例子&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，例如站点 &lt;code&gt;http://foo.example&lt;/code&gt; 的网页应用想要访问 &lt;code&gt;http://bar.other&lt;/code&gt; 的资源，&lt;code&gt;http://foo.example&lt;/code&gt; 的网页中可能包含类似于下面的 JavaScript 代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;XMLHttpRequest&lt;/span&gt;();
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://bar.other/resources/public-data/&amp;#39;&lt;/span&gt;;
   
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callOtherDomain&lt;/span&gt;() {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;) {    
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onreadystatechange&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(); 
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;熟悉 JavaScript 的同学可能发现这段代码向 &lt;code&gt;http://bar.other/resources/public-data/&lt;/code&gt; 发起了一个 &lt;code&gt;GET&lt;/code&gt; 请求，请求和响应的报文如下。&lt;/p&gt;
&lt;p&gt;请求报文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190505164610.png&#34; alt=&#34;2018-12-02-request-msg&#34;&gt;&lt;/p&gt;
&lt;p&gt;响应报文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNbRwgy1fxsiwz302wj31uo0rsn0i.jpg&#34; alt=&#34;2018-12-02-response-msg&#34;&gt;&lt;/p&gt;
&lt;p&gt;在请求报文中，&lt;code&gt;Origin&lt;/code&gt; 字段表明该请求来源于 &lt;code&gt;http://foo.example&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在响应报文中，&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 字段被设置为 &lt;code&gt;*&lt;/code&gt;，表明该资源可以被任意的域访问。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Origin&lt;/code&gt; 和 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 就能完成最简单访问控制。如果服务端仅允许来自 &lt;code&gt;http://foo.example&lt;/code&gt; 域的访问，应该把 进行如下设置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Allow-Origin: http://foo.example
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;33-预检请求preflight-request&#34;&gt;3.3 预检请求（Preflight Request）&lt;/h3&gt;
&lt;p&gt;和简单请求不同，「需预检的请求」要求必须先使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发送一个预检请求到服务器，以获知服务器是否允许该请求，或者是否需要携带身份认证信息。「预检请求」的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。&lt;/p&gt;
&lt;p&gt;当一个请求满足以下任一条件时，该请求需要首先发送预检请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了下面任一 HTTP 方法：&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;CONNECT&lt;/code&gt;、&lt;code&gt;OPTIONS&lt;/code&gt;、&lt;code&gt;TRACE&lt;/code&gt;、&lt;code&gt;PATCH&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Header 中设置了除简单请求 Header 字段外的其他字段（见简单请求中的 Header 字段说明）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt; 的值不属于下列之一：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text/plain&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请求中的 &lt;code&gt;XMLHttpRequestUpload&lt;/code&gt; 对象注册了任意多个事件监听器；&lt;/li&gt;
&lt;li&gt;请求中使用了 &lt;code&gt;ReadableStream&lt;/code&gt; 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如下面这个例子&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;XMLHttpRequest&lt;/span&gt;();
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://bar.other/resources/post-here/&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&amp;lt;person&amp;gt;&amp;lt;name&amp;gt;Arun&amp;lt;/name&amp;gt;&amp;lt;/person&amp;gt;&amp;#39;&lt;/span&gt;;
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callOtherDomain&lt;/span&gt;(){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;)
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
      &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setRequestHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-PINGOTHER&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pingpong&amp;#39;&lt;/span&gt;);
      &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setRequestHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;application/xml&amp;#39;&lt;/span&gt;);
      &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onreadystatechange&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt;;
      &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;); 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码使用 POST 请求发送一个 XML 文档，该请求中包含了一个自定义的 Header 字段 &lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt;。另外，该请求的 &lt;code&gt;Content-Type&lt;/code&gt; 为 &lt;code&gt;application/xml&lt;/code&gt;，因此，该请求需要首先发起「预检请求」。&lt;/p&gt;
&lt;p&gt;OPTIONS 请求报文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tNbRwgy1fxtit1a99sj31uo0rs0yi.jpg&#34; alt=&#34;2018-12-03-option-request-msg&#34;&gt;&lt;/p&gt;
&lt;p&gt;OPTIONS 响应报文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tNbRwgy1fxtiwydue5j31uo0rsjwi.jpg&#34; alt=&#34;2018-12-03-option-response-msg&#34;&gt;&lt;/p&gt;
&lt;p&gt;OPTIONS 方法是 HTTP/1.1 中定义的方法，用以从服务器获取更多的信息，该方法不会对服务器资源产生影响。预检请求的 Headers 中携带了两个字段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Request-Method: POST
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Request-Headers: X-PINGOTHER, Content-Type
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Access-Control-Request-Method: POST&lt;/code&gt; 字段告诉服务器，实际请求将使用 &lt;code&gt;POST&lt;/code&gt; 方法；&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 字段告诉服务器，实际请求将携带两个自定义请求的 Header 字段：&lt;code&gt;X-PINGOTHER&lt;/code&gt; 和 &lt;code&gt;Content-Type&lt;/code&gt;，服务器根据此决定，该实际请求是否被允许。&lt;/p&gt;
&lt;p&gt;OPTIONS 响应报文表明服务器将接受后续的实际请求，其中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Allow-Origin: http://foo.example
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Allow-Methods: POST, GET, OPTIONS
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Access-Control-Max-Age: 86400
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Origin &lt;/code&gt;表示允许 &lt;code&gt;http://foo.example&lt;/code&gt; 的域进行访问；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 表明允许客户端发送 &lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;OPTIONS&lt;/code&gt; 请求；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 表明语序客户端携带 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 和 &lt;code&gt;Content-Type&lt;/code&gt; Header 字段；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 表明该响应的有效时间为 86400 秒（24 小时），在有效时间内，浏览器无需为同一请求再次发起预检请求。（注，浏览器自身维护了一个最大有效时间，如果该 Header 字段超过了最大有效时间，将不会生效）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预检请求完成之后，发送实际的请求，请求报文如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;POST&lt;/span&gt; /resources/post-here/ &lt;span style=&#34;color:#66d9ef&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.1&lt;/span&gt;
Host&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;bar.other&lt;/span&gt;
User-Agent&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre&lt;/span&gt;
Accept&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/span&gt;
Accept-Language&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;en-us,en;q=0.5&lt;/span&gt;
Accept-Encoding&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;gzip,deflate&lt;/span&gt;
Accept-Charset&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/span&gt;
Connection&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;keep-alive&lt;/span&gt;
X-PINGOTHER&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;pingpong&lt;/span&gt;
Content-Type&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;text/xml; charset=UTF-8&lt;/span&gt;
Referer&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;http://foo.example/examples/preflightInvocation.html&lt;/span&gt;
Content-Length&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;
Origin&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;http://foo.example&lt;/span&gt;
Pragma&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;no-cache&lt;/span&gt;
Cache-Control&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;no-cache&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;person&amp;gt;&amp;lt;name&amp;gt;&lt;/span&gt;Arun&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/name&amp;gt;&amp;lt;/person&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;响应报文：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OK&lt;/span&gt;
Date&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Mon, 01 Dec 2008 01:15:40 GMT&lt;/span&gt;
Server&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Apache/2.0.61 (Unix)&lt;/span&gt;
Access-Control-Allow-Origin&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;http://foo.example&lt;/span&gt;
Vary&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Accept-Encoding, Origin&lt;/span&gt;
Content-Encoding&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;gzip&lt;/span&gt;
Content-Length&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;235&lt;/span&gt;
Keep-Alive&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;timeout=2, max=99&lt;/span&gt;
Connection&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Keep-Alive&lt;/span&gt;
Content-Type&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;text/plain&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;[Some GZIP&amp;#39;d payload]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;34-附带身份认证的请求&#34;&gt;3.4 附带身份认证的请求&lt;/h3&gt;
&lt;p&gt;一般而言，对于跨域 &lt;code&gt;XMLHTTPRequest&lt;/code&gt; 或者 &lt;code&gt;Fetch&lt;/code&gt; 请求，浏览器不会发送身份凭证信息，如果需要发送身份凭证信息，需要把 &lt;code&gt;XMLHTTPRequest&lt;/code&gt; 的 &lt;code&gt;withCredentials&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;举个例子，下面这段代码表示 &lt;code&gt;http://foo.example&lt;/code&gt; 向 &lt;code&gt;http://bar.other&lt;/code&gt; 发送一个 &lt;code&gt;GET&lt;/code&gt; 请求，并且设置 &lt;code&gt;Cookies&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;XMLHttpRequest&lt;/span&gt;();
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://bar.other/resources/credentialed-content/&amp;#39;&lt;/span&gt;;
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callOtherDomain&lt;/span&gt;(){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;withCredentials&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onreadystatechange&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;invocation&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(); 
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过把 &lt;code&gt;withCredentials&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;，从而向服务器发送一个携带 &lt;code&gt;Cookies&lt;/code&gt; 的请求。因为这是一个简单的 &lt;code&gt;GET&lt;/code&gt; 请求，所以浏览器不会发起预检请求，但是，服务端的响应中如果未携带 &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; ，浏览器不会把响应内容返回给请求的发送者。&lt;/p&gt;
&lt;p&gt;对于携带身份认证的请求，服务器不得设置 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 的值为 &lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;35-用于-cors-的-headers&#34;&gt;3.5 用于 CORS 的 Headers&lt;/h3&gt;
&lt;p&gt;下面列出所有用于 HTTP 请求和响应中的 Header 字段，具体的使用请查阅&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers&#34;&gt;相关文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;HTTP 请求 Headers：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Origin&lt;/code&gt;：表明预检请求或实际请求的源站，它不包含任何路径信息，只是服务器名称（URI）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;：用于预检请求，作用是将实际请求所使用 HTTP 方法告诉服务器；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;：用于预检请求，作用是将实际请求所使用的 Header 字段告诉服务器；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP 响应 Headers：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;：指定了允许访问该资源的外域 URI；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;：让服务器把允许浏览器访问的头放入白名单，这样浏览器就能使用 &lt;code&gt;getResponseHeader&lt;/code&gt; 方法来访问了；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;：指定了预检请求的结果能够被缓存多久；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;：指定了当浏览器的&lt;code&gt;credentials&lt;/code&gt;设置为 true 时是否允许浏览器读取 response 的内容；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;：用于预检请求的响应。其指明了实际请求中允许携带的首部字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四服务器端实现&#34;&gt;四、服务器端实现&lt;/h2&gt;
&lt;p&gt;为了实现 CORS，在服务器端需要做一些工作，最主要的就是在响应 Header 中添加指定的字段。&lt;/p&gt;
&lt;p&gt;如果是使用 Python + Flask 的开发的话，可以在 &lt;code&gt;after_app_request&lt;/code&gt; 钩子函数中添加指定的响应头：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@app.after_app_request&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;after_request&lt;/span&gt;(response):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;正常请求结束后的处理&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# ... some code here&lt;/span&gt;
    
    response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Origin&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://example.com&amp;#39;&lt;/span&gt;
    response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Methods&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET, PUT, POST, DELETE, HEAD, OPTIONS&amp;#39;&lt;/span&gt;
    response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Headers&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type, Authorization, X-Requested-With&amp;#39;&lt;/span&gt;
    )
    
    &lt;span style=&#34;color:#75715e&#34;&gt;# ... some code here&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; response
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他语言在对应的钩子函数中处理即可。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;&gt;Same-origin policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&#34;&gt;浏览器同源政策及其规避方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;这个例子的来源：&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>OmniFocus 3 使用指南</title>
      <link>http://blog.jiayuanzhang.com/post/omnifocus-3-workflow/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/omnifocus-3-workflow/</guid>
      <description>&lt;p&gt;这篇文章主要分享一下我多年使用的一套任务管理系统的经验，工具是次要的，主要是一些想法的实践。有了基本的思路，无论是 OmniFocus、Todoist 还是 org-mode（Emacs 中的一个时间管理模式），都可以有自己的一套方式来实践。本篇文章主要以 OmniFocus 3 为载体来介绍这些内容。&lt;/p&gt;
&lt;p&gt;每个人都有一套适合自己的工作流，所以读者不必要完全按照我所写的来操作，正确的方式是从中获取一些灵感，实践并融合到自己的工作流当中。&lt;/p&gt;
&lt;h2 id=&#34;什么是一个好的任务管理系统&#34;&gt;什么是一个好的任务管理系统&lt;/h2&gt;
&lt;p&gt;首先，任务管理系统的目的是为了更好得完成任务，一切脱离这个基本条件的系统都是不可用的。如果你觉得一个最简单的 Todo List 就能很好地完成任务，那么这就是最适合你的任务管理系统。&lt;/p&gt;
&lt;p&gt;在我看来，一个优秀的任务管理系统至少需要满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收集能力&lt;/li&gt;
&lt;li&gt;在特定的情况下要知道可以做哪些事情&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;「收集能力」指的是这个任务系统要能够容纳（几乎）所有的内容，一个任务、一条想法、一封未读的邮件、一个笔记、一个链接、没有报销的发票等等。&lt;/p&gt;
&lt;p&gt;具体实践起来并不是真的需要把所有的东西都塞进任务系统里面，例如我使用 Evernote 作为剪裁和笔记的工具，很显然把每条笔记都复制一份到 OmniFocus 中很不现实，但是我会在 OmniFocus 中添加一个「定期清理 Evernote Inbox」的任务，这样就相当于把 Evernote 作为 OmniFocus 的子 Inbox，来统一进行管理。对于一些支持 URL Schema 的应用，完全可以在 OmniFocus 中建立一个链接直接指定，这样在 OmniFocus 中也可以直接打开其他应用中的内容了。&lt;/p&gt;
&lt;p&gt;收集能力决定了要处理的内容，第二个条件则决定了一个任务系统是否高可用。具体的情境来说，你要知道早上的时候该干哪些事，工作的时候该干哪些事，无聊的时候该干哪些事等等，而不是依靠大脑来记录什么时间要做什么事情，这样很容易进入游离的状态。&lt;/p&gt;
&lt;p&gt;一个任务系统做好了这两件事情，至少不会让你感到「有事可做，但无从下手」的状况，真正的执行还是需要靠自己的意志力了，从另一种情况下来说，即使意志力不强，完全可以找一些「不太重要、很轻松」的事，这在一定程度上利用了「结构性拖延」的办法来完成一些任务。&lt;/p&gt;
&lt;h2 id=&#34;任务管理系统的三要素&#34;&gt;任务管理系统的三要素&lt;/h2&gt;
&lt;p&gt;到现在为止，我还没有讲到一种具体工具的使用。因为工具是次要的，了解了本质的思想，使用什么工具都没有问题。纵观各种任务管理的工具：OmniFocus、Todoist、Things、org-mode，它们支持的功能也各不相同，Project、无限层级、Defer、Due、Repeat、Context、Label、Tag、Filter、Perspective 等等，有没有被这些名词给吓到？难道我们每切换一种系统都需要再重新学习一遍？&lt;/p&gt;
&lt;p&gt;抛开这些名词，我们来分析一下一个任务系统到底是由什么组成的。在我看来，一个任务系统最本质的东西只有三个：任务、附加元素和过滤器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;：一个最小可执行的单元即为一个任务。这个是最好理解的，所以不做过多解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附加元素&lt;/strong&gt;：作用在任务上的不同维度的限制。这句话读起来有点拗口，举个简单例子，「去 XXX 取快递（截止今天 10:00）」，其中，「截止今天 10:00」就是在时间维度上对这个任务的一个限制。同样的，「项目」、「标签」等等这些都是作用在某个任务上的附加元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过滤器&lt;/strong&gt;：组合不同附加元素的过滤规则。只有附加元素并没有什么实际的作用，但是有了过滤器之后，就可以编写不同的过滤规则来过滤指定规则的任务。例如，我想知道「最近 10 天内重要的事情」，那么过滤规则可能就是「Due date &amp;lt; 10 and flagged」。&lt;/p&gt;
&lt;p&gt;了解了上面三个基本的概念，那么再重新审视各种任务管理工具，就可以从一个比较宏观的角度来看待了，这也可以避免切换工具造成的重新学习成本。&lt;/p&gt;
&lt;h2 id=&#34;omnifocus-3-实践&#34;&gt;OmniFocus 3 实践&lt;/h2&gt;
&lt;p&gt;把上面任务系统的基本三要素运用到 OmniFocus 上，任务就是一个个的单独 Todo item，附加元素就是 Todo item 所属的项目、Due Date、Defer Date、Tags、Flag、Repeat rule 等，过滤器就是透视（Perspective）。&lt;/p&gt;
&lt;p&gt;接下来的内容我会通过 OmniFocus 3 为载体，来具体介绍如何实现一个可靠的任务管理系统，并介绍一些实际实践过的 Workflow 流程。&lt;/p&gt;
&lt;h3 id=&#34;项目的设定&#34;&gt;项目的设定&lt;/h3&gt;
&lt;p&gt;项目的设定建议使用统一的一套项目设定，例如，我的 OmniFocus 的项目和 Evernote 笔记的项目几乎是一一对应的，这样做的好处可以保证你的项目分类始终处于一个有序的状态。&lt;/p&gt;
&lt;p&gt;如果想保证项目比较有序，分成三个层级即可：大的领域（Folder）- 子领域（Folder）- 项目（Project）。&lt;/p&gt;
&lt;p&gt;例如，我的项目分类如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152724.png&#34; alt=&#34;OmniFocus 项目分类&#34;&gt;&lt;/p&gt;
&lt;p&gt;我主要分成了 5 个比较大的项目：工作、学习、生活、兴趣、系统，基本上可以涵盖涉及到的所有领域了。在每个大的项目中再细分出小的项目，这个可以根据自己的需要来进行细分。OmniFocus 支持无限层级的项目划分，但是个人只建议分三层，最后一层直接是任务就可以了，这样可以保证项目层级不会过于复杂。&lt;/p&gt;
&lt;p&gt;可以看到很多项目下面都有用&lt;code&gt;[]&lt;/code&gt;括起来的项目，这个是 Single List 项目，这样一些不属于某个项目里面的内容就可以放到这个列表里了。&lt;/p&gt;
&lt;p&gt;项目的分类并不一定要按照我的来，只要保证一定的规整化即可。&lt;/p&gt;
&lt;p&gt;一些项目设定的 Tips：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不是 Single List，项目需要一个既定的完成条件，在某一时刻或某一条件下，这个项目是要能够被标记为 Completed 或者 Dropped，这样可以避免一个项目长时间地呆在任务系统中；&lt;/li&gt;
&lt;li&gt;项目中的任务最好是最小可执行的，如果是比较大的任务，可以利用 OmniFocus 的无限任务层级继续细分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;标签的设定&#34;&gt;标签的设定&lt;/h3&gt;
&lt;p&gt;OmniFocus 3 的标签系统可以在自带功能的基础上添加更多的附加元素，从而在设定过滤器的时候更加准确地过滤出符合的任务。基于此目的，可以根据需求设定出适合自己的标签系统。&lt;/p&gt;
&lt;p&gt;OmniFocus 3 缺失的一个很常见的功能就是 Schedule，一个任务在时间维度上应该有有截止日期（Due）和安排日期（Schedule）两个元素，Due 表示在某一天之前必须被完成，Schedule 表示被安排到某一天做，所以可以设定如下标签来完成 Schedule 的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Schedule
&lt;ul&gt;
&lt;li&gt;ThisMonth：被安排到这个月&lt;/li&gt;
&lt;li&gt;ThisWeek：被安排到这周&lt;/li&gt;
&lt;li&gt;Today：被安排到今天&lt;/li&gt;
&lt;li&gt;Recenly：最近需要做的事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样在做计划的时候，打上对应的标签，就可以使用过滤器过滤出对应的任务了，比如我想看「这个月和工作相关的任务」，那么就可以指定 Project 为「Work」项目，标签为「ThisMonth」，这样对应的任务就可以使用这个过滤器过滤出来，具体的过滤器设定下面会讲到。&lt;/p&gt;
&lt;p&gt;另外一个可以借鉴的设定就是精力值标签：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Energy
&lt;ul&gt;
&lt;li&gt;LowEnergy&lt;/li&gt;
&lt;li&gt;MediumEnergy&lt;/li&gt;
&lt;li&gt;HighFocus&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，我们工作了一整天之后，还剩一段时间才下班，精力已经下降到一个很低的值，这个时候已经不适合完成一些需要非常专注的工作了，但是一些工作上的杂事，例如打印东西，提交报表等简单的工作可以利用这个时间来完成，这个时候我们就可以设定一个过滤器，过滤出 Project 为「Work」，标签为「LowEnergy」的任务。&lt;/p&gt;
&lt;p&gt;我们可以看到，标签系统可以极大地扩展附加元素的内容，给过滤器添加更多的过滤维度。标签系统的设定应该根据自己的需求来，如果设定的标签却没有在过滤器中用到的话，那么也仅仅是个任务添加了一个没有用上的附加元素而已，意义不大。&lt;/p&gt;
&lt;h3 id=&#34;过滤器的设定&#34;&gt;过滤器的设定&lt;/h3&gt;
&lt;p&gt;过滤器的目的就是组合各种条件，过滤出所需要的任务来，之前所有的任务上的附加元素都是为了过滤器而设定的。&lt;/p&gt;
&lt;p&gt;过滤器在 OmniFocus 3 中就是透视（Perspective）。在 OmniFocus 3 中，透视功能被很大的增强了，支持类似于 iTunes 智能播放列表一样的设定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152804.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是仔细使用下来会发现，OmniFocus 3 的过滤器设定依然是有局限的，并不能想 iTunes 那样自由地对元素进行操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152822.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;尽管如此，相比较 OmniFocus 2 残疾一样的过滤器设定，已经好太多了。用过 Todoist 的同学可能会知道，Todoist 的过滤器设定支持自定义的一套语法，OmniFocus 3 与之相比，还是要差了许多，主要是提供的可过滤元素太少，过滤条件也不够自由，但是结合标签系统也基本上能满足日常的使用。&lt;/p&gt;
&lt;p&gt;同标签系统一样，过滤器的设定依然需要结合自己的情况来。我主要设定了以下几个过滤器，这些过滤器都是在实践中经常使用到的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152841.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;routine-过滤器&#34;&gt;Routine 过滤器&lt;/h4&gt;
&lt;p&gt;这个过滤器主要被用于制定计划，例如，我每天早上去公司都会有 Morning Review，来规划今天一天的工作任务。这个时候，我只需要打开这个过滤器，依次把上面的事情做完，今天的计划安排就被制定好了。&lt;/p&gt;
&lt;p&gt;过滤器的详细设定如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152916.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中，「Routine」Folder 中就是设定的具体内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152930.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这一个过滤器的设定是和我的 Workflow 紧密相连的，如果你没有做 Morning Review 之类的习惯，可以不需要设定这个过滤器。&lt;/p&gt;
&lt;h4 id=&#34;today-过滤器&#34;&gt;Today 过滤器&lt;/h4&gt;
&lt;p&gt;这个过滤器被使用的次数最多，类似于 Forecast 的功能，但是相比较 Forecast，自定义的程度更大。&lt;/p&gt;
&lt;p&gt;过滤器的详细设定如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326152950.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个过滤器将会把符合以下条件的任务过滤出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即将截止或者标注为 Today 标签的任务&lt;/li&gt;
&lt;li&gt;状态为 Available 的任务&lt;/li&gt;
&lt;li&gt;非 Routine Folder 下的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显示方式以 Project 为维度显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153001.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对比 Forecast Perspective，它只是把对应的任务都展示了出来，在任务的层级上没有自定义的那么清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153012.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想要 Forecast 显示特定标签的任务，可以参考如下设定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153036.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;work-过滤器&#34;&gt;Work 过滤器&lt;/h4&gt;
&lt;p&gt;这个过滤器和 Today 类似，只不过指定了所属项目为「Work」文件夹下面的任务，这个主要是在工作中只想专注于和工作相关的任务。&lt;/p&gt;
&lt;p&gt;过滤器的详细设定如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153049.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了指定了特殊的项目目录，其他的设置和 Today 的设定没有区别。&lt;/p&gt;
&lt;h4 id=&#34;to-sth-过滤器&#34;&gt;To-Sth 过滤器&lt;/h4&gt;
&lt;p&gt;日常的使用中，我会把没有看的文章、需要写的东西、要读的书、要搜索的内容都存在 OmniFocus 中，所以需要一个过滤器能够快速过滤出这些内容。&lt;/p&gt;
&lt;p&gt;首先使用这个过滤器需要先设置一套标签系统：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153105.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;过滤器的详细设定如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153127.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际的使用场景：比如我想阅读一些和 Python（一门编程语言）相关的内容，那么我只需要打开这个 Perspective，挑选标签为「To-Read」，然后从搜索框中搜索 Python 关键字就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153145.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;future-过滤器&#34;&gt;Future 过滤器&lt;/h4&gt;
&lt;p&gt;这个过滤器主要被用于制定计划，在 Weekly Review 和 Daily Review 中会被频繁地使用到。需要基于以下的标签设定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153301.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;过滤器的详细设定如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153310.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;easydo-过滤器&#34;&gt;EasyDo 过滤器&lt;/h4&gt;
&lt;p&gt;这个过滤器会把一些简单的或者不需要太多精力的任务过滤出来&lt;/p&gt;
&lt;p&gt;过滤器的详细设定如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153322.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;完成时间小于 15 分钟或者被标注为「LowEnergy」标签的任务会被过滤出来。&lt;/p&gt;
&lt;h3 id=&#34;workflow&#34;&gt;Workflow&lt;/h3&gt;
&lt;p&gt;今年使用 OmniFocus 已经完成了 1500+ 的任务，经过这么长时间的使用，已经有了自己的一套任务处理流程了，随着 OmniFocus 3 的更新，这套任务处理的流程也经过了一些优化。在这整个 Workflow 中，主要分为三个部分：计划、执行、总结。&lt;/p&gt;
&lt;h4 id=&#34;计划&#34;&gt;计划&lt;/h4&gt;
&lt;p&gt;很多人都不重视计划这个环节，想到什么做什么，这样不仅会做事没有条理，也会分不清任务的优先级。&lt;/p&gt;
&lt;p&gt;一般来说，如果不知道怎么做计划的话，有一个长期计划和一个短期计划就可以了。长期计划主要是一个大体的方向，可以是年度计划或者月度计划；短期计划则需要明确具体要做哪些事情，可以是周计划或者日计划。&lt;/p&gt;
&lt;p&gt;实践过程中使用最多的就是周计划和日计划。在 OmniFocus 中，我设定了两个项目，分别是 Weekly Review 和 Morning Review。&lt;/p&gt;
&lt;p&gt;在做 Weekly Review 的时候，我会先在 Evernote 中大概写一下这周需要做哪些事情，然后在 OmniFocus 中打开 Future 过滤器，选择 ThisMonth 标签，把需要完成的项目和任务打上 ThisWeek 标签。&lt;/p&gt;
&lt;p&gt;在做 Morning Review 的时候，我会打开 Future 过滤器，选择 ThisWeek 和 Recently 标签，然后挑选今天需要完成的事情打上 Today 标签，这样，在 Today 和 Work 过滤器中就可以看到今天要做的事情了。&lt;/p&gt;
&lt;h4 id=&#34;执行&#34;&gt;执行&lt;/h4&gt;
&lt;p&gt;执行应该是整个 Workflow 中最重要的一个环节，如果只是计划了，但是最后任务却没有被完成，那做计划也只是白费力气。&lt;/p&gt;
&lt;p&gt;执行的关键就是要在对的时间内做对的事，这也是为什么要设置那么多过滤器的原因，在工作的时候就只展示工作相关要做的事，在没有精力的时候就只展示简单易做的事情。&lt;/p&gt;
&lt;p&gt;如果你做事情的时候很容易分心，可以参考一下番茄工作法，一般我会设置为专注 50 分钟，然后休息 10 分钟。默认的 25 分钟时间过短，可能刚进入状态就要被打断。&lt;/p&gt;
&lt;p&gt;另外可以尝试使用「结构化拖延法」（Structured Procrastination）。结构化拖延法就是忽略优先级高的事，而是从小的事，优先级比较低的事情开始做，这样慢慢地进入工作的状态，然后再去完成优先级高的事情。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;总结是为了更好地计划。总结给计划提供了更多的参考条件，可以当做计划的一把标尺。&lt;/p&gt;
&lt;p&gt;很多时候我们做计划都会看高自己完成任务的能力，结果就是一周过去了发现实际上并没有能够完成计划的内容，如果没有总结的话，下次做计划的时候还是按照这种量来计划，必定也是完成不了的，久而久之，就失去了做计划的动力。如果每周都做总结的话就能够知道这周完成了哪些内容，哪些内容没有完成，原因是什么，这样就能在下周的计划里面做改进。这种「反馈-调节」的机制可以促进整个任务处理流程的良性循环。&lt;/p&gt;
&lt;p&gt;一方面，如果你在 Evernote 中有写周计划的话，那么在每周的 Review 时候就可以打开对应的项目，在 Project 视图里面选择 All，这样就可以把所有的任务（包括已完成的）都展示出来，方便对照查看完成了哪些，又有哪些是没有完成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326153338.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另一方面，OmniFocus 3 提供了自带的 Review 透视，建立每个项目的时候可以选择多少天 Review 一次。实践上，一般工作上需要每天跟进的项目，会把 Review 的时间设置为每天一次，一般的项目设置为一周 Review 一次即可。为了防止忘记 Review，可以把这个 Review 的任务添加到 Morning Review 或者 Weekly Review 中。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;OmniFocus 2 刚发布时就开始使用了，期间还使用过 org-mode 和 Todoist，OmniFocus 3 发布了之后就立马重新迁移过来。虽然 OmniFocus 3 还存在着一些不足，但是已经能够很好地满足目前的工作流了。主要的使用场景大部分是在 macOS 上，iOS 基本上只是用来查看。&lt;/p&gt;
&lt;p&gt;这篇文章中所写的内容都是经过了很长时间实践之后得出的经验，一个好的任务系统是需要不断优化迭代的，如果你觉得自己的系统不怎么好用，不妨想一下哪些地方需要优化，然后慢慢改进它。掌握了任务管理的本质之后，不管是切换到什么工具都能够游刃有余。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2018 Weekly 35 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2018-week-35-review/</link>
      <pubDate>Sat, 01 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2018-week-35-review/</guid>
      <description>&lt;p&gt;重启之前写 Weekly Review 的习惯，一方面为了总结上一周都做了什么，另一方面也为了督促自己多多做事，不要碌碌无为。&lt;/p&gt;
&lt;p&gt;2018 这半年多的时间里面博客一直没有再继续写下去，工作占去了大部分的时间，剩下的时间又都分配给爱好，所以写博客这件事就暂时搁置了下来。过去一年的时间里面主要发展了两个爱好，摄影和滑板，即使是爱好，也会想把它做好，所以空闲下来的时间大部分精力都花在了上面。经过这半年多的时间来看，一个人不太可能同时把好几件事做得不错，所以在未来的一段时间内，需要考虑一下舍弃掉一项爱好了，或者只是仅仅当做爱好，不用去过于较真。&lt;/p&gt;
&lt;p&gt;自从工作了，发现刻意学习专业知识的时间越来越少，大部分情况都是工作中遇到什么东西不太了解然后找相关资料学习一下，Vue.js、PHP 就是在工作中学会的，虽然不能说熟练，但是应对基本开发内容还是没什么问题。Vue.js 看了一下官方文档就开始写了，PHP 甚至都没有看什么东西，就只是看了一下公司之前的源码，毕竟语言的内容大部分都是相通的，PHP 又和 Python 同为动态语言，基本上东西都差不多，熟悉了一天就开始上手开发业务了，增删改查的内容也不太需要太多技术含量。&lt;/p&gt;
&lt;p&gt;这种学习方式可以被称之为「自顶向下」的学习方法，和学校的「自底向上」的学习方法孰优孰劣，还得视情况而来。前者可以快速用起来，不用了解底层的内容，上手快，耗费时间短，但很容易停留在「顶」，没有继续深入下去，最后浮于表面；后者更加系统，学完会有一个整体的脉络，但是耗费时间长，底层的知识没办法实践，最后流于理论。所以正确的方式应该是把这两者结合起来，例如我主要是一个「后端开发工程师」，那对于 Vue.js 的一些底层实现理论，现在确实没有必要太了解，之后有需要的时候再看也不迟；而 CPython 底层的实现却是需要了解的内容，了解底层实现的缺陷在哪里，才能更好地进行优化。所以学习也要分好优先级，毕竟精力有限，不太重要的学习内容可以先靠后。&lt;/p&gt;
&lt;p&gt;说道学习，再谈一下「刻意学习」的问题，学习不是堆时间、拼谁比谁学的更久，更重要的是用对方法，这一点在学滑板的过程中领会很深。之前很长一段时间练习滑板都是在堆砌时间，虽说也有进步，但是太缓慢了，大部分的时候都是呆在「舒适区」内做一些自己已经熟练的动作，后来看到了 Rodney Mullen &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 的学习方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In short, Mullen is a very driven, smart individual. While many skaters spend a similar amount of hours skating every day as Mullen has, very few use those hours as efficiently as he did.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The minimum amount of time to spend on the board to impove is two hours a day, every day, without fail. One hour a day is enough to maintain skills, but you&amp;rsquo;ll never impove. Five hours+ a day is the key to rapid development.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Mullen prefers to skate alone, and so those two hours are spent skateboarding, and nothing else. In the 80s, he&amp;rsquo;d use a Casio watch with a stopwatch to time his sessions and make sure his sessions were long enough, even pausing the stopwatch when he took a short break.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;He breaks down his five hour weekend sessions thus:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;30 minutes: warming up, not worring about consistency.&lt;/li&gt;
&lt;li&gt;3 hours: practicing his contest run, breaking it down into three 40 second segments, and doing them over and over again until he could do them without looking at his board.&lt;/li&gt;
&lt;li&gt;90 minutes: learning new tricks.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;He also kept a skate notebook, writing down ideas for tricks, noting down observations on how his board flipped, and observing how different foot positions affected tricks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，Mullen 一直在按照计划来练习，而不是漫无目的地「玩」滑板，这也是他能成为大师的原因之一吧。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;滑板教父，街式滑板的发源者。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>《程序员修炼之道》阅读笔记（二）</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-2/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-2/</guid>
      <description>&lt;h3 id=&#34;重复的危害&#34;&gt;重复的危害&lt;/h3&gt;
&lt;p&gt;系统中的每一项知识都必须具有单一、无歧义、权威的表示。（感觉翻译得怪怪的）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 11
DRY - Don&amp;rsquo;t Repeat Yourself
不要重复你自己&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;重复是怎样发生的&#34;&gt;重复是怎样发生的&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;强加的重复（imposed duplication）：开发者觉得他们无可选择 —— 环境似乎要求重复。&lt;/li&gt;
&lt;li&gt;无意的重复（inadvertent duplication）：开发者没有意识到他们在重复信息。&lt;/li&gt;
&lt;li&gt;无耐性的重复（impatient duplication）：开发者偷懒，他们重复，因为那样似乎更容易。&lt;/li&gt;
&lt;li&gt;开发者之间的重复（interdeveloper duplication）：同一团队（或不同团队）的几个人重复了同样的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;强加的重复&#34;&gt;强加的重复&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信息的多种表示&lt;/p&gt;
&lt;p&gt;我们也许在编写客户-服务器应用，在客户和服务器端使用了不同的语言，并且需要在两端都表示某种共有的结构。我们或许需要一个类，其属性是某个数据库表的 schema。&lt;/p&gt;
&lt;p&gt;解决办法是编写简单的过滤器或代码生成器。可以在每次构建（build）软件时，使用简单的代码生成器，根据公共的元数据表示构建多种语言下的结构。可以用最初用于构建 schema 的元数据，自动生成类定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码中的文档&lt;/p&gt;
&lt;p&gt;代码为什么需要注释：糟糕的代码才需要许多注释。&lt;/p&gt;
&lt;p&gt;DRY 法则告诉我们，要把低级的知识放在代码中，它属于那里；把注释保留给其他高级说明。否则，我们就是在重复知识，而每一次改变都意味着既要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档与代码&lt;/p&gt;
&lt;p&gt;你撰写文档，然后编写代码。有些东西变了，你修订文档、更新代码。文档和代码都含有同一知识表示。&lt;/p&gt;
&lt;p&gt;可以根据文档来生成测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语言问题&lt;/p&gt;
&lt;p&gt;许多语言会在源码中强加可观的重复。如果语言使模块的接口与其实现分离，就常常会出现这样的情况。C/C++ 有头文件，在其中重复了被导出变量、函数和（C++）类的名称和类型信息。&lt;/p&gt;
&lt;p&gt;再思考一下头文件和实现文件中的注释。绝对没有理由在这两种文件之间重复函数或类头注释（head comment）。应该用头文件记载接口问题，用实现文件记载代码的使用者无需了解的实际细节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;无意的重复&#34;&gt;无意的重复&lt;/h5&gt;
&lt;p&gt;有时，重复来自设计中的错误。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Line&lt;/span&gt; {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		Point start;
		Point end;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; lenght;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一眼看上去这个类似乎是合理的。线段显然有起点和终点，并总是有长度的。但这里有重复，长度是由起点和终点决定的：改变其中一个，长度就会变化。最好是让长度编程计算字段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Line&lt;/span&gt; {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		Point start;
		Point end;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lenght&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; start.distanceTo(end); }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;无耐性的重复&#34;&gt;无耐性的重复&lt;/h5&gt;
&lt;p&gt;每个项目都有时间压力。&lt;/p&gt;
&lt;p&gt;如果你觉得受到了诱惑，想一想古老的格言「欲速则不达」。你现在也许可以节省几秒钟（感觉不止），但以后可能损失几小时。（如果一个人不打算在公司长久待下去的话是会写出重复的代码的，所以 code review 要做好）&lt;/p&gt;
&lt;p&gt;无耐性的重复是一种容易检测和处理的重复形式，但那需要你接受训练，并愿意为避免以后的痛苦而预先话一些时间。&lt;/p&gt;
&lt;h5 id=&#34;开发者之间的重复&#34;&gt;开发者之间的重复&lt;/h5&gt;
&lt;p&gt;或许最难检测和处理的重复发生在项目的不同开发者之间。处理这个问题的最佳方式是鼓励开发者进行主动地交流。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 12
Make It Easy to Reuse
让复用变得容易&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你所要做的就是营造一种环境，在其中找到并复用已有的东西，比自己编写更容易。&lt;/p&gt;
&lt;h3 id=&#34;正交性&#34;&gt;正交性&lt;/h3&gt;
&lt;p&gt;如果你想要制作易于设计、构建、测试及扩展的系统，正交性是一个十分关键的概念。&lt;/p&gt;
&lt;h4 id=&#34;什么是正交性&#34;&gt;什么是正交性&lt;/h4&gt;
&lt;p&gt;「正交性」是从几何学中借来的术语。如果两条直线相交成直角，它们就是正交的。&lt;/p&gt;
&lt;p&gt;在计算机技术中，该术语用于表示某种不相依赖性和解耦性。如果两个或更多事物中的一个发生变化，不会影响到其他事物，这些事物就是正交的。&lt;/p&gt;
&lt;h4 id=&#34;正交的好处&#34;&gt;正交的好处&lt;/h4&gt;
&lt;p&gt;非正交系统的改变与控制更复杂是其固有的性质。当任何系统的各组件互相高度依赖时，就不在具有局部修正这样的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 13
Eliminate Effects Between Unrelated Things
消除无关事物之间的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们想要设计自足（self-contained）的组件：独立、具有单一、良好定义的目的（内聚）。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你不改变组件的外部接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高生产率
&lt;ul&gt;
&lt;li&gt;改动得以局部化，所以开发实践和测试时间得以降低。编写多个相对较小的、自足的组件更为容易，你可以设计、编写简单的组间，对其进行单元测试。当你增加新代码时，无需不断改动已有的代码。&lt;/li&gt;
&lt;li&gt;正交的途径还能够促进复用。如果组间具有明确而具体的、良好定义的责任，就可以把它们和新组件整合到一起。&lt;/li&gt;
&lt;li&gt;如果你对正交的组件进行组合，生产效率会有相当微妙的提高（M x N &amp;gt; M * (N - i), i 为 M、N 重复内容）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降低风险
&lt;ul&gt;
&lt;li&gt;有问题的代码区域被隔离开来。&lt;/li&gt;
&lt;li&gt;所得的系统更健壮。&lt;/li&gt;
&lt;li&gt;政教系统很可能得到更好的测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;项目团队&#34;&gt;项目团队&lt;/h4&gt;
&lt;p&gt;怎样把团队划分为责任得到了良好定义的小组，并使重叠降至最低呢？没有简单的答案。我们的偏好是从使基础设施与应用分离开始。每个主要的基础设施组间（数据库、通信接口、中间件层等）有自己的子团队。如果应用功能的划分显而易见，那就照此划分。然后我们考察现有的人员，并对分组进行相应的调整。&lt;/p&gt;
&lt;p&gt;在讨论每个所需改动时需要涉及多少人。人数越多，团队的正交性就越差。&lt;/p&gt;
&lt;h4 id=&#34;设计&#34;&gt;设计&lt;/h4&gt;
&lt;p&gt;对于正交设计，有一种简单的测试方法。一旦设计好组件，问问你自己：如果我显著地改变了某个特定功能背后的需求，有多少模块会受到影响？在正交系统中，大难应该是「一个」。&lt;/p&gt;
&lt;p&gt;不要依赖你无法控制的事物属性。&lt;/p&gt;
&lt;h4 id=&#34;工具箱与库&#34;&gt;工具箱与库&lt;/h4&gt;
&lt;p&gt;在你引入第三方工具箱和库时，要注意保持系统的正交性。要明智地选择技术。它是否会迫使你对代码进行不必要的改动。如果对象持久模型（object persistence scheme）是透明的，那么它就是正交的。如果它要求你以一种特殊的方式创建或访问对象，那么它就不是正交的。&lt;/p&gt;
&lt;p&gt;正交性的另一个有趣的变体是面向切片编程（Aspect-Oriented Programming, AOP）。AOP 能让你在一个地方表达本来会分散在源码各处的某种行为。例如，日志消息通常是在源码各处、通过显式地调用某个日志函数生成的。通过 AOP，你可以把日志功能正交地实现到要进行日志记录的代码中。（Python 中的装饰器就可以实现这个功能）&lt;/p&gt;
&lt;h4 id=&#34;编码&#34;&gt;编码&lt;/h4&gt;
&lt;p&gt;你可以将若干技术用于维持正交性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让你的代码保持「解耦」：编写不会没有必要地向其他模块暴露任何事情、也不依赖其他模块具体实现的模块。&lt;/li&gt;
&lt;li&gt;避免使用全局数据&lt;/li&gt;
&lt;li&gt;避免编写相似的函数：使用 Strategy（策略）模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;养成不断地批判对待自己打的代码的习惯，寻找任何重新进行组织、以改善其结构和正交性的机会。这个过程叫重构（refactoring）。&lt;/p&gt;
&lt;h4 id=&#34;测试&#34;&gt;测试&lt;/h4&gt;
&lt;p&gt;正交地设计和实现的系统也更易于测试，因为系统的各组件间的交互是形式化和有限的，更多的系统测试可以在单个的模块进行。&lt;/p&gt;
&lt;h3 id=&#34;可撤销性&#34;&gt;可撤销性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果某个想法是你唯一的想法，再没有什么比这更危险的事了。 —— Emil-Auguste Chartier&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 14
There Are No Final Decisions
不存在最终决策&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。&lt;/p&gt;
&lt;h3 id=&#34;曳光弹&#34;&gt;曳光弹&lt;/h3&gt;
&lt;p&gt;为了在代码中获得「曳光弹」的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 15
Use Tracer Bullets to Find the Target
用曳光弹找到目标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;曳光弹告诉你击中的是什么，那不一定总是目标，于是你调整准心，直到完全击中目标为止，这正是要点所在。&lt;/p&gt;
&lt;h3 id=&#34;原型与便笺&#34;&gt;原型与便笺&lt;/h3&gt;
&lt;p&gt;你可以为下列事物制作原型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构&lt;/li&gt;
&lt;li&gt;已有系统中的新功能&lt;/li&gt;
&lt;li&gt;外部数据的结构或内容&lt;/li&gt;
&lt;li&gt;第三方工具或组件&lt;/li&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;用户界面设计&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。那才是原型制作的要点所在。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 16
Prototype to Learn
为了学习而制作原型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;怎样使用原型&#34;&gt;怎样使用原型&lt;/h4&gt;
&lt;p&gt;在构建原型时，你可以忽略哪些细节？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确性：你也许可以在适当的地方使用虚假的数据；&lt;/li&gt;
&lt;li&gt;完整性：原型也许只能在非常有限的意义上工作；&lt;/li&gt;
&lt;li&gt;健壮性：错误检查很有可能不完整。如果你偏离预定路径，原型就可能崩溃，这没有关系；&lt;/li&gt;
&lt;li&gt;风格：原型代码可能没有多少注释或文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为原型应该遮盖细节，并聚焦于所考虑系统的某些具体方面，你可以用非常高级的语言实现原型。高级的脚本语言能让你推迟考虑许多细节，并且仍然能制作出可以工作的代码。&lt;/p&gt;
&lt;h4 id=&#34;制作架构原型&#34;&gt;制作架构原型&lt;/h4&gt;
&lt;p&gt;一些你可以在架构原型中寻求解答的具体问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要组间的责任是否得到了良好的定义？是否适当？&lt;/li&gt;
&lt;li&gt;主要组间间的协作是否得到了良好的定义？&lt;/li&gt;
&lt;li&gt;耦合是否得以最小化？&lt;/li&gt;
&lt;li&gt;你能否确定重复的潜在来源？&lt;/li&gt;
&lt;li&gt;接口定义和各项约束是否可接受？&lt;/li&gt;
&lt;li&gt;每个模块在执行过程中是否能访问到其所需的数据？能够在需要时进行访问？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;领域语言&#34;&gt;领域语言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 17
Program Close to the Problem domain
靠近问题领域编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论适用于配置和控制应用程序的简单语言，还是用于指定规则或过程的更为复杂的语言，我们认为，你都应该考虑让你的项目更靠近问题领域。通过在更高的抽象层面上编码，你获得了专心解决领域问题的自由，并且可以忽略琐碎的实现细节。&lt;/p&gt;
&lt;h3 id=&#34;估算&#34;&gt;估算&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 18
Estimate to Avoid Surprises
估算，以避免发生意外&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;估算来自哪里&#34;&gt;估算来自哪里&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;理解提问内容：任何估算练习的第一步都是建立对提问内容的理解。除了上面讨论的精确度以外，你还需要把我问题域的范围。这常常隐含在问题中，但你需要养成在开始猜想之前先思考范围的习惯。&lt;/li&gt;
&lt;li&gt;建立系统的模型：根据你对所提问题的理解，建立粗略、就绪的思维模型骨架。&lt;/li&gt;
&lt;li&gt;把模型分解为组件：你需要找出描述这些组件怎样交互的数学规则。你将会发现，在典型的情况下，每个组件都有一些参数，会对它给整个模型带来什么造成影响。在这一阶段，只要确定每个参数就行了。&lt;/li&gt;
&lt;li&gt;给每个参数指定值：一旦你分解出各个参数，你就可以逐一给每个参数赋值。在这个步骤中你可能会引入一些错误。诀窍是找出哪些参数对结果的影响最大，并致力于让它们大致正确。&lt;/li&gt;
&lt;li&gt;计算答案：在计算阶段，你可能会得到看起来很奇怪的答案。不哟啊太快放弃它们，如果你的运算是正确的，那你对问题或模型的理解就很可能是错的。这是非常宝贵的信息。&lt;/li&gt;
&lt;li&gt;追踪你的估算能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;估算项目进度&#34;&gt;估算项目进度&lt;/h4&gt;
&lt;p&gt;在面对相当大的应用开发的各种复杂问题与反复无常的情况时，普通的估算规则可能会失效。为项目确定进度表的唯一途径常常是在相同的项目上获取经验。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查需求&lt;/li&gt;
&lt;li&gt;分析风险&lt;/li&gt;
&lt;li&gt;设计、实现、继承&lt;/li&gt;
&lt;li&gt;向用户确认&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 19
Iterate the Schedule with the Code
通过代码对进度表进行迭代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;第二章其实更多的再讲团队和产品设计方面的问题，自己在这两方面并没有什么经验。不过 DRY 和正交性的概念还是比较重要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《程序员修炼之道》阅读笔记（一）</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-1/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-1/</guid>
      <description>&lt;p&gt;实习到现在差不多两个月了，博客也一直荒废了没写。这次更新就先来写写读书笔记好了。&lt;/p&gt;
&lt;p&gt;这本书从书名来看其实很像那种鸡汤类的书，英文名「The Pragmatic Programmer」（注重实效的程序员）看上去就好了许多。&lt;a href=&#34;https://book.douban.com/subject/1152111/&#34;&gt;豆瓣评分&lt;/a&gt; 8.6 分。大一的时候买的书，之前随意地写过几年的玩具代码，所以初读这本书的时候觉得很有道理，但是读完了之后发现什么也没有记住。用&lt;a href=&#34;http://blog.youxu.info&#34;&gt;徐宥&lt;/a&gt;的话来说就是「读者如果没有类似的经历，看到这些珠玑，也只是觉得把玩颇为有趣而已，极少能有同感。」大一的时候读这是这种感觉。&lt;/p&gt;
&lt;p&gt;出来实习之后，接触到实际生产中的代码，在代码量比较大的情况下（几十万行），之前书中所讲的一些问题都一一浮现了。为了写出优雅的代码，有必要把这本书再读一遍，可能以后还要反复读很多遍（不是所有的内容看一遍就能内化在心里的），所以每读一部分就记一点笔记，留作日后复习用。&lt;/p&gt;
&lt;p&gt;给自己制定以下阅读的计划，因为这本书每一张的内容读起来都比较轻松，所以预计用两周的时间读完：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每 1-2 天阅读一章（共 8 章）&lt;/li&gt;
&lt;li&gt;每一章都写一篇笔记，读的时候可以做一些摘录，读完一章之后写一篇总结性的笔记；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是「序言」和「第一章」的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;序&#34;&gt;序&lt;/h2&gt;
&lt;h3 id=&#34;注重实效的程序员都有哪些特征&#34;&gt;注重实效的程序员都有哪些特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;早期的采纳者/快速的改编者：给你一样新东西，你很快能把握它，并把它与你的知识的其余部分结合在一起（尝试新技术）；&lt;/li&gt;
&lt;li&gt;好奇：你喜欢提问，你是收集小知识的林鼠（建立自己的知识 wiki）；&lt;/li&gt;
&lt;li&gt;批判的思考者：你会首先抓住事实，而不是照搬别人所说的；&lt;/li&gt;
&lt;li&gt;有现实感：你会设法理解你面临的每个问题的内在本质（事情有多困难，需要花多长时间完成？）&lt;/li&gt;
&lt;li&gt;多才多艺：你尽力熟悉广泛的技术和环境；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（审视一下自己，上面几点好像都没有做到，或者说有的做到了但是并不到位。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 1
Care About Your Craft
关心你的技艺&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何做到上面所说的？&lt;strong&gt;在你做某件事情的时候思考你在做什么&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 2
Think! About Your Work
思考！你的工作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;它是一个持续的过程&#34;&gt;它是一个持续的过程&lt;/h3&gt;
&lt;p&gt;每天为提炼你所拥有的技能而工作，为把新的工具增加到你的技能列表中二工作。草坪不是一天修成的。&lt;/p&gt;
&lt;h2 id=&#34;第一章注重实效的哲学&#34;&gt;第一章：注重实效的哲学&lt;/h2&gt;
&lt;h3 id=&#34;我的源码让猫给吃了&#34;&gt;我的源码让猫给吃了&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在所有的弱点中，最大的弱点就是害怕暴露弱点。—— J.B.Bossuet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你确实同意要为某个结果负责，你就应该切实负起责任。当你犯错误的时候，不要责备别人或别的东西，或是拼凑借口。你可以选择提供解决方案，而不是寻找借口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 3
Provide Options, Don&amp;rsquo;t Make Lame Excuses
提供各种选择，不要找蹩脚的借口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在你走向任何人，告诉他们为何某件事做不到、为何耽搁、为何出现问题之前，先停下来，听一听你心里的声音。在你去告诉他们坏消息之前，是否还有其他你可以再试一试的办法？有时，你其实知道他们会说什么，所以还是不要给他们添麻烦。&lt;/p&gt;
&lt;p&gt;（这一点深有感触，在实习的这一段时间里面，经常因为一些小事去麻烦 leader，比如说环境跑步起来，某个莫名其妙的报错等，这虽然有文档不全的原因在，不过自己也没想着去补全文档这种解决办法。）&lt;/p&gt;
&lt;h3 id=&#34;软件的熵&#34;&gt;软件的熵&lt;/h3&gt;
&lt;p&gt;软件中的无序增长时，程序员们称之为「软件腐烂」（software rot）。&lt;/p&gt;
&lt;p&gt;「破窗理论」：以一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里占领、定居或者纵火。又或想像一条人行道有些许纸屑，如果无人清理，不久后就会有更多垃圾，最终人们会视为理所当然地将垃圾顺手丢弃在地上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 4
Don&amp;rsquo;t Live with Broken Windows
不要容忍破窗户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要留着「破窗户」（低劣的设计、错误决策、或是糟糕的代码）不修，发现一个修一个。&lt;/p&gt;
&lt;p&gt;如果没有足够的时间进行适当的修理，可以把出现问题的代码放到注释中，或者是用虚拟的数据来代替。&lt;strong&gt;采取某种行动防止进一步破坏，并说明情势处在你的控制之下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你发现自己在有好些破窗户的项目里工作，会很容易产生这样的想法：「这些代码的其余部分也是垃圾，我只要照着做就行了。」&lt;/p&gt;
&lt;h3 id=&#34;石头汤与煮青蛙&#34;&gt;石头汤与煮青蛙&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 5
Be a Catalyst for Change
做变化的催化剂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（有的时候想要做出一个新功能，可以先开发一个简单的版本，然后诱导别人往其中添加新功能。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 6
Remember the Big Picture
记住大图景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你设法催生变化时，你能否确定你是在做石头汤还是青蛙汤？决策是主观的还是客观的？&lt;/p&gt;
&lt;h3 id=&#34;足够好的软件&#34;&gt;足够好的软件&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 7
Make Quality a Requirements Issue
使质量称为需求问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要因为过度修饰和过于精于求精而破坏完好的程序。继续前进，让你的代码凭借自己的质量站立一会儿，它也许不完美，但不用担心：它不可能完美。&lt;/p&gt;
&lt;h3 id=&#34;你的知识资产&#34;&gt;你的知识资产&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;知识上的投资总能得到最好的回报。—— 本杰明·富兰克林&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;管理知识资产与管理金融资产非常相似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;严肃的投资者定期投资&lt;/li&gt;
&lt;li&gt;多元化是长期成功的关键：你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特定技术的各种特性，但不要就此止步。&lt;/li&gt;
&lt;li&gt;聪明的投资者在保守的投资和高风险、高回报的投资之间平衡他们的资产&lt;/li&gt;
&lt;li&gt;投资者设法低买高卖，以获取最大回报：在新兴的技术流行之前学习它可能就和找到被低估的股票一样困难，但所得到的就和那样的股票带来的收益一样。&lt;/li&gt;
&lt;li&gt;应周期性地重新评估和平衡资产&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 8
Invest Regularly in YOur Knowledge Portfolio
定期为你的知识资产投资&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每年至少学习一种新语言&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每季度阅读一本技术书籍&lt;/strong&gt;。一旦你养成习惯，就一个月读一本书。在你掌握了你正在使用的技术之后，扩宽范围，阅读一些与你的项目无关的书籍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;也要阅读非技术书籍&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上课&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参加本地用户组织&lt;/strong&gt;。不要只是去听讲，而要主动参与。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;试验不同的环境&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跟上潮流&lt;/strong&gt;。订阅商务杂志和其他期刊。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上网&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;持续投入非常重要，一旦你熟悉了某种新语言或技术，继续前进，学习另外一种。设法把你学到的东西应用到你当前的项目当中，即使你的项目没有使用该技术，你或许也能借鉴一些想法。&lt;/p&gt;
&lt;p&gt;所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先规划。让自己在空闲的片刻时间里总有东西可读。&lt;/p&gt;
&lt;p&gt;最后一个药店是，批判地思考你读到的和听到的。你需要确保你的资产中的知识是准确的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 9
Critically Analyze What You Read and Hear
批判地分析你读到的和听到的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;交流&#34;&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Tip 10
It&amp;rsquo;s Both What You Say and the Way You Say It
你说什么和你怎么说同样重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除非你生活在真空中，你猜不需要交流，交流越有效，你就越有影响力。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;大概花了两个多小时的时间把第一章的内容看了一遍，顺便摘录了一些内容。这一章其实更多的是讲「道」层面上的内容，与技术内容关联不大，但又是至关重要的，做好了上面几点可以从「码农」蜕变成「程序员」，能有自己的思考，能够与他人交流，能够对自己进行投资，而不是一味地按照要求写代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2017 Week 19 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2017-week-19-review/</link>
      <pubDate>Sun, 07 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2017-week-19-review/</guid>
      <description>&lt;p&gt;之前有在博客上写 Weekly Review 的习惯，后来因为被朋友说博客真水然后都撤下来了，有些文章确实是类似于「流水账」的记事，但也有一些是围绕这周做的东西来讨论的。总的来说，写 Weekly Review 对自己帮助还是很大的，可以在一周中 Focus 一个特定的主题，而不是想到什么做什么，所以这个系列以后还会继续写下去，只是写的内容更加具体一天，可以围绕着这周的 Project，或者这周听的音乐，或者读的书之类的。以前的文章看情况要不要放上来。&lt;/p&gt;
&lt;p&gt;这周算是正式把我的任务管理系统从 org-mode 转移到 Todoist 上来了。在不考虑时间成本和易用性上来说，org-mode 依然是目前我认为最完备的任务和时间管理系统，我用它来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任务管理：类似于 OmniFocus 的多层级任务管理，支持标签和优先级，可以自定义过滤视图&lt;/li&gt;
&lt;li&gt;时间记录：按照项目的方式来记录时间，基本是在做哪件事之前把计时器打开，一个番茄时间后自动关闭，可以自定义生成各种时间报表&lt;/li&gt;
&lt;li&gt;番茄工作法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://omaacpco9.bkt.clouddn.com/2017-05-07-092455.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;自定义生成的时间记录表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://omaacpco9.bkt.clouddn.com/2017-05-07-092544.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然 org-mode 的优点众多，但是始终是一个基于 Emacs 的 major mode，所以诸多限制在所难免：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有一个简单易用的移动端&lt;/li&gt;
&lt;li&gt;没办法做到全局 capture，虽然借助 Alfred 的 Workflow 和 Elisp 脚本能够实现这一功能，但是使用起来体验并不是很好&lt;/li&gt;
&lt;li&gt;编辑功能过重，很显然，做任务管理不需要多么高效的编辑操作，类似于 OmniFocus 使用鼠标 + 快捷键才是更高效的方法，在 Emacs 里经常编辑速度过快把整个文件搞乱了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不用 OmniFocus 的原因是本来就是从 OmniFocus 转到 org-mode 上来的，OmniFocus 有一个很致命的缺点就是不支持多标签，并且 Perspective 提供的设置选项也很有限，根不能不能满足一些复杂的过滤要求。除此之外，OmniFocus 应该是最优秀的任务管理软件了。&lt;/p&gt;
&lt;p&gt;Todoist 初次使用的时候感觉很难用，尤其是鼠标点击就进入编辑模式，这个设计真的不知道怎么想的，并且各平台的客户端一点也不 Native，基本就是 Web 版套了一个壳。macOS 客户端经常有一些莫名的 bug，反正软件的使用体验上来说和 OmniFocus 简直不能比。&lt;/p&gt;
&lt;p&gt;经过一段时间的调教，现在基本还能满足日常使用了。我认为一个可靠的任务管理系统需要满足两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能够随时把想法和任务记录进去&lt;/li&gt;
&lt;li&gt;能够按照特定的要求过滤出任务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他的一些东西其实都是为了服务这两点的，比如说标签系统，其实就是在过滤任务的时候多加了一个维度。Todoist 的过滤系统比 OmniFocus 好很多，但是和 org-mode 这种可以完全自定义的过滤系统相比还是差点，不过也完全够用。&lt;/p&gt;
&lt;p&gt;具体要写 Todoist 怎么用可能一篇文章也写不完（或许以后会写），另外 Todoist 还刚使用，有些东西还需要熟悉一下，下一篇文章会介绍一下目前我在用的一些过滤器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>这周在读什么 Issue#1</title>
      <link>http://blog.jiayuanzhang.com/post/weekly-reading-report-issue-01/</link>
      <pubDate>Fri, 24 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/weekly-reading-report-issue-01/</guid>
      <description>&lt;p&gt;为什么要写这个？最主要的原因还是激励自己多多阅读，读好书和好文章，然后写 review。&lt;/p&gt;
&lt;p&gt;读些什么？平常的阅读比较杂，除了书籍之外，还会读很多的博客文章，所以会写这周的 book review，主要是针对这周读完的书，读了一半放弃不打算再读的书也会写，没有读完的书不写；文章就简单写一些笔记性的 review。&lt;/p&gt;
&lt;p&gt;*注：标注了 &lt;code&gt;[TECH]&lt;/code&gt; 是和我专业相关的内容，可以跳过。&lt;/p&gt;
&lt;h2 id=&#34;books&#34;&gt;Books&lt;/h2&gt;
&lt;h3 id=&#34;清华园日记httpsbookdoubancomsubject4251102季羡林外语教学与研究出版社二零零九&#34;&gt;&lt;a href=&#34;https://book.douban.com/subject/4251102/&#34;&gt;《清华园日记》&lt;/a&gt;，季羡林，外语教学与研究出版社，二零零九。&lt;/h3&gt;
&lt;p&gt;这本书断断续续得读了有一个月的时间，因为是日记体的形式，所以什么时候都可以拿出来读一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日记是写给自己看的，什么样的思想，什么样在人前难以说出口的话，都写了进去。万没想到今天会把日记公开。这些话是不是要删掉呢？我考虑了一下，决定不删。一仍其旧，一句话也没有删。==我七十年前不是圣人，将来也不会成为圣人。我不想到孔庙里去陪着吃冷猪肉。我把自己活脱脱地暴露于光天化日之下。==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这本日记是季羡林在清华园求学时所记，从大三一直写到大四。百年之前的大学生活和现在相比，并无什么太大的不同。季老也有过迷茫，对前途的忧虑，但是更多的是在勤勉地读书、写文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;苏东坡词「谁到人生无再少，门前流水尚能西」。难道这就是「再少」吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读用时：7 小时 26 分，&lt;a href=&#34;https://www.evernote.com/l/AYC42MIUq-5BXIHRNGdRcL1OxXt3DPzLT5k&#34;&gt;摘录&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;articles&#34;&gt;Articles&lt;/h2&gt;
&lt;h3 id=&#34;1-how-i-got-a-second-degree-and-earned-5-developer-certifications-in-just-one-year-while-working-and-raising-two-kidshttpsmediumfreecodecampcomhow-i-got-a-second-degree-and-earned-5-developer-certifications-in-just-one-year-while-working-and-2b902ee291abgblxpzdk0&#34;&gt;1. &lt;a href=&#34;https://medium.freecodecamp.com/how-i-got-a-second-degree-and-earned-5-developer-certifications-in-just-one-year-while-working-and-2b902ee291ab#.gblxpzdk0&#34;&gt;How I got a second degree and earned 5 developer certifications in just one year, while working and raising two kids&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;全职教师、两个孩子、五张开发者证书、一个第二学位。如何在一年内实现这么多事？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ambitious goals are important.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，你还不得不放弃一些东西。比如，剧是不能追了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It was important for me to give things up in order to accomplish my goals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学会使用 8/2 法则，逃出自己的 comfort zone。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Really, when learning anything, you should ask yourself if it is part of the 20% of learning content that will give you 80% of value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这和很久前看的&lt;a href=&#34;https://www.douban.com/group/topic/34856495/&#34;&gt;一篇文章&lt;/a&gt;很像。&lt;/p&gt;
&lt;h3 id=&#34;2-unconventional-way-of-learning-a-new-programming-languagehttpshackernooncomunconventional-way-of-learning-a-new-programming-language-e4d1f600342c6o98rs4xs&#34;&gt;2. &lt;a href=&#34;https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c#.6o98rs4xs&#34;&gt;Unconventional way of learning a new programming language&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Open source projects oriented programming.&lt;/p&gt;
&lt;p&gt;如何学习一门新的语言，参加关于那个语言的开源项目。开源项目没有想象的那么难。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I had a look at the issues and found a lot of “beginner” issues. I immediately started working on them and submitted a couple of pull requests. Fast forward to today, I am one of the main contributors for a couple of their open projects and also one of the 20 Open Source Community Leaders for DuckDuckGo.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-a-vision-of-coding-without-opening-your-eyeshttpsmediumfreecodecampcomlooking-back-to-what-started-it-all-731ef5424aecscacfw9pe&#34;&gt;3. &lt;a href=&#34;https://medium.freecodecamp.com/looking-back-to-what-started-it-all-731ef5424aec#.scacfw9pe&#34;&gt;A Vision of Coding, Without Opening your Eyes&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;I’m a coder. I’m also blind. Blind as a bat, you might say. And I was born this way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章写自一个 blind coder，解释了三个（在我看来）有点 offensive 的问题：1）如何阅读；2）如何 coding；3）会做梦吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I’ll try and sketch out an image for those of you who are curious about accessibility, and how blind people use computers to code, and to do the work of the 21st century.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>叛逃 Spotify</title>
      <link>http://blog.jiayuanzhang.com/post/go-to-spotify/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/go-to-spotify/</guid>
      <description>&lt;p&gt;不久前我还&lt;a href=&#34;mweblib://14879083243319&#34;&gt;写文&lt;/a&gt;称赞过 Apple Music，现在光速打脸，叛逃 Spotify。&lt;/p&gt;
&lt;p&gt;主要原因有几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Apple Music 的「My Favorites Mix」一周才更新一次，不够听。&lt;/li&gt;
&lt;li&gt;推荐的歌单都是听过的，专辑也是，重复推荐，并且由于是人工编辑的歌单，难免有不合自己口味的。&lt;/li&gt;
&lt;li&gt;个性化推荐的内容太单一，经常出现歌慌，需要自己去找歌。&lt;/li&gt;
&lt;li&gt;同步问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Spotify 的 Premium 之前就买了，但是一直没有用。这几天用了一下，说一下使用体验：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推荐算法很厉害，机器推荐的歌更个人一些，不会有人工歌单的主观因素在里面。&lt;/li&gt;
&lt;li&gt;「Based on the songs in this playlist」这个功能很有用，可以用来扩充歌单。&lt;/li&gt;
&lt;li&gt;Radio 功能比 Apple Music 强大。&lt;/li&gt;
&lt;li&gt;多设备同步，这个功能太方便了，我只需要在电脑上断开蓝牙连接，然后就可以直接在手机上听了（配合蓝牙耳机）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一些不满意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能收藏专辑，有的专辑里面并不是每首歌都喜欢听，save 专辑会把整张专辑里面的歌添加到资料库里，这不得不让我又新建一个 Loved 的歌单，专门用来放喜欢的歌，这样和 Apple Music 就是差不多的操作逻辑。&lt;/li&gt;
&lt;li&gt;没有提供加心功能，「+」仅仅是把歌曲添加到资料库，所以还得手动建一个歌单然后再添加，比较麻烦（可能我使用的方法不正确？）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过毕竟才用了几天，还没有深度体验过。Mac 上推荐配合 Alfred 的 Workflow 来使用，可以避免到 Spotify 应用里面进行操作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 音乐总结</title>
      <link>http://blog.jiayuanzhang.com/post/digital-life-in-2016-music-part/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/digital-life-in-2016-music-part/</guid>
      <description>&lt;p&gt;最近知乎上的一个朋友和我私信聊了一些关于效率工具以及 Workflow（此处指的是「工作流」）方面的一些问题。聊的内容比较碎片，所以还是打算写一篇文章来具体讨论一下。考虑到会涉及很多不同的主题，所以还是一个主题写一篇，这样也可以控制文章的长度。暂定按照以下主题来写：音乐篇、阅读篇、写作篇和时间管理篇。&lt;/p&gt;
&lt;p&gt;音乐对我来说，应该算是日常生活中比较重要的一项内容了，除了一些需要特别 Focus 的工作（例如看数学）不会听音乐外，其他时间都会戴着耳机。2016 年彻底地转入到 Apple Music 中来，期间试用过一段时间的 Spotify，网易云音乐几乎没怎么打开过。这篇打算讨论一下所有（尽量）听音乐方面相关的问题。&lt;/p&gt;
&lt;h2 id=&#34;用什么设备听&#34;&gt;用什么设备听&lt;/h2&gt;
&lt;p&gt;我的大多数电子设备都是 Apple 系的，包括 rMBP、iPhone、iPad，所以听音乐也都是围绕着这些设备来。严格的来说，并不能算一个「音乐发烧友」，我对设备的要求并不是太高，甚至对音源也没有太高的要求，Apple Music 的音质已经完全能够满足了，无损音源内容几乎不听，其一是没有购买 CD 的习惯，所以没有合法的途径获取无损资源；其二是一直都是拿 iTunes 听音乐，无损还需要转格式编辑信息，过于麻烦。&lt;/p&gt;
&lt;p&gt;主力播放器是 Macbook，几乎 80% 的时间都是在 Macbook 上听（写代码、阅读、写作等）。另外便是新购入的 iPhone 7，主要是外出坐车、跑步或是睡前听一下（之前是用 5s）。iPad 很少用来听音乐。&lt;/p&gt;
&lt;p&gt;使用的耳机是 &lt;a href=&#34;https://www.amazon.com/Westone-Pro30-Performance-Universal-Earphones/dp/B00FKY3IFA&#34;&gt;Westone UM Pro 30&lt;/a&gt;，使用体验很好，对比 Apple 自带的耳机有惊艳的提升，而且长时间佩戴也没有不适感（几乎没有戴着耳机的感觉）。想要具体了解得可以去搜相关的评测来看。&lt;/p&gt;
&lt;p&gt;耳机是在 7 发售之前买的，传闻 7 要去掉耳机接口的时候其实我是不信的，结果还真去掉了。这导致了插 7 上需要多接一根转接线，略显累赘，所以现在在 iPhone 上听歌就直接拿自带的耳机了。&lt;/p&gt;
&lt;h2 id=&#34;为什么不用网易云音乐&#34;&gt;为什么不用网易云音乐&lt;/h2&gt;
&lt;p&gt;我知道，我也很讨厌类似「我为什么不 xxx」的说法，「不用就不用，还要批判一番」，但是还是要写一写。&lt;/p&gt;
&lt;p&gt;其实我很早就开始使用网易云音乐了，那个时候一些热门的歌曲下评论还只有几百条，不像现在，动辄上千上万条评论。也安利过身边好多人用，曾经是长期的会员用户，所以还是有一些资格来谈论一下这个音乐服务的。&lt;/p&gt;
&lt;p&gt;很明显，网易云音乐最初就是模仿 Spotify 的，包括界面设计，几乎一模一样。除了借鉴 Spotify 之外，网易云音乐还加入了很多自己的「创新」，而正是这些所谓的创新，让我开始慢慢得不想用它。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;评论：其实我是赞成加入评论功能的，但是网易云的评论已经偏离了音乐评论的范围，变成了编故事、讲段子、骗赞评论的聚集地。认真评论音乐的几乎没有，我不知道如果想看段子为什么不上微博？这一点实际上让一个音乐软件变成了社交软件，不好意思，我只想好好听音乐。&lt;/li&gt;
&lt;li&gt;歌曲：网易云上很多歌曲的信息混乱不堪，包括专辑信息、专辑封面、年份等，很多单曲甚至没有专辑信息，直接被编排到「热门歌曲串烧」这样的专辑里，我有强迫症，看着挺 low 的。并且很多的歌来源都不明确，大多数都是网友上传，甚至很多 Bilibili 鬼畜区的音乐也被上传上来，哪天听推荐就冷不丁得听到。&lt;/li&gt;
&lt;li&gt;专辑封面不完整：网易云的一大特色就是模仿唱片机旋转，想看一下专辑封面是什么样还要点到专辑列表里面去看。在我看来，在电子设备上「拟物」是一种很没有效率的事，就像之前电子书的模拟翻页一样，「翻页」这个动作本来就是一个三维的过程，在手机上再怎么模拟也达不到现实中的效果，「瀑布式」的阅读方式才是正确的选择。所以我推崇「反拟物化」、「扁平化」和「极简化」的设计风格。&lt;/li&gt;
&lt;li&gt;歌单：几乎所有的歌单都是由用户创建，和 Apple Music 与 Spotify 专门的音乐编辑创建的歌单相比，高下立判。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在我看来，听音乐是一件很纯粹的事，而网易云给这件纯粹的事加了太多的东西。&lt;/p&gt;
&lt;h2 id=&#34;apple-music-之痛&#34;&gt;Apple Music 之痛&lt;/h2&gt;
&lt;p&gt;Apple Music 自从 2015 年 6 月发布以来，到现在已经有接近两年的时间了，从发布当天付费到现在，中间用了一段时间的国区，由于曲库原因，现在还换回了港区，每月 48 港币，虽然比国区每月 10 ￥（学生 5 ￥）贵了不少，不过依然很值，想想一张专辑的钱就可以听一个月。&lt;/p&gt;
&lt;p&gt;虽说经过这么长时间的发展，Apple Music 依然可以说做得很烂，我在一年前的一篇文章（&lt;a href=&#34;http://forrestchang.github.io/14824082548997.html&#34;&gt;《Apple Music，古典音乐，阅读》&lt;/a&gt;）中已经吐槽过了，除了网络问题有了明显改善之外，其他的并没有太大的改进。以至于现在每年的 WWDC 最期待的不是发布什么新产品，而是 Apple Music 有什么大的改进，加了些什么功能。&lt;/p&gt;
&lt;p&gt;我在 V2EX 上也发过&lt;a href=&#34;https://www.v2ex.com/t/336425&#34;&gt;一篇帖子&lt;/a&gt;吐槽过 Apple Music。&lt;/p&gt;
&lt;p&gt;这些问题肯定和 iTunes 的历史因素有关，iTunes 本身就是作为一个音乐商店，在没有 Apple Music 之前，听音乐的流程就是从商店中购买数字音乐（或者从 CD 中导入），然后添加到 Library 中，之后对这些音乐做什么事都与商店中的音乐无关了。而到了 Apple Music，它依然延续着之前的流程，当把音乐添加到 Library 中后，你对音乐做出的评分、加心实际上都和云端的数据无关了，所有数据都存放在本地的 &lt;code&gt;iTunes Library.xml&lt;/code&gt; 文件中，所以这才会导致一部分音乐明明加过心了，到了手机上一看却是没有加过心的，并且由于存放在本地的原因，云端的数据也不会更新，这也会影响到每天推荐给你的音乐。&lt;/p&gt;
&lt;p&gt;Medium 上的一个设计师专门帮 Apple Music 重新设计了一下：&lt;a href=&#34;https://medium.com/product-design-ux-ui/apple-music-redesign-part-1-526c4c4c4777#.lopgpvt41&#34;&gt;Apple Music Redesign&lt;/a&gt;，在我看来，比原版的 Apple Music 好太多。&lt;/p&gt;
&lt;p&gt;很难想象，把 iPhone 做得只有 7 mm 厚的科技公司，竟然连 iTunes 中遗留的种种问题也解决不好。&lt;/p&gt;
&lt;h2 id=&#34;听什么&#34;&gt;听什么&lt;/h2&gt;
&lt;p&gt;我并不打算讲太多「听什么」的内容，音乐本来就是一个很个人的事情，但是，音乐真的没有好坏吗？实际上，Apple Music 与网易云一个很大的不同点就是，前者有意得引导你听，而后者是根据你听歌的记录推荐相似的（尽管并不准）歌曲。&lt;/p&gt;
&lt;p&gt;相比较网易云的每日推荐，Apple Music 只有一个最爱精选（My Favorites Mix），里面有很多你之前就已经喜欢的歌，每周更新一次。而更多的每天推荐是类似「朴树：音乐灵感」、「古典音乐：混音和改编歌曲」这样的人工手动编辑的歌单，而一般这样的歌单都会附带编辑的一些评语，让你能够大体得了解这张歌单内容，比如今天推荐给我的「古典音乐：混音和改编歌曲」：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;古典樂的經典旋律恆久不變，但同樣的旋律放在此歌單中卻可讓你帶來驚喜！耳熟能詳的柴可夫斯基、韋瓦第等大師作品，換上電子工程師 Max Richer、CFCF 及 DJ Spooky 的混音和改編，令幾百年前的作品添上時代感，即使充滿實驗性和玩味，趣味滿分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相比没有目的、仅仅根据自己的喜好乱听，这种引导的方式会慢慢影响你的音乐品味。&lt;/p&gt;
&lt;p&gt;另一方面，它还会每天给你推荐不一样的专辑，比如我喜欢听 Imagine Dragons，它今天就给我基于此推荐了《An Awesome Wave》、《Skying》、《Megalithic Symphony》等专辑。&lt;/p&gt;
&lt;p&gt;快餐音乐时代，很多歌曲单独从专辑中拿出来听也不会有什么问题，但是按照专辑来听，依然是严肃欣赏音乐的唯一方式。&lt;/p&gt;
&lt;h2 id=&#34;怎么听&#34;&gt;怎么听&lt;/h2&gt;
&lt;p&gt;用过两种方法。&lt;/p&gt;
&lt;p&gt;1）类似于 Spotify，添加到 Library 的歌曲就算是你想以后继续听的，「加心」的行为只是用来作为推荐的参考。这种方式就不需要再本地再建一个智能播放列表专门用来过滤加心的歌曲了，因为 Library 中的所有的歌都是你想听的。&lt;/p&gt;
&lt;p&gt;2）添加到 Library 中只是作为一个「稍后听」的过程，一般这种情况是按照专辑来添加到 Library 中，然后把这张专辑从头到尾（或者以你喜欢的方式）听一遍，把喜欢的歌加心，并给歌曲评分（可选），然后建立智能播放列表过滤出加心的歌，例如，我除了有一个 「Favorites」 歌单（自动更新 Library 中加心的歌曲），还有一个「古典精选」歌单，其中内容是类型为「Classical」并且已经加心了的歌曲。智能播放列表可以使用很复杂的过滤器。这种听歌方式也是现在我用的，这其实和之前在 iTunes Store 上购买音乐再听并没有什么区别，除了改成了订阅的方式并且附带了推荐功能。&lt;/p&gt;
&lt;p&gt;不过听音乐这种事各有各的方法，这里也仅仅是提供参考。&lt;/p&gt;
&lt;h2 id=&#34;一些辅助工具&#34;&gt;一些辅助工具&lt;/h2&gt;
&lt;p&gt;其实写到这里基本已经写完了。如果你不是一个强迫症、数据控、偏执狂或是一个完美主义者，最后这部分并没有什么太多帮助。&lt;/p&gt;
&lt;p&gt;我使用 &lt;a href=&#34;https://www.last.fm&#34;&gt;last.fm&lt;/a&gt; 来记录自己听了什么，Mac 上使用的是官方的 Last.fm Scrobbler 这个软件，不过它只能记录离线的歌曲，对于 Radio 就无能为力了，所以我辅助 &lt;a href=&#34;http://bowtieapp.com/&#34;&gt;Bowtie&lt;/a&gt; 这个小软件来记录，为了防止重复记录，需要把 Last.fm Scrobbler 中的 Enable Scrobbling 选项关闭。&lt;/p&gt;
&lt;p&gt;记录数据可以让你更好得知道平常的音乐喜好，以及某张专辑、某首歌、某个艺人听了多少次等等。并且 last.fm 提供通用的 API 来方便导出这些数据，说不定以后有什么用。&lt;/p&gt;
&lt;p&gt;过去一周我的听歌记录可以在 &lt;a href=&#34;https://www.last.fm/user/Tisoga/listening-report/week&#34;&gt;这里&lt;/a&gt; 看到。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>换了一个新地方写东西</title>
      <link>http://blog.jiayuanzhang.com/post/new-blog/</link>
      <pubDate>Sat, 04 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/new-blog/</guid>
      <description>&lt;p&gt;现在这个博客只写技术相关的内容，其他的随笔都写在&lt;a href=&#34;https://medium.com/@Tisoga&#34;&gt;新博客&lt;/a&gt;里，Medium 是被大陆屏蔽的，所以请自备梯子。另外一些比较私人的笔记——例如「Week Review」系列就不发表在互联网上了。&lt;/p&gt;
&lt;p&gt;至于原因，单纯得觉得 Medium 上的衬线字体很好看。~~如果需要魔改这个博客的话，还是挺麻烦的，自己目前的前端知识还处于未入门的水平，所以就不折腾了。~~结果我还是魔改了，现在风格比较简洁了，照着 &lt;a href=&#34;https://github.com/lepture/yue.css&#34;&gt;yue.css&lt;/a&gt; 改的。&lt;/p&gt;
&lt;p&gt;既然重新换了一个主题，就不换地方写了……&lt;/p&gt;
&lt;p&gt;主题的代码放在 &lt;a href=&#34;https://github.com/forrestchang/Cuckoo&#34;&gt;GitHub&lt;/a&gt; 上，完全是新手的作品，所以还是不要 star 了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2017 Week 01 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2017-week-01-review/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2017-week-01-review/</guid>
      <description>&lt;p&gt;今天是元旦，因为在 Calendar 中把今天归到 2017 年的第一周里了，所以就按照上面所写的把这周当做第一周吧。&lt;/p&gt;
&lt;p&gt;这周结束了在中软的课程设计实训，以前总嫌弃小渔村破，现在回来才知道还是小渔村好啊。课程设计实训的内容是用 Java 写一个点餐系统，一个小组只需要做一份就可以了，不过几乎所有人都不知道 Git 是个什么东西，小组合作还是用的 U 盘拷贝代码，所以代码质量可想而知了，本组的其他人都比较厉害，索性我就抱大腿划水了，什么也没有参与，代码也没有写一行。&lt;/p&gt;
&lt;p&gt;不过虽说没有写课程设计的项目，但还是有写代码的。这周把两个月前参加 HACKxFDU 的项目拿出来用 Python 3 重写了一遍。项目的地址：&lt;a href=&#34;https://github.com/forrestchang/Neutron&#34;&gt;Neutron&lt;/a&gt;，当初我们考虑做 Neutron 的时候是想把它做成一个通用的智能家居语音终端的，类似于 Amazon 的 Echo，只要提供第三方的 API，就能轻松集成到 Neutron 来，但是实际上碍于 Hackathon 的时间限制，只是完成了一个简单的 Demo，完全没有拓展性。本来这个项目参加完 Hackathon 之后就没有管了，不过最近看到 Facebook CEO 扎克伯格写了一个 Jarvis，觉得和之前做的东西很像（当然还是差远了，基本我们做的东西就是用别人的 API），所以又掏出来拿 Python 3.5 重写了一遍。现在在 &lt;a href=&#34;https://github.com/forrestchang/neutron/tree/develop&#34;&gt;develop&lt;/a&gt; 分支基本上把框架搭建好了，最底层是和 API 交互的 layer 层，这一层需要为每个 API 写特定的代码，其上是抽象的 handler 层，提供通用的接口，抽象 layer 层的操作：例如语音控制模块、AI 模块等，这一层上还可能包裹一层特定的 wrapper，例如对特定的 message 做语义分析。通过配置文件来选择使用哪个 layer 以及配置 layer 的内容（key 等内容），开始的时候打算用 json 来做配置文件的，后来看了一下还有 yaml 这种更加简洁的配置文件，所以打算换成 yaml 的。目前这个项目还有很多内容要写的，比如特定的 layer，都需要更具不同的 API 写特定的代码，这一点上我参考的 &lt;a href=&#34;https://github.com/syl20bnr/spacemacs&#34;&gt;Spacemacs&lt;/a&gt; 的方法。&lt;/p&gt;
&lt;p&gt;这周在中软那边的宿舍里面把08版的《射雕英雄传》看完了，虽然槽点挺多的（特效、台词、演技），但是还是看得很欢乐，林依晨的黄蓉甚是喜欢。记得以前应该是看过朱茵版的黄蓉的，不过时间太久远了，已经记不太清了。小说倒没有读完，还是看剧比较快啊。看完后好长一段时间里面都觉得特别空虚，总感觉少了些什么。这种孤独感几乎在每次看完某部小说和电视剧后都会有（电影倒没有这种感觉，可能时间太短了），总觉得还沉浸在别人的故事里，可惜别人的故事已经结束，不得不回到现实中来。想起席慕蓉的一句话『在别人的故事里，留着自己的泪』 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;就借着这篇博客顺便说说 17 年的计划吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习一门新语言：14年学了 C、Scheme，15年学了 Java、Python，16年学了 Swift，再加上各种用过但是不熟的语言，也有好多个了。现在主力开发语言是 Python，17年打算学习 一下 JavaScript，这门 GitHub 上最火的语言，不会都不好意思说自己是程序员。也不用学到多么深，只求达到入门水平。&lt;/li&gt;
&lt;li&gt;Python 水平达到 professional，用了接近两年的 Python，但是水平也没有长进多少，今年打算深入一下 Python，多写一些项目。&lt;/li&gt;
&lt;li&gt;去周边国家玩一次，其实挺想去尼泊尔的，不知道今年有没有时间。不过即使不出国，也要多出去走走，一个人的旅行。&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;席慕蓉的《戏子》，用在这里并不完全准确。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 52 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-52-review/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-52-review/</guid>
      <description>&lt;p&gt;2016 年最后一周（实际上还有6天，不过那一周就算到 2017 年第一周吧）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编程&lt;/strong&gt;：这周在看《Python 网络数据采集》，以前虽然也用过爬虫，但是毕竟没有系统地学过，所以还是找了一本书来看。但是说实话，这本书写得并不是很好，不知道是写书时间的原因还是什么，挺多语法错误的，而且代码的风格很差（完全不符合 PEP8 标准）。内容也比较浅，基本上都是之前已经知道了的东西，所以收获也不是很多，（下一篇的博客可以来写一写怎么写一个高效的爬虫）。面试的事情作废了，1）看了一下他们做的产品，感觉不是自己想要做的东西；2）开出的薪资太低，up to 2k（其实主要是薪资太低了，每天要往返金石滩和大连市，太累了）。所以还是好好学习准备明年的暑期实习吧。另外 GSoC 也应该放上日程了，即使有申请不上的可能，还是要试一试的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阅读&lt;/strong&gt;：开始读金庸的《射雕英雄传》，以前上学的时候一直被家里教导不要沉迷武侠小说，所以一直没有读过金庸和古龙（然而那些时间都用来看网文玄幻了……）。最近读来还是觉得很有意思，作为实训的时候消遣很不错（主要没有网）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生活&lt;/strong&gt;：这周五就可以离开这鬼地方了，见识过外包公司的情况后决定以后肯定是不会进这种公司的。在公司里实训也一直没有写代码，本来打算用 Python 实现一下实训的题目的，但是老师说不允许，这也没什么办法，索性就划水吧。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;博客&lt;/strong&gt;：可以看到，我博客又换样子了。用 Emacs 来写博客还是太麻烦了一些，而且 render 的速度实在是太感人，本地的 org 文件多了之后好几次 render 的时候卡住。现在这个博客是 Mweb 自带的 generator 生成的，就是主题不怎么好看，其他的都很方便。奈何自己的前端知识太渣，改了半天也没有改成自己想要的样子，所以还是凑合着先用吧。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>推荐系统笔记</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-recommandation-system/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-recommandation-system/</guid>
      <description>&lt;p&gt;开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。&lt;/p&gt;
&lt;p&gt;这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。&lt;/p&gt;
&lt;h2 id=&#34;基于用户的协同过滤&#34;&gt;基于用户的协同过滤&lt;/h2&gt;
&lt;h3 id=&#34;协同过滤collaborative-filtering&#34;&gt;协同过滤（Collaborative filtering）&lt;/h3&gt;
&lt;p&gt;一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。&lt;/p&gt;
&lt;h3 id=&#34;测试数据集&#34;&gt;测试数据集&lt;/h3&gt;
&lt;p&gt;为了演示一些算法，我们需要从&lt;a href=&#34;http://grouplens.org/datasets/movielens/&#34;&gt;这个网站&lt;/a&gt;上下载一份数据集。这里因为是作为演示使用，所以只需要下载&lt;a href=&#34;http://files.grouplens.org/datasets/movielens/ml-latest-small.zip&#34;&gt;ml-latest-small.zip&lt;/a&gt;这一份简单的数据集就可以了。&lt;/p&gt;
&lt;h3 id=&#34;相似度计算&#34;&gt;相似度计算&lt;/h3&gt;
&lt;p&gt;在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的&lt;strong&gt;相似度评价值&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;欧几里德距离评价euclidean-distance-score&#34;&gt;欧几里德距离评价（Euclidean Distance Score）&lt;/h4&gt;
&lt;p&gt;欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作$(p_1, p_2, p_3, p_4, &amp;hellip;)$和$(q_1, q_2, q_3, q_4, &amp;hellip;)$，则欧几里德距离的计算公式为：&lt;/p&gt;
&lt;p&gt;$$
\sqrt{((p_1-q_1)^2+(p_2-q_2)^2+&amp;hellip;+(p_n-q_n)^2)} = \sqrt{(\sum_{i=1}^n(p_i-q_i)^2)}
$$&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;recommendations.py&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;用代码表示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; math &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sqrt

&lt;span style=&#34;color:#75715e&#34;&gt;# 返回一个有关 person1 与 person2 的基于距离的相似度评价&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sim_distance&lt;/span&gt;(prefs, person1, person2):
	&lt;span style=&#34;color:#75715e&#34;&gt;# 得到 shared_items 的列表&lt;/span&gt;
	shared_items &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person1]:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person2]:
		shared_items[item] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
	
	&lt;span style=&#34;color:#75715e&#34;&gt;# 如果两者没有共同之处，则返回 0&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(shared_items) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
		
	&lt;span style=&#34;color:#75715e&#34;&gt;# 计算所有差值的平方和&lt;/span&gt;
	sum_of_squares &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([pow(prefs[person1][item]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;prefs[person2][item], &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person1] &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person2]])
	
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sqrt(sum_of_squares))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。&lt;/p&gt;
&lt;p&gt;好了，现在我们需要先将数据读取进来，在 &lt;code&gt;recommendations.py&lt;/code&gt; 中添加如下代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;loadMovieLens&lt;/span&gt;(path&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;):
    movies &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(path &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/movies.csv&amp;#39;&lt;/span&gt;):
        (id, title) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;,&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
        movies[id] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; title

    prefs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(path&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/ratings.csv&amp;#39;&lt;/span&gt;):
        (user, movieid, rating, ts) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;,&amp;#39;&lt;/span&gt;)
        prefs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(user, {})
        prefs[user][movies[movieid]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(rating)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; prefs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 ipython 交互环境中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; recommendations
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; prefs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loadMovieLens()
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 比较 10 号用户 和 20 号用户的相似度评价&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sim_distance(prefs, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;20&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#ae81ff&#34;&gt;0.23371479611805132&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;皮尔逊相关系数pearson-correlation-coefficient&#34;&gt;皮尔逊相关系数（Pearson Correlation Coefficient）&lt;/h4&gt;
&lt;p&gt;皮尔逊相关系数是一种度量两个变量间相关程度的方法，它是一个介于 1 和 -1 之间的值，其中，1 表示变量完全正相关，0 表示无关， -1 则表示完全负相关（一个变量的值越大，则另一个变量的值反而会越小）。&lt;/p&gt;
&lt;p&gt;计算公式：&lt;/p&gt;
&lt;p&gt;$$
r = \frac{\sum{XY}-\frac{\sum X \sum Y}{N}}{\sqrt{(\sum X^2 - \frac{(\sum X)^2}{N})(\sum Y^2 - \frac{(\sum Y)^2}{N})}}
$$&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;recommendations.py&lt;/code&gt; 中添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sim_pearson&lt;/span&gt;(prefs, person1, person2):
	  &lt;span style=&#34;color:#75715e&#34;&gt;# 得到双方都曾评价过的物品列表&lt;/span&gt;
    shared_items &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person1]:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person2]:
            shared_items[item] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
	  &lt;span style=&#34;color:#75715e&#34;&gt;# 得到物品列表元素的个数&lt;/span&gt;
    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(shared_items)

	  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果两者没有共同元素，则返回0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

	  &lt;span style=&#34;color:#75715e&#34;&gt;# 计算 person1 和 person2 的皮尔逊相关系数&lt;/span&gt;
    sumxy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([prefs[person1][item] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; prefs[person2][item]
                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; shared_items])
    sumx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([prefs[person1][item] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; shared_items])
    sumy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([prefs[person2][item] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; shared_items])
    sumx2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([prefs[person1][item] &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; shared_items])
    sumy2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum([prefs[person2][item] &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; shared_items])

    zahler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sumxy &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (sumx &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; sumy) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; n
    nenner &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sqrt((sumx2 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (sumx &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; n) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (sumy2 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (sumy &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; n))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nenner &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zahler &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; nenner

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 ipython 交互环境中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; reload(recommendations)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; prefs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loadMovieLens()
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sim_pearson(prefs, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;20&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#ae81ff&#34;&gt;0.4908806936738162&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到和上面使用欧几里德距离评价计算出来的相似度是不一样的。&lt;/p&gt;
&lt;h4 id=&#34;关于该使用哪一种相似性度量方法&#34;&gt;关于该使用哪一种相似性度量方法&lt;/h4&gt;
&lt;p&gt;除了这两种计算相似度的方法，实际上还有许多别的计算相似度的算法，例如&lt;strong&gt;Tanimoto 分值&lt;/strong&gt;。使用哪一种方法，完全取决于具体的应用。&lt;/p&gt;
&lt;p&gt;下面的代码中，将使用一个通用的相似性函数来计算相似度，只要它满足以下条件：拥有同样的函数签名，以一个浮点数作为返回值，其数值越大代表相似度越大。&lt;/p&gt;
&lt;h3 id=&#34;寻找相似的用户&#34;&gt;寻找相似的用户&lt;/h3&gt;
&lt;p&gt;既然我们已经有了对两个人进行比较的函数，下面我们就可以编写，根据指定人员对每个人进行打分，并找出最接近的匹配结果了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 从反映偏好的字典中返回最佳匹配者&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 返回结果的个数和相似度函数均为可选参数&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;topMatches&lt;/span&gt;(prefs, person, n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, similarity&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sim_pearson):
	scores &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [(similarity(prefs, person, other), other) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; other &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; other &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; person]
	
	&lt;span style=&#34;color:#75715e&#34;&gt;# 对列表进行排序，评价值最高者排在最前面&lt;/span&gt;
	scores&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;True)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; scores[:n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 ipython 交互环境中测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; reload(recommendations)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; prefs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loadMovieLens()
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 与 40 号用户相似的 10 个用户&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;topMatches(prefs, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;40&amp;#39;&lt;/span&gt;, n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
[(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;63&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;582&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;326&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;260&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;220&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;198&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;153&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;116&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;0.9999999999999947&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;474&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;0.9999999999999947&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;215&amp;#39;&lt;/span&gt;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;推荐物品&#34;&gt;推荐物品&lt;/h3&gt;
&lt;p&gt;有的时候我们可能不需要寻找相似的用户，例如在购物网站中，我们需要的是一份可能会想要购买的物品列表，一种方法是从相似的用户所购买的物品列表中选出没有购买的，但是这种方法不确定的因素太多，例如可能相似用户还未购买某些物品，而这些物品恰恰就是我们所需要的。&lt;/p&gt;
&lt;p&gt;为了解决上面的问题，我们需要通过一个经过加权的评价值来为影片打分，评论者的评分结果因此而形成了先后的排名。为此，我们需要取得所有其他评论者的评价结果，借此得到相似度之后，再乘以他们为每部影片所给的评价值。&lt;/p&gt;
&lt;p&gt;以以下数据集为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&#39;Lisa Rose&#39;: {&#39;Lady in the Water&#39;: 2.5,
               &#39;Snakes on a Plane&#39;: 3.5,
               &#39;Just My Luck&#39;: 3.0,
               &#39;Superman Returns&#39;: 3.5,
               &#39;You, Me and Dupree&#39;: 2.5,
               &#39;The Night Listener&#39;: 3.0},
 &#39;Gene Seymour&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 1.5,
                  &#39;Superman Returns&#39;: 5.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Michael Phillips&#39;: {&#39;Lady in the Water&#39;: 2.5,
                      &#39;Snakes on a Plane&#39;: 3.0,
                      &#39;Superman Returns&#39;: 3.5,
                      &#39;The Night Listener&#39;: 4.0},
 &#39;Claudia Puig&#39;: {&#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 3.0,
                  &#39;The Night Listener&#39;: 4.5,
                  &#39;Superman Returns&#39;: 4.0,
                  &#39;You, Me and Dupree&#39;: 2.5},
 &#39;Mick LaSalle&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 4.0,
                  &#39;Just My Luck&#39;: 2.0,
                  &#39;Superman Returns&#39;: 3.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 2.0},
 &#39;Jack Matthews&#39;: {&#39;Lady in the Water&#39;: 3.0,
                   &#39;Snakes on a Plane&#39;: 4.0,
                   &#39;The Night Listener&#39;: 3.0,
                   &#39;Superman Returns&#39;: 5.0,
                   &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Toby&#39;: {&#39;Snakes on a Plane&#39;: 4.5,
          &#39;You, Me and Dupree&#39;: 1.0,
          &#39;Superman Returns&#39;: 4.0}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设我们需要给 Toby 提供影片推荐，我们可以根据上面的算法得出一张表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;评论者&lt;/th&gt;
&lt;th&gt;相似度&lt;/th&gt;
&lt;th&gt;Night&lt;/th&gt;
&lt;th&gt;S.xNight&lt;/th&gt;
&lt;th&gt;Lady&lt;/th&gt;
&lt;th&gt;S.xLady&lt;/th&gt;
&lt;th&gt;Luck&lt;/th&gt;
&lt;th&gt;S.xLuck&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Rose&lt;/td&gt;
&lt;td&gt;0.99&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;2.97&lt;/td&gt;
&lt;td&gt;2.5&lt;/td&gt;
&lt;td&gt;2.48&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;2.97&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Seymour&lt;/td&gt;
&lt;td&gt;0.38&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;1.14&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;1.14&lt;/td&gt;
&lt;td&gt;1.5&lt;/td&gt;
&lt;td&gt;0.57&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Puig&lt;/td&gt;
&lt;td&gt;0.89&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;4.02&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;2.68&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LaSalle&lt;/td&gt;
&lt;td&gt;0.92&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;2.77&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;2.77&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Matthews&lt;/td&gt;
&lt;td&gt;0.66&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;1.99&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;1.99&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12.89&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8.38&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8.07&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sim.Sum&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3.84&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2.95&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3.18&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计/Sim.Sum&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3.35&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2.83&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2.53&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表中列出来每位评论者的相关度评价值，以及他们对三部影片的评分情况。以 S.x 打头的列给出了乘以评价值之后的相似度。如此一来，相比于与我们不相近的人，那些与我们相近的人将会对整体评价拥有更多的贡献。总计所有加权评价值的和。&lt;/p&gt;
&lt;p&gt;我们也可以选择利用总计值来计算排名，但是这其中有一个问题，一部受更多人评论的影片会对结果产生很大影响。为了修正这一问题，我们需要除以表总名为 Sim.Sum 的那一行，它代表了&lt;strong&gt;所有对这部电影有过评论的评论者的相似度之和&lt;/strong&gt;。对于影片《Lady in the Water》来说，Puig 并未做过评论，所以我们将这部影片的总计值除以所有其他人的相似度之和。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;recommendations.py&lt;/code&gt; 中添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 利用所有其他人评价值得加权平均，为某人提供建议&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getRecommendations&lt;/span&gt;(prefs, person, similarity&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sim_pearson):
	totals &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	simSums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; other &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs:
		&lt;span style=&#34;color:#75715e&#34;&gt;# 不要和自己做比较&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; other &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; person:
			&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
		sim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; similarity(prefs, person, other)
		
		&lt;span style=&#34;color:#75715e&#34;&gt;# 忽略评价值为零或者小于零的情况&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sim &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
			&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
			
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[other]:
			&lt;span style=&#34;color:#75715e&#34;&gt;# 只对自己还未看过的影片进行评价&lt;/span&gt;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person] &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; prefs[person][item] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
				&lt;span style=&#34;color:#75715e&#34;&gt;# 相似度*评价值&lt;/span&gt;
				totals&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(item, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
				totals[item] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; prefs[other][item] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; sim
				&lt;span style=&#34;color:#75715e&#34;&gt;# 相似度之和&lt;/span&gt;
				simSums&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(item, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
				simSums[item] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; sim
		
		&lt;span style=&#34;color:#75715e&#34;&gt;# 建立一个归一化的列表&lt;/span&gt;
		rankings &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [(total &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; simSums[item], item) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item, total &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; totals&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items()]
		
		&lt;span style=&#34;color:#75715e&#34;&gt;# 返回经过排序的列表&lt;/span&gt;
		rankings&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;True)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; rankings
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 ipython 中测试一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; relaod(recommendations)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; prefs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loadMovieLens()
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getRecommendations(prefs, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10&amp;#39;&lt;/span&gt;)[:&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;]
[(&lt;span style=&#34;color:#ae81ff&#34;&gt;5.000000000000001&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;The Slipper and the Rose: The Story of Cinderella (1976)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.000000000000001&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hands on a Hard Body (1996)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.000000000000001&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;For the Birds (2000)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.000000000000001&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Diva (1981)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Zorba the Greek (Alexis Zorbas) (1964)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Zerophilia (2005)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Zelary (2003)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Z Channel: A Magnificent Obsession (2004)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Yossi (Ha-Sippur Shel Yossi) (2012)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;World of Tomorrow (2015)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Woody Allen: A Documentary (2012)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Woman on Top (2000)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Without a Clue (1988)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Withnail &amp;amp; I (1987)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Wild Zero (2000)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;War Room (2015)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Walker (1987)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Voices from the List (2004)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Videodrome (1983)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Victoria (2015)&amp;#39;&lt;/span&gt;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;匹配商品&#34;&gt;匹配商品&lt;/h3&gt;
&lt;p&gt;现在我们已经可以为指定人员寻找品味相近的用户，以及如何向其推荐商品。假如我们想要了解哪些物品是相近的，那又该如何呢？&lt;/p&gt;
&lt;p&gt;在我们浏览 Amazon 的时候，经常会看到页面底部会推荐与当前浏览的物品相似的商品。这种情况，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，这和我们之前用来计算人与人之间的相似度是一样的，只需要把人和物品相互调换就行了。&lt;/p&gt;
&lt;p&gt;我们来编写这个翻转字典的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;transformPrefs&lt;/span&gt;(prefs):
	result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; person &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; prefs[person]:
			result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault[item, {}]
			&lt;span style=&#34;color:#75715e&#34;&gt;# 将物品和人对调&lt;/span&gt;
			result[item][person] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prefs[person][item]
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有了这个方法之后，我们就可以复用之前所写的方法了。&lt;/p&gt;
&lt;p&gt;在 ipython 环境中测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; load(recommendations)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; movies &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;transformPrefs()
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;topMatches(movies, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;For the Birds (2000)&amp;#39;&lt;/span&gt;)
[(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.000000000000016&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;Silence of the Lambs&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;World War Z (2013)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Wallace &amp;amp; Gromit in The Curse of the Were-Rabbit (2005)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Tron: Legacy (2010)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Transcendence (2014)&amp;#39;&lt;/span&gt;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们还可以为影片推荐评论者：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getRecommendations(movies, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;For the Birds (2000)&amp;#39;&lt;/span&gt;)[:&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;]
[(&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;668&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;618&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;543&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;541&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;536&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;52&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;464&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;46&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;409&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;357&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;308&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;296&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;29&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;28&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;197&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;196&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;190&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;131&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;113&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;4.999999999999999&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;465&amp;#39;&lt;/span&gt;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;基于物品的协同过滤&#34;&gt;基于物品的协同过滤&lt;/h2&gt;
&lt;p&gt;当前所完成的推荐系统，要求我们使用每一位用户的全部评分来构建数据集，这种方法对于小规模的数据集是没有问题的，但是对于像 Amazon 这样有着上百万用户和商品的大型网站而言，讲一个用户同其他所有用户进行比较，然后再对每位用户评过分的商品进行比较，时间花费上是巨大的。&lt;/p&gt;
&lt;p&gt;目前为止我们所使用的技术被称为&lt;strong&gt;基于用户的协同过滤&lt;/strong&gt;（user-based collaborative filtering）。除此以外，还有一种可供选择的方法被称为&lt;strong&gt;基于物品的协同过滤&lt;/strong&gt;（item-based collaborative filtering）。在拥有大量数据集的情况下，基于物品的协同过滤能够得出更好的结论，而且它允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们所要的结果。&lt;/p&gt;
&lt;p&gt;基于物品的协同过滤总体思路就是为每件物品预先计算好最为相近的其他物品。然后，当我们想为某位用户提供推荐的时候，就可以查看他曾经评过分的物品，并从中选出排名靠前者，再构造一个加权列表，其中包含了与这些选中物品最相近的其他物品。此处最显著的区别在于，尽管第一步要求我们检查所有的数据，但是物品间的比较不会像用户间比较那么频繁变化。&lt;/p&gt;
&lt;h3 id=&#34;构造物品比较数据集&#34;&gt;构造物品比较数据集&lt;/h3&gt;
&lt;p&gt;为了对物品进行比较，我们要做的第一件事就是编写一个函数，构造一个包含相近物品的完整数据集。构建完数据集之后，我们就可以在需要的时候重复使用它。&lt;/p&gt;
&lt;p&gt;将下面代码添加到 &lt;code&gt;recommendations.py&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calculateSimilarItems&lt;/span&gt;(prefs, n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;):
	&lt;span style=&#34;color:#75715e&#34;&gt;# 建立字典，以给出与这些物品最为相近的其他物品&lt;/span&gt;
	result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	
	&lt;span style=&#34;color:#75715e&#34;&gt;# 以物品为中心最偏好矩阵进行倒置处理&lt;/span&gt;
	itemPrefs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; transformPrefs(prefs)
	c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; itemPrefs:
		&lt;span style=&#34;color:#75715e&#34;&gt;# 针对大数据集更新状态变量&lt;/span&gt;
		c &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
			&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; / &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (c, len(itemPrefs))
		scores &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tomMatchs(itemPrefs, item, n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n, similarity&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sim_pearson)
		result[item] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scores
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数首先利用了此前定义过得 &lt;code&gt;transformPrefs&lt;/code&gt; 函数，对反映评价的字典进行倒置处理，从而得到一个有关物品及其用户评价情况的列表，然后程序又循环遍历每项物品，并将转换了的字典传入 &lt;code&gt;tomMatches&lt;/code&gt; 函数中，求得最为相近的物品及其相似度评价值，最后，它建立并返回了一个包含物品及其最相近物品列表的字典。&lt;/p&gt;
&lt;p&gt;在 ipython 交互环境中测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; reload(recommendations)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; itemsim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;calculateSimilarItems(prefs)
&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;600&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;700&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;800&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;900&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1200&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1300&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1400&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1500&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1600&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1700&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1800&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1900&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8963&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首次运行需要等待一段时间进行计算。&lt;/p&gt;
&lt;p&gt;只有频繁执行该函数，才能令物品的相似度不至于过期。通常我们需要在用户基数和评分数量不是很大的时候执行这一函数，但是随着用户数量的不断增长，物品间的相似度评价通常会变得越来越稳定。&lt;/p&gt;
&lt;h3 id=&#34;获得推荐&#34;&gt;获得推荐&lt;/h3&gt;
&lt;p&gt;现在，我们可以利用反映物品相似度的字典来给出推荐了，我们可以去到用户评价过得所有物品，并找出其相近的物品，根据相似度对其进行加权。&lt;/p&gt;
&lt;p&gt;下表给出了利用基于物品的方法寻找推荐的过程，所用到的数据可以在上面&lt;strong&gt;推荐物品&lt;/strong&gt;一节中找到。&lt;/p&gt;
&lt;p&gt;为 Toby 提供基于物品的推荐：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;影片&lt;/th&gt;
&lt;th&gt;评分&lt;/th&gt;
&lt;th&gt;Night&lt;/th&gt;
&lt;th&gt;R.xNight&lt;/th&gt;
&lt;th&gt;Lady&lt;/th&gt;
&lt;th&gt;R.xLady&lt;/th&gt;
&lt;th&gt;Luck&lt;/th&gt;
&lt;th&gt;R.xLuck&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Snakes&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;0.182&lt;/td&gt;
&lt;td&gt;0.818&lt;/td&gt;
&lt;td&gt;0.222&lt;/td&gt;
&lt;td&gt;0.999&lt;/td&gt;
&lt;td&gt;0.105&lt;/td&gt;
&lt;td&gt;0.474&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Superman&lt;/td&gt;
&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;0.103&lt;/td&gt;
&lt;td&gt;0.412&lt;/td&gt;
&lt;td&gt;0.091&lt;/td&gt;
&lt;td&gt;0.363&lt;/td&gt;
&lt;td&gt;0.065&lt;/td&gt;
&lt;td&gt;0.258&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dupree&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;0.148&lt;/td&gt;
&lt;td&gt;0.148&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;0.182&lt;/td&gt;
&lt;td&gt;0.182&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0.433&lt;/td&gt;
&lt;td&gt;1.378&lt;/td&gt;
&lt;td&gt;0.713&lt;/td&gt;
&lt;td&gt;1.762&lt;/td&gt;
&lt;td&gt;0.352&lt;/td&gt;
&lt;td&gt;0.914&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归一化结果&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3.183&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2.473&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2.598&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此处每一行都列出了一部我们曾经观看过的影片，以及对该片的个人评价。对于每一部我们还未曾看过的影片，相应有一列会指出它与已观看影片的相似程度。以 R.x 打头的列给出了我们队影片的评价值乘以相似度之后的结果。&lt;/p&gt;
&lt;p&gt;总计一行给出了每部影片相似度评价值的总和以及 R.x 列的总和，为了预测我们对每一部影片的评分情况，只要将 R.x 列的总计值除以相似度一列的总计值即可。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;recommendations.py&lt;/code&gt; 中添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getRecommendedItems&lt;/span&gt;(prefs, itemMatch, user):
	userRatings &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prefs[user]
	scores &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	totlaSim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
	
	&lt;span style=&#34;color:#75715e&#34;&gt;# 循环遍历由当前用户评分的物品&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (item, rating) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; userRatings&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items():
		
		&lt;span style=&#34;color:#75715e&#34;&gt;# 循环遍历与当前物品相近的物品&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (similarity, item2) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; itemMatch[item]:
		
			&lt;span style=&#34;color:#75715e&#34;&gt;# 如果该用户已经对当前物品做过评价，则将其忽略&lt;/span&gt;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; item2 &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; userRatings:
				&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
			
			&lt;span style=&#34;color:#75715e&#34;&gt;# 评价值与相似度加权之和&lt;/span&gt;
			scores&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(item2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
			scores[item2] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; similarity &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; rating
			
			&lt;span style=&#34;color:#75715e&#34;&gt;# 全部相似度之和&lt;/span&gt;
			totalSim&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(item2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
			totalSim[item2] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; similarity
			
	&lt;span style=&#34;color:#75715e&#34;&gt;# 将每个合计值除以加权和，求出平均值&lt;/span&gt;
	rankings &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [(score &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; totalSim[item], item) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item, score &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; scores&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items()]
	
	&lt;span style=&#34;color:#75715e&#34;&gt;# 按最高值到最低值的顺序，返回评分结果&lt;/span&gt;
	rankings&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;True)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; rankings
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 ipython 中测试一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; reload(recommendations)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; recommendations&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getRecommendedItems(prefs, itemsim, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;20&amp;#39;&lt;/span&gt;)[:&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]
[(&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Zoot Suit (1981)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Zoolander (2001)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Zack and Miri Make a Porno (2008)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;You&amp;#39;ve Got Mail (1998)&amp;#34;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-Men: The Last Stand (2006)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-Men: Apocalypse (2016)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-Men (2000)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;5.0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Von Ryan&amp;#39;s Express (1965)&amp;#34;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;4.75&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Willow (1988)&amp;#39;&lt;/span&gt;),
 (&lt;span style=&#34;color:#ae81ff&#34;&gt;4.75&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;White Men Can&amp;#39;t Jump (1992)&amp;#34;&lt;/span&gt;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;基于用户进行过滤还是基于物品进行过滤&#34;&gt;基于用户进行过滤还是基于物品进行过滤&lt;/h2&gt;
&lt;p&gt;在数据集大小上，基于物品进行过滤的方式要比基于用户进行过滤更快；在数据的稀疏程度上，稀疏的数据集使用基于物品的过滤方法更优，而对于秘密集的数据集而言，两者的效果几乎一样。&lt;/p&gt;
&lt;p&gt;基于用户的过滤方法更加易于实现，而且无需额外步骤，因此它通常更适用于规模较小的变化非常频繁的数据集。在一些应用中，告诉用户还有哪些人与自己有着相近偏好是有一定价值的——也许对于一个购物网站而言，我们并不想这么做，但是对于一个音乐分享类或者电影评分类网站而言，这种潜在的需求却是存在的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 51 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-51-review/</link>
      <pubDate>Tue, 20 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-51-review/</guid>
      <description>&lt;p&gt;看了一下日历，上一周是 2016 年的倒数第二周了（写这篇文章的时候已经是 52 周了），换了新博客之后就一直没有再写过 Week Review，这其中虽然有一些外部的因素，但大抵上还是不想写。&lt;/p&gt;
&lt;p&gt;上周学校组织来中软做课程设计，所以这些天一直待在中软的培训中心里，课程设计的题目是一个点餐的 Web 应用，用 Java 开发，因为并不打算从事 Java，所以也并没有怎么听，大部分时间都是在自己看书和写自己的 Project。不过要吐槽一下这边的环境，宿舍除了床什么也没有，所以晚上回去什么都干不了，只能坐在床上看看电影，最不能忍的是网都没有……学校送来培训中心的这种做法我是很不认同的，好好的大学为什么要搞成职业教育呢？&lt;/p&gt;
&lt;p&gt;最近找到了大连的一家做 Python Web 的 start up，联系了一下准备过去面试，不过软件园离学校太远了，估计面过了也不会去吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 46 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-46-review/</link>
      <pubDate>Sun, 13 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-46-review/</guid>
      <description>&lt;p&gt;编程学习方面，不完全看完了《利用 Python 进行数据分析》，感觉光看没有进行练习的话很难一次记住那么多用法，所以这本书最好还是最 NumPy、Pandas 这几个库用过一段时间之后再看。之后开始看《集体智慧编程》，目前才看了两章，内容写得还是挺好的，不过很多代码不是很规范（比如命名、缩进什么的），还有就是可能书已经比较老了，很多例子中使用的 API 已经挂掉了，所以不得不自己找数据集下来测试。不知道别人看书是怎样的，反正我看书不把书中每个例子测试一下就感觉书好像没看过，所以看书的速度还是挺慢的，昨天和今天花了两天的时间把第2章的东西总结了一下，写了篇博客。&lt;/p&gt;
&lt;p&gt;朋友说我现在才开始学习机器学习并且想要以此为以后的职业简直在玩火（并且还不打算读研究生的情况下），说得也是，毕竟现在已经大三了，按照道理，应该刷刷题准备下学期的实习面试的。不过既然跳进这个火坑里了，就不能半途而废，至少先学习几个月看看情况再变更计划。如果实在不行，到时候再去做 Web 开发还是可以的。&lt;/p&gt;
&lt;p&gt;前几天在登录 iPad 上的 Evernote 的时候，突然提示我登录的设备超过了两台，需要开通会员（之前开通过一年的会员，后来没有续费），总觉得为了这个再开通会员有点不值得，并且之前 Evernote 在 Mac 上使用就有很多诟病，所以打算换 OneNote 了。更新了一下 Mac 上 OneNote，发现竟然支持手写了，果断用用用。不过 OneNote 最开始的字体问题到现在还没有解决……&lt;/p&gt;
&lt;p&gt;下周五就可以玩上 Pokemon Moon 了，激动不已，虽然破解党们早已二周目通关……&lt;/p&gt;
&lt;p&gt;另外，发现番茄工作法挺好用的，现在也没有什么课了，每天就直接到图书馆里来，打开番茄钟，然后无脑干活就好了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 45 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-45-review/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-45-review/</guid>
      <description>&lt;p&gt;已经第 45 周了啊，再过 10 周 2016 年就要过去了。今天大连下起了雪，似乎冬天就这么不知不觉得来了，记得上一次下大雪的时候去了一次海边，可惜 Photos 在一次事故中数据全部丢失了。作为一个南方人当初决定来北方的时候其实是对雪有一种很强烈的期待的，不过来了大连之后发现其实这里也不怎么下雪，偶尔下一次的雪也不是很大，这在一定程度上有点令人失望。&lt;/p&gt;
&lt;p&gt;上周在读《挪威的森林》这本书，第一次读的时候大概是在初中的时候，当时没看懂里面写的是什么，纯属当做一本小黄书来读的。这次读的时候依旧有好多东西没明白。有一天听着 Thirteen Senses 的专辑猛地读到了 50%，感觉特别压抑，说不出来的压抑，所以就暂时放下了，顺便把翻拍的电影看了一遍，说实话，电影拍得不是很好，剧情的跳跃度有些大了，让没读过小说的人看得莫名其妙。&lt;/p&gt;
&lt;p&gt;学习方面感觉上周特别颓废，什么事情都不相干，每天就窝在宿舍里，果然宿舍是一个让人堕落的地方，甚至连门都不想出去了，吃饭全部叫外卖。还好今天周一强迫自己来了图书馆，希望能做些东西吧。&lt;/p&gt;
&lt;p&gt;这学期的课程基本结束了，免修了两门课，除了上机可能会去一下，其他时间都是空余的了，有大块的时间可以用来做自己想要做额事情了。&lt;/p&gt;
&lt;p&gt;看了一眼窗外，雪似乎已经停了，耳机里放着坂本龙一的「A Flower Is Not A Flower」。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>搭建 Python 科学计算环境</title>
      <link>http://blog.jiayuanzhang.com/post/build-python-scienfic-computing-environment/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/build-python-scienfic-computing-environment/</guid>
      <description>&lt;p&gt;最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。&lt;/p&gt;
&lt;h2 id=&#34;安装虚拟环境&#34;&gt;安装虚拟环境&lt;/h2&gt;
&lt;p&gt;不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在&lt;a href=&#34;http://forrestchang.github.io/2016/07/17/virtualenv-notes/&#34;&gt;virtualenv 相关笔记&lt;/a&gt;这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用&lt;code&gt;alias&lt;/code&gt;），这样就避免每次一打开就输入一长串命令了。&lt;/p&gt;
&lt;p&gt;因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。&lt;/p&gt;
&lt;p&gt;然后使用以下命令一键安装所需要的库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo pip install numpy pandas matplotlib jupyter scikit-learn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装不上的请检查是不是需要翻墙。&lt;/p&gt;
&lt;h2 id=&#34;ipython&#34;&gt;IPython&lt;/h2&gt;
&lt;p&gt;熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。&lt;/p&gt;
&lt;h3 id=&#34;开启-ipython-notebook&#34;&gt;开启 IPython Notebook&lt;/h3&gt;
&lt;p&gt;使用以下命令来打开 IPython Notebook：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ENV2.7&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;$ jupyter notebook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样 server 就启动了，浏览器会自动打开一个目录树。&lt;/p&gt;
&lt;p&gt;Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。&lt;/p&gt;
&lt;p&gt;然后我们新建一个 IPython Notebook 用作演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326145820.png&#34; alt=&#34;14776647413275&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In [1]&lt;/code&gt; 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 &lt;code&gt;matplotlib&lt;/code&gt; 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。&lt;/p&gt;
&lt;h3 id=&#34;内省&#34;&gt;内省&lt;/h3&gt;
&lt;p&gt;在变量的前面或后面加上一个 &lt;code&gt;?&lt;/code&gt; 就可以将有关该对象的一些通用信息显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326145843.png&#34; alt=&#34;14776649884990&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上什么都能看。&lt;/p&gt;
&lt;h3 id=&#34;run-命令&#34;&gt;&lt;code&gt;%run&lt;/code&gt; 命令&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;%run&lt;/code&gt; 可以运行本地的 Python 脚本，并可以在 IPython 中访问脚本中定义的所有变量。&lt;/p&gt;
&lt;p&gt;如果想要脚本能够访问 IPython 中的命名空间，可以使用 &lt;code&gt;%run -i&lt;/code&gt; 命令。&lt;/p&gt;
&lt;h3 id=&#34;测试代码的执行时间&#34;&gt;测试代码的执行时间&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;%time&lt;/code&gt; 和 &lt;code&gt;%timeit&lt;/code&gt; 可以用来测试代码的执行时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326150005.png&#34; alt=&#34;14776653395450&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;下面使用一个具体的例子来演示 IPython Notebook 的使用。&lt;/p&gt;
&lt;p&gt;使用到的数据可以在&lt;a href=&#34;https://www.ssa.gov/oact/babynames/limits.html&#34;&gt;Beyond the Top 1000 Names&lt;/a&gt;下载到，这是一份包含1880-2015年每年出生婴儿姓名出现次数的数据表。&lt;/p&gt;
&lt;p&gt;由于该数据按年份被分割成了好多文件，所以第一步我们需要把所有数据组装到一个 DataFrame 中去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326150028.png&#34; alt=&#34;14776659007521&#34;&gt;&lt;/p&gt;
&lt;p&gt;不知道这些 Python 代码没关系，因为这里只是用来演示 IPython Notebook。&lt;/p&gt;
&lt;p&gt;然后我们按照性别和年度统计总出生数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326150107.png&#34; alt=&#34;14776660937109&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后绘制出表格：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326150149.png&#34; alt=&#34;14776661445090&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 42-43 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-42-43-review/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-42-43-review/</guid>
      <description>&lt;p&gt;连续两周没写周总结了，41周的周总结因为涉及到一些私事所以还是删掉了（当然感兴趣的还是可以在我的 repo 里面找到之前的 commit）。&lt;/p&gt;
&lt;p&gt;过去两周还是发生了很多事情的，一件一件来说吧。&lt;/p&gt;
&lt;p&gt;10.15-10.17 去上海参加了 HACKxFDU，这也是第一次参加 Hackathon，最后抱了大腿队友水到了一个微软的万物互联奖，不过奖品就两套物联网套件，根本不够四个人分(╯°□°）╯。在上海大概玩了一个礼拜，去了趟迪士尼（人多，体验差，项目无聊）就回学校了。然后上一周基本上没做什么事情，一是要准备大创项目的中期检查答辩，二是要复习软件工程的考试。&lt;/p&gt;
&lt;p&gt;最近做出比较重要的一个决定就是确定了以后将要从业的方向，以前基本上都是按照兴趣来学，什么都做过一些，但都不是很深入，也没有想好以后工作想要干嘛。最近不知道怎么突然对数据挖掘和机器学习产生兴趣了，正好之前做的一个大创项目也是和这个有关的（虽然项目内容都是在划水），所以还算对这方面有点经验。&lt;/p&gt;
&lt;p&gt;但是要解决的问题还是有很多的，比如说如何找到工作的问题，搜索了一下，机器学习/数据挖掘的岗位都需要有研究生学历，作为一个辣鸡学校的本科生，能不能找到工作就是一个问题。跟一个朋友说了一下想法，他说我在玩火……当然，实际上这方面倒不是太担心，如果有普通研究生能力的话找到一个工作还是不难的。&lt;/p&gt;
&lt;p&gt;另外一个就是需要系统得学习这一套东西了，包括微积分、线性代数、概率论、统计学、机器学习，大部分内容是数学，现在有点后悔大一大二的时候没有好好学数学了，高数那些课基本就是划水过去的，欠下来的债还要还的。&lt;/p&gt;
&lt;p&gt;现在基本的计划就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看《利用 Python 进行数据分析》，把 Python 的几个科学计算库用熟练；&lt;/li&gt;
&lt;li&gt;复习一下数学的知识，看《程序员的数学》系列的三本书，有基础的话应该挺快就能看完；&lt;/li&gt;
&lt;li&gt;看李航的《统计学习方法》；&lt;/li&gt;
&lt;li&gt;看《集体智慧编程》；&lt;/li&gt;
&lt;li&gt;看周志华的《机器学习》；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面就是初步的入门计划，应该看完了对数据挖掘/机器学习有一个基本的了解了，可以顺便去 Kaggle 上打打比赛，虽然不一定能够能拿到好名次，积累一些经验总是好的。另外 Ng 的课和台大的《机器学习基石》也可以看一下。&lt;/p&gt;
&lt;p&gt;其他一些资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ZuzooVn/machine-learning-for-software-engineers&#34;&gt;Top-down learning path: Machine Learning for Software Engineers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009&#34;&gt;机器学习工程师（中/英）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cn.udacity.com/course/data-analyst-nanodegree--nd002&#34;&gt;数据分析师（中/英）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这周和下周的计划就是把《利用 Python 进行数据分析》这本书看完。&lt;/p&gt;
&lt;p&gt;ps：买了《文明6》，感觉时间还是挺紧的(╯▽╰)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 44 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-44-review/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-44-review/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Coding&lt;/strong&gt; - 本周主要在看《利用 Python 进行数据分析》，大概看了有一半的样子，下周应该能够结束掉。接下来的打算可能是先不看书，而是把&lt;a href=&#34;https://www.quora.com/What-should-I-learn-in-data-science-in-100-hours&#34;&gt;What should I learn in data science in 100 hours?&lt;/a&gt;这个问题下面的回答内容实践一遍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Japanese&lt;/strong&gt; - 日语已经落下好久了，大概还有1个月的时间考试，虽然只是报了一个三级试试水，但是不去考试总感觉白费报名费了，当初以为交了钱就会好好学，然而想多了。另外，日语现在并不是刚需的语言，之前决定学习是为了玩游戏，现在基本想玩的游戏都出了中文，《怪物猎人》玩了几个小时，发现不适合我这种手残。所以到底要不要继续学习日语还有待商榷……&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;English&lt;/strong&gt; - 英语自从到了大学以来就没有刻意地学过，除了准备托福的那段时间背了一些单词，然后其他都是直接用，导致了现在听说读写水平参差不齐，听力和阅读还算可以（至少能听懂和读懂技术相关的内容），口语基本就是没有说过，写作也没怎么练过，写一些基本的句子也要查语法（靠语感来写作结果就是一堆语法错……）。相比较日语来说，英语还算一个刚需的技能，尤其是写作和口语部分，还需要加强训练。接下来的一段时间内也会把英语学习提到日程上来，暂时的计划还没有想好，先加到 TODO 中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reading&lt;/strong&gt; - 发现这学期都没有读过几本书，上学期还能保持基本每周都读一本书，现在 Kindle 都吃灰了。下周先把《挪威的森林》这本书看完吧……&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Game&lt;/strong&gt; - 等《精灵宝可梦 日月》发售，还有20天的样子，没有预定，直接买现货或者买下载版吧。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 40 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-40-review/</link>
      <pubDate>Sun, 02 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-40-review/</guid>
      <description>&lt;p&gt;这周恰逢国庆假期，休息了两天（感觉今天貌似也在休息），明天学校断电断网（大农村条件艰苦），所以应该要出去一天，暂时的行程还没有安排。&lt;/p&gt;
&lt;h2 id=&#34;编程&#34;&gt;编程&lt;/h2&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;首先收到了 &lt;a href=&#34;http://fdu.hackx.org/#/&#34;&gt;HACKxFDU&lt;/a&gt; 的通过邮件，所以 14 号会去上海打一波酱油，以目前的水平如果不抱大腿感觉完全没有拿奖的可能性。主要的目的应该不是去参赛，可能会去找找下学期实习的目标，顺便认识一些大牛(≧▽≦)/&lt;/p&gt;
&lt;p&gt;上周说要看完《Flask Web Development》，但是实际上并没有看完，大概看了一半的样子，期间还看了一些 Flask 的源码，打算边看书边看源码，然后之后再重新造一遍轮子。&lt;/p&gt;
&lt;h3 id=&#34;计划&#34;&gt;计划&lt;/h3&gt;
&lt;p&gt;之前就一直觉得自己的 Python 水平好像一直止步不前（传说中的半吊子水平），要做什么东西都是先 Google 一下用什么库，有些标准库中的内容也很不熟悉。昨天被学长问道最近在学什么，我说在看 Flask，然后就被鄙视了，然后通过对话才意识到 Library Reference 还没有完整的刷过，Python 的基础还是比较薄弱的。现在是个人就会 Python，不过刷过 Library Reference 的人应该还是不多的。&lt;/p&gt;
&lt;p&gt;所以接下去的计划应该是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继续看 Flask（被鄙视也要看啊，开了头不能半途而废……），把源码看懂然后自己山寨一个，尝试着写一些基于 Flask 的 Project；&lt;/li&gt;
&lt;li&gt;刷 Python Library Reference，用 ipython notebook 来做笔记，先刷一遍，不会的东西先跳过；&lt;/li&gt;
&lt;li&gt;刷一下算法，这个是为了下学期的面试准备的，CLRS 没有看完，但是感觉想要看完会花掉不少的时间，看不看到时候再说，先把 LeetCode 刷一遍，然后《编程之美》、《编程珠玑》、《剑指 offer》这几本书刷一遍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这学期估计做完上面的事情时间就用得差不多了，下学期开始的时候就要为参加 GSoC 做一些准备了。&lt;/p&gt;
&lt;p&gt;下周要做的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继续刷《Flask Web Development》，争取看完&lt;/li&gt;
&lt;li&gt;看完 Python Library Reference 2、3、4节&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;日语&#34;&gt;日语&lt;/h2&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;这周貌似完全没有学习日语！所以上周列的计划也没有完成，尴尬！时间分配上面还是有一点问题了，每天有计划今天计算机的东西要看哪些，但是日语的东西貌似一点也没有计划，想到了就看一点，所以没有想到的时候就完全不看了-_-|||&lt;/p&gt;
&lt;h3 id=&#34;计划-1&#34;&gt;计划&lt;/h3&gt;
&lt;p&gt;现在有点后悔抱名 N3 的考试了，以来 N3 没什么卵用，而来貌似自己好像并没有太多时间学习日语，还不如好好学习一下然后直接考 N2 或者 N1，但是如果不去考试的话就浪费了 350 大洋！&lt;/p&gt;
&lt;p&gt;五十音基本上是会了，所以还是直接看《大家的日语》这本书，一天学习一课的样子，学习到第 5 课。&lt;/p&gt;
&lt;h2 id=&#34;游戏&#34;&gt;游戏&lt;/h2&gt;
&lt;p&gt;最近发售的大作有点多啊，首先是 PC 上的《文明6》，然后 11 月份还有《精灵宝可梦 太阳·月亮》，其实主要是想玩日月……&lt;/p&gt;
&lt;h3 id=&#34;pokemon-oras&#34;&gt;Pokemon ORAS&lt;/h3&gt;
&lt;p&gt;这周好像 OR 也没有玩多久，主要就是战斗宅邸推塔，今天超级单打打到 45 层失误跪了，目前的队伍还不是很稳，还要重新组一个队伍。另一方面打了几把排位，语言的关系对有些技能不是很熟悉，所以吃了好几次亏，而且没玩过 xy 导致 gen6 的精灵基本不认识。&lt;/p&gt;
&lt;p&gt;入了对战坑之后发现这游戏根本不是小孩子玩的，虽说是「子供向」的游戏，但是对战方面实在是太硬核了，要了解的东西太多，玩了 70h+ 几乎才了解一些皮毛。不过日月出来了之后应该会好些，不会总是看到技能就要查图鉴是干嘛的了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 39 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-39-review/</link>
      <pubDate>Sun, 25 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-39-review/</guid>
      <description>&lt;h2 id=&#34;编程&#34;&gt;编程&lt;/h2&gt;
&lt;p&gt;总的来说，好像这一周并没有做出什么东西来。本来是在看《Web Scraping with Python》这本书的，可以看到后面发现错误挺多的，都有一些最基本的语法错误，所以索性就直接不看了。然后知乎专栏的爬虫也一直没有开始写。&lt;/p&gt;
&lt;p&gt;从前几周就开始使用 VS Code 了，比想象中的好用很多，上一次使用还是刚出的时候，很多东西都不完善，现在 1.0 版本有了很大的改进，作为主力编辑器应该是没有什么问题了。Atom 的启动速度还是那么慢，什么时候改进一些什么时候再说吧。Emacs 已经好久没有用了，应该没有什么特殊情况不会去用了吧，写 Lisp 和 Haskell VS Code 或许也能够胜任。&lt;/p&gt;
&lt;p&gt;最近最烦心的一件事情就是不知道以后要从事什么方向的程序员了。目前自己的技术栈并不是很丰富，杂七杂八的东西研究了很多，赚钱的技能没学多少……所以还是有必要挑一个搬砖的技能好好磨练一下了。目前初步的计划是 Python Web 开发，然后顺带把 C 语言再看看然后去读 Python 的源码，再看一些经典的书（UNIX 系列）。&lt;/p&gt;
&lt;h3 id=&#34;下周的计划&#34;&gt;下周的计划&lt;/h3&gt;
&lt;p&gt;把《Flask Web Development: Developing Web Applications with Python》这本书看完，然后把书中的博客例子做出来。&lt;/p&gt;
&lt;p&gt;顺便写代码累了的时候可以刷刷《程序员修炼之道》这本书，以前看过其中的一部分，还是比较有意思的。&lt;/p&gt;
&lt;h2 id=&#34;日语&#34;&gt;日语&lt;/h2&gt;
&lt;p&gt;12月份就要考试了，然而我还没怎么开始学习。大概在 YouTube 上看了几节五十音的视频，其实五十音之前也都学过，平假名基本上还是熟悉的，就是片假名记不住-_-|||&lt;/p&gt;
&lt;h3 id=&#34;下周的计划-1&#34;&gt;下周的计划&lt;/h3&gt;
&lt;p&gt;熟练掌握五十音，包括平假名和片假名的书写、发音。先把 YouTube 上那一个系列的视频看完吧，然后直接拿单词卡片来背，Anki 中也有单词本可以用来复习。&lt;/p&gt;
&lt;h2 id=&#34;游戏&#34;&gt;游戏&lt;/h2&gt;
&lt;p&gt;这周没怎么玩游戏，守望先锋已经一周多没有玩了。&lt;/p&gt;
&lt;p&gt;平时的时候玩 「Pokemon Omega Ruby」比较多，也就是孵孵蛋，打打对战塔，刚入对战坑，好多东西还不懂，还需要学习一个。&lt;/p&gt;
&lt;p&gt;开始入门狼人杀，这周的几次聚会玩狼人杀很嗨，在某宝上买了一套卡牌，准备研究研究。&lt;/p&gt;
&lt;h2 id=&#34;阅读&#34;&gt;阅读&lt;/h2&gt;
&lt;p&gt;看了一点《胡适留学日记》，拖到现在还没有看完，Kindle 好像来学校之后就有点吃灰了。&lt;/p&gt;
&lt;h3 id=&#34;下周的计划-2&#34;&gt;下周的计划&lt;/h3&gt;
&lt;p&gt;看完《胡适留学日记》。&lt;/p&gt;
&lt;h2 id=&#34;电影&#34;&gt;电影&lt;/h2&gt;
&lt;p&gt;这周看了三部韩国的电影，分别是《隧道》、《釜山行》、《恐怖直播》，发现韩国的电影好好看！韩国的电影感觉黑色幽默和讽刺多一些，日本的电影中二气息比较多一些，国产的电影嘛……&lt;/p&gt;
&lt;p&gt;相比较最近比较火的《釜山行》，个人还是感觉《隧道》比较好看一些。亚洲地区的丧尸片估计《釜山行》应该是最佳了，但是和欧美的一些丧尸片比起来，还是有差距的，其中的一些套路也都是别人玩过了的。《隧道》这部电影让我感觉和《活埋》很像，但是一个生还了，一个 gg 了……&lt;/p&gt;
&lt;h2 id=&#34;杂项&#34;&gt;杂项&lt;/h2&gt;
&lt;p&gt;这周好像聚会比较多(≧▽≦)，已经吃了好几顿饭+去了一次 KTV，生活过得比较颓废。&lt;/p&gt;
&lt;p&gt;是时候应该沉迷学习了(╯﹏╰）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>virtualenv 相关笔记</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-virtualenv/</link>
      <pubDate>Sun, 17 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-virtualenv/</guid>
      <description>&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;直接使用 pip 来进行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;用途&#34;&gt;用途&lt;/h2&gt;
&lt;p&gt;主要用来创建隔离的 Python 开发环境，比如说一个项目需要用到 2.7 的库，另一个项目需要用到 3.0 的库，我们就可以使用  virtualenv 来分别给这两个项目创建虚拟的 Python 环境，这样可以有效的避免冲突。&lt;/p&gt;
&lt;p&gt;virtualenv 会创建一个拥有独立安装目录的 Python 环境，该隔离环境不会与其他 virtualenv 环境共享模块（可以选择是否访问全局安装目录）。&lt;/p&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;h3 id=&#34;创建虚拟环境&#34;&gt;创建虚拟环境&lt;/h3&gt;
&lt;p&gt;最基本的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ virtualenv ENV
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;ENV&lt;/code&gt; 是用来存放虚拟环境的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$tree -L 1 ENV
ENV
├── bin
├── include
├── lib
└── pip-selfcheck.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;lib&lt;/code&gt; 和 &lt;code&gt;include&lt;/code&gt; 目录是用来存放新的虚拟 Python 环境的依赖库，Package 被安装到 &lt;code&gt;lib/pythonX.X/site-packages/&lt;/code&gt; 中，&lt;code&gt;bin&lt;/code&gt; 目录中是新的 Python 解释器。&lt;code&gt;pip&lt;/code&gt; 和 &lt;code&gt;setuptools&lt;/code&gt; 默认被安装的。&lt;/p&gt;
&lt;h3 id=&#34;active-script&#34;&gt;active script&lt;/h3&gt;
&lt;p&gt;进入虚拟环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source ENV/bin/active
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（如果 &lt;code&gt;source&lt;/code&gt; 命令不存在可以使用 &lt;code&gt;.&lt;/code&gt; 命令。）&lt;/p&gt;
&lt;p&gt;退出虚拟环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ deactivate
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;removing-an-environment&#34;&gt;Removing an Environment&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;(ENV)$ deactivate
$ rm -r /path/to/ENV
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;--system-site-packages-选项&#34;&gt;&lt;code&gt;--system-site-packages&lt;/code&gt; 选项&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;virtualenv --system-site-packages ENV&lt;/code&gt; 将会继承全局 packages。并不是很常用的功能。&lt;/p&gt;
&lt;h3 id=&#34;指定-python-版本&#34;&gt;指定 Python 版本&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;-p PYTHON_EXE&lt;/code&gt; 选项在创建虚拟环境的时候制定 Python 版本。&lt;/p&gt;
&lt;p&gt;Python 2.7:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ virtualenv -p /usr/bin/python2.7 ENV2.7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Python 3.5:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ virtualenv -p /usr/local/bin/python3.5 ENV3.5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成可打包环境&#34;&gt;生成可打包环境&lt;/h3&gt;
&lt;p&gt;某些情况下，我们可能需要在别的地方使用这个已经配置好的虚拟环境，可以使用 &lt;code&gt;virtualenv --relocatable&lt;/code&gt; 将 ENV 修改为可迁移的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(ENV)$ virutalenv --relocatable ./
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Swift 中的内存管理</title>
      <link>http://blog.jiayuanzhang.com/post/garbage-collection-in-swift-lang/</link>
      <pubDate>Fri, 15 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/garbage-collection-in-swift-lang/</guid>
      <description>&lt;p&gt;这篇文章是在阅读《The Swift Programming Language》Automatic Reference Counting（ARC，自动引用计数）一章时做的一些笔记，同时参考了其他的一些资料。&lt;/p&gt;
&lt;p&gt;在早期的 iOS 开发中，内存管理是由开发者手动来完成的。因为传统的垃圾回收机制对于移动平台来说十分低效，苹果采用的是引用计数（RC，Reference Counting）的方式来管理内存，开发者需要通过手工的方式增加或减少一个实例的引用计数。在 iOS 5 之后，引入了 ARC 自动引用计数，使得开发者不需要手动地调用 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 来管理引用计数，但是实际上这些方法还是会被调用，只不过是交给了编译器来完成，编译器会在合适的地方帮我们加入这些方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是自动引用计数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每当你创建一个类的实例的时候，ARC 便会自动分配一块内存空间来存放这个实例的信息，当这个实例不再被使用的时候，ARC 便释放实例所占用的内存。一般每个被管理的实例都会与一个引用计数器相连，这个计数器保存着当前实例被引用的次数，一旦创建一个新的引用指向这个实例，引用计数器便加 1，每当指向该实例的引用失效，引用计数器便减 1，当某个实例的引用计数器变成 0 的时候，这个实例就会被立即销毁。&lt;/p&gt;
&lt;p&gt;在 Swift 中，对引用描述的关键字有三个：&lt;code&gt;strong&lt;/code&gt;，&lt;code&gt;weak&lt;/code&gt; 和 &lt;code&gt;unowned&lt;/code&gt;，所有的引用没有特殊说明都是 &lt;code&gt;strong&lt;/code&gt; 强引用类型。在 ARC 中，只有指向一个实例的所有 &lt;code&gt;strong&lt;/code&gt; 强引用都断开了，这个实例才会被销毁。&lt;/p&gt;
&lt;p&gt;举一个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; name: String
    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(name: String) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.name = name
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;deinit&lt;/span&gt; {
        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A deinit&amp;#34;&lt;/span&gt;)
    }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; a1: A?
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; a2: A?

a1 = A(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;)
a2 = a1

a1 = &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这个例子中，虽然 &lt;code&gt;a1&lt;/code&gt; 这个 &lt;code&gt;strong&lt;/code&gt; 强引用断开了，但是还有 &lt;code&gt;a2&lt;/code&gt; 这个强引用指向这个实例，所以不会在命令行中输出 &lt;code&gt;A deinit&lt;/code&gt;，当我们把 &lt;code&gt;a2&lt;/code&gt; 也设置为 &lt;code&gt;nil&lt;/code&gt; 时，与这个实例关联的所有强引用均断开了，这个实例便会被销毁，在命令行中打印 &lt;code&gt;A deinit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环强引用（Strong Reference Cycles）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，在某些情况下，一个类实例的强引用数永远不能变为 0，例如两个类实例互相持有对方的强引用，因而每个类实例都让对方一直存在，这就是所谓的强引用循环（Strong Reference Cycles）。&lt;/p&gt;
&lt;p&gt;这里引用 TSPL 中的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; name: String
    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(name: String) { &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.name = name }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; apartment: Apartment?
    &lt;span style=&#34;color:#66d9ef&#34;&gt;deinit&lt;/span&gt; { print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;name&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; is being deinitialized&amp;#34;&lt;/span&gt;) }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Apartment&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; unit: String
    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(unit: String) { &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.unit = unit }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; tenant: Person?
    &lt;span style=&#34;color:#66d9ef&#34;&gt;deinit&lt;/span&gt; { print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Apartment &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;unit&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; is being deinitialized&amp;#34;&lt;/span&gt;) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每一个 &lt;code&gt;Person&lt;/code&gt; 实例有一个可选的初始化为 &lt;code&gt;nil&lt;/code&gt; 的 &lt;code&gt;Apartment&lt;/code&gt; 类型，因为一个人并不总是拥有公寓。同样，每一个 &lt;code&gt;Apartment&lt;/code&gt; 实例都有一个可选的初始化为 &lt;code&gt;nil&lt;/code&gt; 的 &lt;code&gt;Person&lt;/code&gt; 类型，因为一个公寓并不总是属于一个人。&lt;/p&gt;
&lt;p&gt;接下来的代码片段定义了两个可选类型的变量 &lt;code&gt;john&lt;/code&gt; 和 &lt;code&gt;unit4A&lt;/code&gt;，并分别设定为下面的 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;Apartment&lt;/code&gt; 的实例，这两个变量都备受设定为 &lt;code&gt;nil&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; john: Person?
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; unit4A: Apartment?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在可以创建特定的 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;Apartment&lt;/code&gt; 实例，并将它们赋值给 &lt;code&gt;john&lt;/code&gt; 和 &lt;code&gt;unit4A&lt;/code&gt; 变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;john = Person(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;John Appleseed&amp;#34;&lt;/span&gt;)
unit4A = Apartment(unit: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4A&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面一段代码将这两个实例关联起来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;john!.apartment = unit4A
unit4A!.tenant = john
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将两个实例关联在一起后，强引用的关系如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326144231.png&#34; alt=&#34;14607053938205&#34;&gt;&lt;/p&gt;
&lt;p&gt;这两个实例关联之后，会产生一个循环强引用，当断开 &lt;code&gt;john&lt;/code&gt; 和 &lt;code&gt;unit4A&lt;/code&gt; 所持有的强引用时，引用计数器并不会归零，所以这两块空间也得不到释放，这就导致了内存泄漏。&lt;/p&gt;
&lt;p&gt;可以将其中一个类中的变量设定为 &lt;code&gt;weak&lt;/code&gt; 弱引用来打破这种强引用循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Apartment&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; unit: String
    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(unit: String) { &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.unit = unit }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;weak&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; tenant: Person?
    &lt;span style=&#34;color:#66d9ef&#34;&gt;deinit&lt;/span&gt; { print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Apartment &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;unit&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; is being deinitialized&amp;#34;&lt;/span&gt;) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326144320.png&#34; alt=&#34;14607057294969&#34;&gt;&lt;/p&gt;
&lt;p&gt;当断开 &lt;code&gt;john&lt;/code&gt; 和 &lt;code&gt;unit4A&lt;/code&gt; 所持有的强引用时，&lt;code&gt;Person instance&lt;/code&gt; 的引用计数器变成 0，实例被销毁，从而 &lt;code&gt;Apartment instance&lt;/code&gt; 的引用计数器也变为 0，实例被销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候使用 &lt;code&gt;weak&lt;/code&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当两个实例是 optional 关联在一起时，确保其中的一个使用 &lt;code&gt;weak&lt;/code&gt; 弱引用，就像上面所说的那个例子一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;unowned&lt;/code&gt; 无主引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在某些情况下，声明的变量总是有值得时候，我们需要使用 &lt;code&gt;unowned&lt;/code&gt; 无主引用。&lt;/p&gt;
&lt;p&gt;同样借用一下 TSPL 中的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; name: String
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; card: CreditCard?
    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(name: String) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.name = name
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;deinit&lt;/span&gt; { print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;name&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; is being deinitialized&amp;#34;&lt;/span&gt;) }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CreditCard&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; number: UInt64
    &lt;span style=&#34;color:#66d9ef&#34;&gt;unowned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; customer: Customer
    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(number: UInt64, customer: Customer) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.number = number
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.customer = customer
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;deinit&lt;/span&gt; { print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Card #&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;number&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; is being deinitialized&amp;#34;&lt;/span&gt;) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里定义了两个类，&lt;code&gt;Customer&lt;/code&gt; 和 &lt;code&gt;CreditCard&lt;/code&gt;，模拟了银行客户和客户的信用卡，在这个例子中，每一个类都是将另一个类的实例作为自身的属性，所以会产生循环强引用。&lt;/p&gt;
&lt;p&gt;和之前那个例子不同的是，&lt;code&gt;CreditCard&lt;/code&gt; 类中有一个非可选类型的 &lt;code&gt;customer&lt;/code&gt; 属性，因为，一个客户可能有或者没有一张信用卡，但是一张信用卡总是关联着一个用户。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; john: Customer?
john = Customer(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;John Appleseed&amp;#34;&lt;/span&gt;)
john!.card = CreditCard(number: &lt;span style=&#34;color:#ae81ff&#34;&gt;1234_5678_9012_3456&lt;/span&gt;, customer: john!)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联两个实例后，它们的引用关系如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326144333.png&#34; alt=&#34;14607068387297&#34;&gt;&lt;/p&gt;
&lt;p&gt;当断开 &lt;code&gt;john&lt;/code&gt; 变量持有的强引用时，再也没有指向 &lt;code&gt;Customer&lt;/code&gt; 的强引用了，所以该实例被销毁了，其后，再也没有指向 &lt;code&gt;CreditCard&lt;/code&gt; 的强引用了，该实例也被销毁了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候使用 &lt;code&gt;unowned&lt;/code&gt; 无主引用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个实例 A 和 B，如果实例 A 必须在实例 B 存在的前提下才能存在，那么实例 A 必须用 &lt;code&gt;unowned&lt;/code&gt; 无主引用指向实例 B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。&lt;/p&gt;
&lt;p&gt;例如上面那个例子所说，银行客户可能没有信用卡，但是每张信用卡总是绑定着一个银行客户，所以信用卡这个类就需要用 &lt;code&gt;unowned&lt;/code&gt; 无主引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无主引用以及隐市解析可选属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况，两个属性都必须有值，并且初始化完成之后永远不会为 &lt;code&gt;nil&lt;/code&gt;。在这种情况下，需要一个类使用 &lt;code&gt;unowned&lt;/code&gt; 无主引用，另一个类使用&lt;a href=&#34;http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html#implicityly_unwrapped_optionals&#34;&gt;隐式解析可选属性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包引起的循环强引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Swift 中，闭包和函数都属于引用类型。并且闭包还有一个特性：可以在其定义的上下文中捕获常量或者变量。所以，在一个类中，闭包被赋值给了一个属性，而这个闭包又使用了这个类的实例的时候，就会引起循环强引用。&lt;/p&gt;
&lt;p&gt;Swift 提供了一种方法来解决这个问题：闭包捕获列表（closure capture list）。在定义闭包的同时定义捕获列表作为闭包的一部分，捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例之间的循环强引用一样，声明每个捕获的引用为弱引用或者无主引用。&lt;/p&gt;
&lt;p&gt;捕获列表中的每一项都由一对元素组成，一个元素是 &lt;code&gt;weak&lt;/code&gt; 或者 &lt;code&gt;unowned&lt;/code&gt; 关键字，另一个元素是类实例的引用（例如最常见得是 &lt;code&gt;self&lt;/code&gt;），这些在方括号内用逗号隔开。&lt;/p&gt;
&lt;p&gt;具体的使用方法请参考&lt;a href=&#34;http://wiki.jikexueyuan.com/project/swift/chapter2/16_Automatic_Reference_Counting.html#resolving_strong_reference_cycles_for_closures&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用 &lt;code&gt;weak&lt;/code&gt;，何时使用 &lt;code&gt;unowned&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在闭包和捕获的实例总是相互引用并且总是同时销毁的时候，将闭包内的捕获定义为 &lt;code&gt;unowned&lt;/code&gt; 无主引用。&lt;/p&gt;
&lt;p&gt;在被捕获的实例可能变成 &lt;code&gt;nil&lt;/code&gt; 的情况下，使用 &lt;code&gt;weak&lt;/code&gt; 弱引用。如果被捕获的引用绝对不会变成 &lt;code&gt;nil&lt;/code&gt;，应该使用 &lt;code&gt;unowned&lt;/code&gt; 无主引用，而不是 &lt;code&gt;weak&lt;/code&gt; 弱引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Garbage Collection（GC，垃圾回收）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实 ARC 应该也算 GC 的一种，不过我们一谈到 GC，大多都会想到 Java 中的垃圾回收机制，相比较 GC，ARC 简单得许多。以后有机会可以讨论一下 Java 中的内存管理。&lt;/p&gt;
&lt;p&gt;另外，需要注意的一点是，这里所讲的都是针对于&lt;code&gt;引用类型&lt;/code&gt;，&lt;code&gt;结构体&lt;/code&gt;和&lt;code&gt;枚举&lt;/code&gt;在 Swift 中属于值类型，不在 ARC 的考虑范围之内。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>时间记录不完全指北</title>
      <link>http://blog.jiayuanzhang.com/post/time-recording-tutorial/</link>
      <pubDate>Sun, 10 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/time-recording-tutorial/</guid>
      <description>&lt;p&gt;两年前，曾经写过一篇有关时间管理的&lt;a href=&#34;http://forrestchang.com/14824097073807.html&#34;&gt;文章&lt;/a&gt;，那个时候还在上高二，对于时间管理仅仅是有一点肤浅的了解，自然写出来的文字也是比较幼稚的。经过两年的实践，积累了很多时间管理的经验，想要拿出来分享一下。预计会写一个系列，包括使用的工具和日常的 Workflow。&lt;/p&gt;
&lt;p&gt;日常使用的工具有这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纸质笔记本（Moleskine）&lt;/li&gt;
&lt;li&gt;OmniFocus&lt;/li&gt;
&lt;li&gt;Evernote&lt;/li&gt;
&lt;li&gt;Toggl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章从题目也可以看出来，主要讲一些关于时间记录的内容，对应的工具是 Toggl。关于 Toggl，我已经在知乎的&lt;a href=&#34;https://www.zhihu.com/question/36546814/answer/69161024&#34;&gt;一个回答&lt;/a&gt;里面推荐过了，这里会更加详细地介绍一下使用流程，在谈论术之前，先来说说道的问题，为什么要做时间记录。&lt;/p&gt;
&lt;p&gt;其实我们对时间是很不敏感的，相信你一定有过这样的体验：早晨醒来，干劲满满，准备打开电脑把昨天没有写完的代码解决，这时想到邮件还没看，先查一下邮件吧，反正花不了多少时间，在查看邮件的时候又发现知乎上有人给你发私信了，在到知乎上看一下私信，顺便回复一下，既然上了知乎，那么去首页看看订阅的内容里面有没有什么有意思的东西吧，看到一个有意思的回答，是推荐你买买买的，于是乎又打开淘宝看了看商品的具体情况，顺便加到购物车里，这是候发现已经中午了，算了，先去吃饭吧，代码等等吃完饭再写，吃过午饭后又觉得有一点困意，那就睡一会儿吧，一觉醒来，发现已经四点多了，不行了，赶紧写代码，等等，这个 bug 好像找不到问题所在啊，算了，去 Stack Overflow 上找找吧，在 Stack Overflow 上找到了答案，链接到一篇具体的解释文章，点进去看了看，发现太长了，还是先加到 Pocket 中，以后再看吧，这个人的博客似乎写得不错，浏览一下 Archive 页面看看还有没有其他的好文章，从头到尾浏览了一遍，心中不禁惊叹，写得真好！然后想到今天 Reddit 好像还没看，说不定又有什么好东西，于是又上 /r/programming 刷了一会儿，看到了几篇牛逼的文章，时间也不早了，该吃晚饭了，吃完晚饭自然又不想写代码，休息一会儿，逛一下 Bilibili 吧，看了几个视频之后突然想到今天的代码还没有写，于是又接着关掉网页去写代码，搞到深夜，终于把代码写完了，朋友圈发一条状态「奋战到深夜，终于把代码改完了！」。&lt;/p&gt;
&lt;p&gt;多么充实的一天，你这样想到，今天似乎做了很多事情。但是实际上呢？有效的时间几乎只有两三个小时。所以你需要把做什么事用了多长时间记录下来，然后就会发现这「充实」的一天过得是多么可怕了。&lt;/p&gt;
&lt;p&gt;根据这些时间的时间记录的经验来看，至少有以下三点好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高对时间的感知能力，发现和避免时间黑洞。记录下时间的时候，你会刻意地关注目前手上正在做的事，如果是一些浪费时间的事，会使你减少花在上面的时间。&lt;/li&gt;
&lt;li&gt;更好地制定计划。有段时间给自己制定的计划老是不能够完成，目标定得太高，再怎么跳也抓不到，通过记录一些事情所花费的时间，就可以更好地做计划，比如说看完一本书需要用多少时间。&lt;/li&gt;
&lt;li&gt;激励自己。积累了一段时间的数据之后，就可以看到在某一方面投入了多少时间了，根据 10000 小时定律，可以知道自己与专家级别的能力还相差多少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，凡事有利就必有弊。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时间记录本身也会花费时间（可以通过工具来弥补）。&lt;/li&gt;
&lt;li&gt;最开始的时候总是会忘记记录。&lt;/li&gt;
&lt;li&gt;事无巨细地记录时间，增加压力（这一点会在下面详细说明）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单地讲了一下「道」层面的问题，想要继续深入的可以看一下&lt;a href=&#34;https://book.douban.com/subject/1115353/&#34;&gt;《奇特的一生》&lt;/a&gt;这本书。下面说一说「术」的层面。&lt;/p&gt;
&lt;h3 id=&#34;简单的系统&#34;&gt;简单的系统&lt;/h3&gt;
&lt;p&gt;其实最开始的时候一支笔、一本本子、一块手表就够了，这一阶段主要是养成时间记录的习惯，当然使用 Evernote 或者 OneNote 之类的软件也是可以的。可以按照以下的模板来记录：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2016/04/10
7:00 - 8:30 阅读 xxx xx 页（1h30min）
9:00 - 9:45 完成 xxx 项目 xx 功能的开发（45min）
&amp;hellip;&lt;/p&gt;
&lt;p&gt;总结：
编程时间：xx h xx min
阅读时间：xx h xx min
有效时间合计：xx h xx min
娱乐时间：xx h xx min
&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的分类可以根据自己的需求来进行。如果对时间记录没有接触过的同学可以选择这个方法试着用一段时间，看有没有什么改变。&lt;/p&gt;
&lt;h3 id=&#34;toggl&#34;&gt;Toggl&lt;/h3&gt;
&lt;p&gt;前面说了这么多，中与引来了今天的主角：&lt;a href=&#34;https://www.toggl.com/&#34;&gt;Toggl&lt;/a&gt;。什么是 Toggl，简单得来说，是一款时间记录的工具，试用过市面上几乎所有时间记录的工具，发现 Toggl 是最符合《奇特的一生》中的工作流的。&lt;/p&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;p&gt;Toggl 几乎包含了全部平台，其中最强大的属于 Web 版，各种高级的报表功能需要在 Web 版上面才能试使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.toggl.com/best-free-time-tracking-app-for-iphone&#34;&gt;iPhone App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.toggl.com/best-free-time-tracking-app-for-android&#34;&gt;Android App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://support.toggl.com/toggl-desktop-for-windows&#34;&gt;Windows Desktop App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://support.toggl.com/toggl-desktop-for-mac-osx&#34;&gt;Mac Desktop App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://support.toggl.com/toggl-desktop-for-linux&#34;&gt;Linux Desktop App&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且它还提供了 &lt;a href=&#34;https://github.com/toggl/toggl_api_docs/blob/master/toggl_api.md&#34;&gt;API&lt;/a&gt;，可以自由定制。&lt;/p&gt;
&lt;h4 id=&#34;基本使用&#34;&gt;基本使用&lt;/h4&gt;
&lt;p&gt;下面主要介绍 Web 版的内容。注册完登陆进计时页面就是如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143857.png&#34; alt=&#34;14602871668402&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你当前正在记录的内容（如果不确定，可以先不填，这个是比其他软件优秀的原因之一，有时候只是想先记录下时间，之后再进行区分）；&lt;/li&gt;
&lt;li&gt;当前记录内容所属分类，可以添加 Tag，后面的美元符号可以添加这个任务的花费，基本没有用到过这个功能；&lt;/li&gt;
&lt;li&gt;记录的时间，可以手动添加时间；&lt;/li&gt;
&lt;li&gt;Timeline，每天做了什么事情用了多少时间就记录在这里（周六周日没有怎么使用，所以比较空）；&lt;/li&gt;
&lt;li&gt;一周记录时间汇总。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;知道了以上的内容之后就可以开始记录了，比如说就把学习 Toggl 的使用当成第一个记录的内容。&lt;/p&gt;
&lt;h4 id=&#34;更好的分类&#34;&gt;更好的分类&lt;/h4&gt;
&lt;p&gt;详细的分类可以更好地输出报表。我使用的是三级的分类：大类-具体领域分类-task。Toggl 默认只可以使用两个层级的分类，Project - Task，但是可以把 Client 这个用作最大的分类，这样就可以进行三个层级的分类，下面是我的分类内容；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本工作（Client）
&lt;ul&gt;
&lt;li&gt;计算机（Project）&lt;/li&gt;
&lt;li&gt;英语&lt;/li&gt;
&lt;li&gt;健身&lt;/li&gt;
&lt;li&gt;写作&lt;/li&gt;
&lt;li&gt;阅读&lt;/li&gt;
&lt;li&gt;工作（几乎用不到，因为还在学校里）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;固定日程
&lt;ul&gt;
&lt;li&gt;上课&lt;/li&gt;
&lt;li&gt;睡觉&lt;/li&gt;
&lt;li&gt;杂事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;娱乐
&lt;ul&gt;
&lt;li&gt;上网&lt;/li&gt;
&lt;li&gt;游戏&lt;/li&gt;
&lt;li&gt;视频/电影&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分级不宜过多，否则会增加选择的压力，可以在使用的过程中不断改进。&lt;/p&gt;
&lt;p&gt;最大的类别（Clients）可以在 Workspace Settings 中添加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143912.png&#34; alt=&#34;14602879238718&#34;&gt;&lt;/p&gt;
&lt;p&gt;Project 的类别在 Projects 选项中添加，可以给每个 Project 不同的颜色以示区分。&lt;/p&gt;
&lt;p&gt;Tag 很少使用，可以为一些相同类型的事情设定相关的 Tag 来作为补充。&lt;/p&gt;
&lt;h4 id=&#34;强大的统计功能&#34;&gt;强大的统计功能&lt;/h4&gt;
&lt;p&gt;使用纸笔做时间记录的麻烦之处就是统计的时候需要花费很多精力去计算，用 APP 就可以免除这些过程，直接根据记录的内容生成非常漂亮的报表，下面的是我这一周的统计内容，从柱状图可以看出这周的效率是逐渐递减的-_-|||&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143922.png&#34; alt=&#34;14602882623445&#34;&gt;&lt;/p&gt;
&lt;p&gt;Reports 支持三种模式：Summary, Detailed, Weekly。上面的是 Summary 的 Reports，Detailed 会把你做的所有事情列出来，Weekly 会以周视图的方式来显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143937.png&#34; alt=&#34;14602884725256&#34;&gt;&lt;/p&gt;
&lt;p&gt;Reports 支持强大的过滤功能，可以根据需要选择 Reports 的时间长度、Project 内容、Tag 内容等等。比如说我想查看这周用在 iOS Dev 上的时间是多少，只需要选择 iOS Dev 这个 Tag 就可以了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143958.png&#34; alt=&#34;14602886317764&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dashboard&#34;&gt;Dashboard&lt;/h4&gt;
&lt;p&gt;Toggl 还提供了仪表盘视图，在这里你可以看到最常 Track 的项目以及一些其他内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326144010.png&#34; alt=&#34;14602889789430&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果在本地 APP 里面打开了 Timeline Track，还可以在 Timeline For Today 这一栏里面查看使用了什么软件，用了多长时间。&lt;/p&gt;
&lt;h4 id=&#34;workflow&#34;&gt;Workflow&lt;/h4&gt;
&lt;p&gt;每天从 Todo 里面拿出一件事情，打开计时器，开始做，本着「做一件事情就把它做好的原则」去完成。积累了一段时间的数据之后，就可以更好地计划自己了，比如说本周阅读多少专业书籍，写多少代码。具体的 Workflow 需要结合 OmniFocus 和笔记本来完成，所以会在下一篇文章中来说明。&lt;/p&gt;
&lt;h4 id=&#34;faq&#34;&gt;FAQ&lt;/h4&gt;
&lt;h5 id=&#34;什么事情都需要记录吗&#34;&gt;什么事情都需要记录吗？&lt;/h5&gt;
&lt;p&gt;只需要记录重要的事情。日常生活中的吃喝拉撒记录了没有任何用处，有一段时间我一直在记录自己的睡眠时间，不过后来固定了之后就不记录了。&lt;/p&gt;
&lt;h5 id=&#34;忘了记录怎么办&#34;&gt;忘了记录怎么办？&lt;/h5&gt;
&lt;p&gt;这个只能慢慢地养成记录的习惯，如果记得大概的时间的话，可以手动录入时间。&lt;/p&gt;
&lt;h5 id=&#34;手边没有电脑怎么办&#34;&gt;手边没有电脑怎么办？&lt;/h5&gt;
&lt;p&gt;一般我都是用手机进行记录，如果连手机也不在手边的话，可以先拿张纸记着，之后再手动录入上去。&lt;/p&gt;
&lt;h3 id=&#34;后记&#34;&gt;后记&lt;/h3&gt;
&lt;p&gt;其实，等你做了一段时间的时间日志会发现，会发现效率并没有提高多少，有时候不得不承认这个悲伤的事实，根据自己的时间日志，最高效的一天记录了 7 个小时的学习时间，相比较那些动不动就每天学习 8 小时的人来说，还是差太多了，不过好歹也算是做出了一点点努力。&lt;/p&gt;
&lt;p&gt;写这篇文章的契机是看到了 pluskid 写的&lt;a href=&#34;http://freemind.pluskid.org/misc/knowledge-accumulate/&#34;&gt;《关于知识整理、积累与记忆》&lt;/a&gt;，想到自己也有挺多经验可以分享的，于是便以试试的心态动笔开始写。&lt;/p&gt;
&lt;p&gt;仓促成文，错误在所难免，还望指正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux 基础笔记</title>
      <link>http://blog.jiayuanzhang.com/post/linux-basic-notes/</link>
      <pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/linux-basic-notes/</guid>
      <description>&lt;h2 id=&#34;shell-的基本操作&#34;&gt;Shell 的基本操作&lt;/h2&gt;
&lt;h3 id=&#34;常用快捷键&#34;&gt;常用快捷键&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Tab&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;命令补全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强行终止当前程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;键盘输入结束或退出终端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;暂定当前程序，暂停后按下任意键恢复运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将当前程序放到后台运行，恢复到前台命令 &lt;code&gt;fg&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将光标移动到行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将光标移动到行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+k&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除从光标所在位置到行末&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Alt+Backspace&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向前删除一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;常用通配符&#34;&gt;常用通配符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配0或多个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任意一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[list]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配 list 中的任意单一字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[!list]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配除 list 中的任意单一字符以外的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[c1-c2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配c1-c2中的任意单一字符，如[0-9][a-z]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{string1,string2,...}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配其中一个字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{c2..c2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配c1-c2中全部字符，如{1..10}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;用户管理&#34;&gt;用户管理&lt;/h2&gt;
&lt;h3 id=&#34;查看用户&#34;&gt;查看用户&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ who am i
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ who mon likes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;who&lt;/code&gt; 命令其他常用参数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印能打印的全部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印死掉的进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同 &lt;code&gt;am i&lt;/code&gt;, &lt;code&gt;mom likes&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印当前登陆用户数及用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印当前登陆用户登陆信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印运行等级&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;创建用户&#34;&gt;创建用户&lt;/h3&gt;
&lt;p&gt;创建用户需要 &lt;code&gt;root&lt;/code&gt; 用户的权限，所以需要使用 &lt;code&gt;sudo&lt;/code&gt; 这个命令。使用 &lt;code&gt;sudo&lt;/code&gt; 名利需要满足两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;知道当前登陆用户的密码&lt;/li&gt;
&lt;li&gt;当前用户必须在 &lt;code&gt;sudo&lt;/code&gt; 用户组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ su &amp;lt;user&amp;gt; # 切换用户到 user
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;$ sudo &amp;lt;cmd&amp;gt; # 以 root 权限运行命令
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;$ su - &amp;lt;user&amp;gt; # 切换用户，并且环境变量同时改变到目标用户的环境变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建用户命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo adduser &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建用户的同时会为用户创建 home 目录。&lt;/p&gt;
&lt;h3 id=&#34;用户组&#34;&gt;用户组&lt;/h3&gt;
&lt;p&gt;在 Linux 中每个用户都有一个用户组，它们共享一些资源和权限，同时拥有私有资源。&lt;/p&gt;
&lt;h4 id=&#34;查看自己的用户组&#34;&gt;查看自己的用户组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ groups &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者，查看&lt;code&gt;/etc/group&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat /etc/group | sort
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;sort&lt;/code&gt; 表示将读取的文本进行一个字典排序再输出。&lt;/p&gt;
&lt;h5 id=&#34;etcgroup-文件格式说明&#34;&gt;&lt;code&gt;etc/group&lt;/code&gt; 文件格式说明&lt;/h5&gt;
&lt;p&gt;/etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;group_name:password:GID:user_list&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;将其他用户加入-sudo-用户组&#34;&gt;将其他用户加入 sudo 用户组&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;usermod&lt;/code&gt; 命令可以为用户组添加用户，使用该命令需要有 root 权限。&lt;/p&gt;
&lt;p&gt;使用一个具有 root 权限的用户为一个不具有 root 权限的用户添加 &lt;code&gt;sudo&lt;/code&gt; 权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo usermod -G sudo &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;删除用户&#34;&gt;删除用户&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sudo deluser &amp;lt;username&amp;gt; --remove-home
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;文件权限&#34;&gt;文件权限&lt;/h2&gt;
&lt;h3 id=&#34;查看文件权限&#34;&gt;查看文件权限&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ ls -l
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143412.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143425.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143435.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;文件类型&#34;&gt;文件类型&lt;/h4&gt;
&lt;p&gt;Linux 里面一切皆文件。&lt;/p&gt;
&lt;h4 id=&#34;文件权限-1&#34;&gt;文件权限&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;读权限：可以读取某个文件的内容&lt;/li&gt;
&lt;li&gt;写权限：可以编辑和修改某个文件&lt;/li&gt;
&lt;li&gt;执行权限：通常指可以运行的二进制程序文件或者脚本文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：一个目录要同时具有读权限和执行权限才可以打开，要有写权限才允许在其中创建其他文件。Linux 不是用过文件的后缀名来区分文件的类型。&lt;/p&gt;
&lt;h4 id=&#34;链接数&#34;&gt;链接数&lt;/h4&gt;
&lt;p&gt;链接到该文件所在的 inode 结点的文件名数目。&lt;/p&gt;
&lt;h3 id=&#34;修改文件权限&#34;&gt;修改文件权限&lt;/h3&gt;
&lt;h4 id=&#34;方法1二进制数字表示&#34;&gt;方法1：二进制数字表示&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143447.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 只能自己使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ chmod 700 &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;方法2加减赋值操作&#34;&gt;方法2：加减赋值操作&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ chmod go-rw &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;lsquo;g&#39;&amp;lsquo;o&amp;rsquo;还有&amp;rsquo;u&amp;rsquo;，分别表示group，others，user，&#39;+&#39;，&#39;-&amp;rsquo; 就分别表示增加和去掉相应的权限。&lt;/p&gt;
&lt;h2 id=&#34;目录结构&#34;&gt;目录结构&lt;/h2&gt;
&lt;p&gt;Windows 是以存储介质为主的，之下才是目录；而 Unix 是以目录为主的，存储介质是挂载在目录上的。Linux 以树形目录结构的形式来构建整个系统。&lt;/p&gt;
&lt;h3 id=&#34;fhs-标准&#34;&gt;FHS 标准&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FHS 定义了两层规范，第一层是，/下面的各个目录应该要放什么文件数据，例如 /etc 应该要放设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。&lt;/p&gt;
&lt;p&gt;第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件，/usr/share 放置共享数据等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143513.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;FSH 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会持续更新，FSH 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四中交互作用的形态，如下表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143527.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;目录路径&#34;&gt;目录路径&lt;/h3&gt;
&lt;h4 id=&#34;绝对路径&#34;&gt;绝对路径&lt;/h4&gt;
&lt;p&gt;以根目录为起点的完整路径。&lt;/p&gt;
&lt;h4 id=&#34;相对路径&#34;&gt;相对路径&lt;/h4&gt;
&lt;p&gt;相对于你当前目录的路径。&lt;/p&gt;
&lt;h2 id=&#34;文件的基本操作&#34;&gt;文件的基本操作&lt;/h2&gt;
&lt;h3 id=&#34;新建&#34;&gt;新建&lt;/h3&gt;
&lt;h4 id=&#34;新建空白文件&#34;&gt;新建空白文件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ touch test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于 &lt;code&gt;touch&lt;/code&gt; 命令，其主要是用来更改文件时间戳的。&lt;/p&gt;
&lt;h4 id=&#34;新建目录&#34;&gt;新建目录&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir testDir
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;-p&lt;/code&gt; 参数，可以创建一个多级目录，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p father/son/grandson
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;复制&#34;&gt;复制&lt;/h3&gt;
&lt;h4 id=&#34;复制文件&#34;&gt;复制文件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cp test testDir
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;复制目录&#34;&gt;复制目录&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cp -r father family
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ rm test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数 &lt;code&gt;-f&lt;/code&gt; 可以强制删除一些为只读权限的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rm -f test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除一个目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rm -r testDir
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;移动文件&#34;&gt;移动文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ mv testFile testDir
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;重命名文件&#34;&gt;重命名文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt; 命令还有重命名的作用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mv oldName newName
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;查看文件&#34;&gt;查看文件&lt;/h3&gt;
&lt;h4 id=&#34;cat-与-tac&#34;&gt;&lt;code&gt;cat&lt;/code&gt; 与 &lt;code&gt;tac&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这两个命令都是用来打印文件内容到标准输出（终端），其中&lt;code&gt;cat&lt;/code&gt; 为正序显示，&lt;code&gt;tac&lt;/code&gt; 为倒序显示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘；标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以使用&lt;code&gt;-n&lt;/code&gt; 参数来显示行号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat -n &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;nl&#34;&gt;&lt;code&gt;nl&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;添加行号并打印，比 &lt;code&gt;cat&lt;/code&gt; 更加强大，参数说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b : 指定添加行号的方式，主要有两种：
    -b a:表示无论是否为空行，同样列出行号(&amp;quot;cat -n&amp;quot;就是这种方式)
    -b t:只列出非空行的编号并列出（默认为这种方式）
-n : 设置行号的样式，主要有三种：
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示，且不加 0
    -n rz:在行号字段最右边显示，且加 0
-w : 行号字段占用的位数(默认为 6 位)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;查看文件类型&#34;&gt;查看文件类型&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;file&lt;/code&gt; 命令来查看文件类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ file /bin/ls
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143553.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这表示这是一个可执行文件。&lt;/p&gt;
&lt;h2 id=&#34;环境变量&#34;&gt;环境变量&lt;/h2&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;declare&lt;/code&gt;命令可以创建一个变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ declare tmp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;读取变量的值，使用&lt;code&gt;echo&lt;/code&gt;命令和&lt;code&gt;$&lt;/code&gt;符号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo $tmp
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;环境变量-1&#34;&gt;环境变量&lt;/h3&gt;
&lt;p&gt;环境变量就是作用域比自己定义的变量要大，如 Shell 的环境变量作用于自身和它的子进程。例如 Shell 环境变量作用于自身和它的子进程。在类 UNIX 系统中，每个进程都有其各自的环境变量设置，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。&lt;/p&gt;
&lt;p&gt;通常我们会涉及到的环境变量有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前 Shell 进程私有用户自定义变量，只在当前 Shell 中有效&lt;/li&gt;
&lt;li&gt;Shell 本身内建的变量&lt;/li&gt;
&lt;li&gt;从自定义变量导出的环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;这三个命令可以用来打印相关环境变量，区别在于涉及的是不同范围的环境变量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示当前 shell 所有环境变量，包括其内建环境变量、用户自定义变量及导出的环境变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;env&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示与当前用户相关的环境变量，还可以让命令在制定环境中运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;export&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326143605.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;命令的查找路径与顺序&#34;&gt;命令的查找路径与顺序&lt;/h3&gt;
&lt;p&gt;Shell 通过环境变量&lt;code&gt;PATH&lt;/code&gt;来搜索命令。&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;PATH&lt;/code&gt; 环境变量的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo $PATH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些目录下面存放的都是可执行文件。&lt;/p&gt;
&lt;h3 id=&#34;添加自定义路径到path-环境变量&#34;&gt;添加自定义路径到&lt;code&gt;PATH&lt;/code&gt; 环境变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PATH&lt;/code&gt;里面的路径是以&lt;code&gt;:&lt;/code&gt;作为分隔符，所以可以这样添加自定义路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ PATH=$PATH:/home/xxxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意到这里一定要使用绝对路径。&lt;/p&gt;
&lt;p&gt;这种修改的方式只对当前的 Shell 有效，要想让每个用户都讷讷够使用，需要更改相应的配置文件，例如&lt;code&gt;zsh&lt;/code&gt;需要修改相应的&lt;code&gt;.zshrc&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;修改和删除已有变量&#34;&gt;修改和删除已有变量&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;unset&lt;/code&gt;命令来删除一个环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ unset temp
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;如何让环境变量立即生效&#34;&gt;如何让环境变量立即生效&lt;/h3&gt;
&lt;p&gt;在修改了配置文件后，可以使用&lt;code&gt;source&lt;/code&gt;命令来让其立即生效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source .zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;搜索文件&#34;&gt;搜索文件&lt;/h2&gt;
&lt;h3 id=&#34;whereis简单快速&#34;&gt;&lt;code&gt;whereis&lt;/code&gt;简单快速&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ whereis who
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;whereis&lt;/code&gt;只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。&lt;/p&gt;
&lt;h3 id=&#34;locate快而全&#34;&gt;&lt;code&gt;locate&lt;/code&gt;快而全&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;/var/lib/mlocate/mlocate.db&lt;/code&gt;数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行&lt;code&gt;updatedb&lt;/code&gt;命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次&lt;code&gt;updatedb&lt;/code&gt;命令。他可以用来查找指定目录下的不同文件类型，例如查找/usr/share/下所有的 jpg 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ locate /usr/share/\*.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意要添加&lt;code&gt;*&lt;/code&gt;号前面的反斜杠转义，否则会无法找到&lt;/p&gt;
&lt;h3 id=&#34;which小而精&#34;&gt;&lt;code&gt;which&lt;/code&gt;小而精&lt;/h3&gt;
&lt;p&gt;我们通常使用&lt;code&gt;which&lt;/code&gt;来确定是否安装了某个指定的软件，因为它只从&lt;code&gt;PATH&lt;/code&gt; 环境变量指定的路径中去搜索命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ which man
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;find-精而细&#34;&gt;&lt;code&gt;find&lt;/code&gt; 精而细&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找，而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。&lt;/p&gt;
&lt;p&gt;在指定目录下搜索指定文件名的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ find /etc/ -name interface
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;find&lt;/code&gt; 命令的基本参数格式为：&lt;code&gt;find [path] [option] [action]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与时间相关的命令参数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-atime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最后访问时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-ctime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-mtime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最后修改时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>2016 Week 12 Review</title>
      <link>http://blog.jiayuanzhang.com/post/2016-week-12-review/</link>
      <pubDate>Wed, 02 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/2016-week-12-review/</guid>
      <description>&lt;p&gt;这周的主题是&lt;code&gt;跑步&lt;/code&gt;，大连的天气开始变暖，终于可以去操场跑步了，不过由于学校在海边，风还是很大的。今天跑完了一个线上马拉松（10km 健康赛），明天大连国际马拉松开始开放报名，打算参加半程马拉松，不知道能不能报上名，毕竟今年有一个目标就是参加一次马拉松（全马或者半马）。比赛日期是5.22，需要利用剩余的两个月的时间积累一下跑量（一周跑5次，每次10km）。&lt;/p&gt;
&lt;p&gt;编程方面，本来打算利用 Flask 写一个网站的，结果拖到今天 Document 也只看了一点点，很显然只能移到下一周来完成了，除了这个就改了改之前写的一些代码。从上周开始看 CSAPP 这本书，看的时候顺带做习题（所有的题目），所以进度很慢，大概每天几页的样子，CMU 的几个 lab 还没有开始做，等看完一部分就去完成这部分的 lab。&lt;/p&gt;
&lt;p&gt;阅读方面，没有读任何书，大部分的时间还是用在了浅阅读上，比如看知乎和 Quora 上的各种问答，阅读别人写的博客之类的。下周的目标是读完《你的灯亮着吗》这本书。&lt;/p&gt;
&lt;p&gt;这周没怎么背单词，现在想是否真的要去考托福了，因为自己的 GPA 有点低，即使有 TOEFL 成绩也申请不上好的学校。不过即使是不考 TOEFL，英语还是要学的。&lt;/p&gt;
&lt;p&gt;再一次地更换了博客的 Generator，这次还换成了 Hexo，用 Atom 来写作，之前还在&lt;a href=&#34;http://forrestchang.github.io/2016/02/13/self-learning-guide/&#34;&gt;一篇文章&lt;/a&gt;中黑过 Atom，没想到这么快就叛逃了，23333 。不过还是得吐槽一下，我装了不少 Package，打开的时候真的是好卡，还掉帧，优化做得确实太渣了，要不是你 UI 漂亮，插件丰富，肯定不用你！转移的过程中没有转移评论内容，因为看了一下 Disqus 中的评论，太乱了（因为之前切换过好几次），转移起来有点麻烦，索性直接不要了，反正评论也不是很多。另外 RSS 地址可能有点变化，如果使用 RSS 阅读器的同学可能需要更新一下 RSS 地址（搞得好像真的有人看似的）。&lt;/p&gt;
&lt;p&gt;马上23：00了，赶紧去睡觉了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apple Music，古典音乐，阅读</title>
      <link>http://blog.jiayuanzhang.com/post/apple-music-and-classical-music-and-reading/</link>
      <pubDate>Wed, 24 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/apple-music-and-classical-music-and-reading/</guid>
      <description>&lt;h3 id=&#34;apple-music&#34;&gt;Apple Music&lt;/h3&gt;
&lt;p&gt;自从Apple Music（以下简称「AM」）发布以来，就一直在使用，从最开始的免费试用到现在每个月10￥的订阅。自从Windows时代就使用iTunes听音乐了（当时有一部iPod），在没有AM的时候，都是从论坛下好别人买的专辑来听。一方面在国内想要在iTunes Store上购买专辑过于麻烦（两个账号需要来回切换），另一方面作为一个学生党iTunes Store上两首歌就相当于一顿饭的价钱对于我来说也有点小贵了，所以AM刚推出的时候，还是比较开心的，没想到入华后价格竟然只要10￥每月，就只相当于两首歌的钱！&lt;/p&gt;
&lt;p&gt;这几个月使用下来，发现还是存在不少的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作逻辑复杂。例如听到一首好听的歌，标注了心之后，它是不会出现在你的播放列表中的，因为标注心只是为了优化推荐的算法。所以每次听到一首好听的曲子，都要进行两个步骤：先添加到库中，再标注心。这样才会在你的Smart Playlist中显示出来。这个估计是iTunes的遗留问题，因为iTunes是以Library的方式来管理的，所以需要先添加进Library中，才能进行进一步的操作，不过AM作为一个流媒体音乐服务，这样做显然是多此一举了。&lt;/li&gt;
&lt;li&gt;每个设备间同步存在问题。我一般都是在Mac上听音乐，不过偶尔也会使用iPhone来听，但是很多加心得歌曲到了iPhone上面就变成没有加心的了。所以现在我也懒得使用iPhone来听歌了，或者就随便打开一个推荐的播放列表来听。&lt;/li&gt;
&lt;li&gt;网络问题。这个应该是最要吐槽的一点了，听歌时断时续是最不能忍的事情了。不知道是Apple在国内没有设置服务器还是什么其他原因，有时候即使开着代理缓冲的速度也很慢。有些专辑就只能先下载下来，然后再听。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是我使用过程中遇到的三个比较影响体验的问题，当然还有其他小的，比如说什么中文歌的名字全是英文（使用英文系统的原因，日文歌的名字全是罗马音等等之类的，只不过这些暂时还能够忍受，不是太影响听音乐的体验（个人很少听中文和日文的歌曲）。&lt;/p&gt;
&lt;p&gt;作为一个数据控，如果听歌的数据不能够记录下来，那么就好像和没听一样（强迫症的症状），虽然iTunes也可以记录歌曲的播放次数，上一次播放时间之类的数据，不过还是过于简单了。之前一直使用的是Last.fm，使用AM了之后发现Last.fm的客户端没办法抓取到数据了，后来找到了「Bowtie」这个小工具，连Radio中播放的内容都能够抓取到，太强大了。分析一首歌听了多少遍的意义并不是很大，但是累计了这么多的数据之后还是可以发现了一些有趣的东西的，比如说我听的最多的歌手是竟然是「ColdPlay」。&lt;/p&gt;
&lt;p&gt;如果作为一个音乐服务来说，AM还存在着很多问题，不过毕竟还是一个新生的流媒体服务，希望下一次大的更新之后能够提高一些用户体验。&lt;/p&gt;
&lt;p&gt;PS. 也使用过一段时间的Xiami和网易云音乐，因为种种原因放弃了。&lt;/p&gt;
&lt;h3 id=&#34;古典音乐&#34;&gt;古典音乐&lt;/h3&gt;
&lt;p&gt;关于古典音乐，其实我只有很少的了解，也只听过很少的入门曲目，最开始听古典是因为「The 50 Most Essential Pieces of Classical Music」这张专辑，这张专辑里面基本上都是一些非常经典的曲目，例如当初看《V字仇杀队》中的「1812 Festival Overture」，以及每个人都熟悉的「Canon in D Major」，如果从来没听过古典，推荐去听一下这个专辑，一定会发现很多熟悉的音乐。&lt;/p&gt;
&lt;p&gt;上学期选修了一门《西方古典音乐鉴赏》，然而并没有很认真地听课，不过还是了解了一些知识。然后看了木遥在博客上的一系列&lt;a href=&#34;http://blog.farmostwood.net/305.html&#34;&gt;介绍古典音乐的文章&lt;/a&gt;，算是对古典音乐有了一个初步的认识。&lt;/p&gt;
&lt;p&gt;如果说是欣赏古典音乐，还是达不到那个层次的，因为现在古典音乐的作用就是在阅读或者写代码的时候提供一个相对较安静的环境，说白了，还是出于一种功利的目的在听（为了更好地完成其他工作）。&lt;/p&gt;
&lt;p&gt;今天听AM的Classical Radio听到很很多以前听过，但是忘了名字的曲子（不得不说，古典音乐的曲子名字太难记了），统统加心添加进Library中。现在听音乐的基本流程就是，先范听，听到喜欢的在去把Artist的所有作品依次听下去，这样会找到不少喜欢的内容。&lt;/p&gt;
&lt;h3 id=&#34;阅读&#34;&gt;阅读&lt;/h3&gt;
&lt;p&gt;前几天Kindle上突然推送了有关Kindle Unlimited的内容，类似于AM，按月订阅，然后可以阅读所有的订阅内容。刚开始还是蛮高兴的，不过看了一下在计划中的书目，基本上没有想看的，果然想看的书还是需要付费啊。不过有7天的试用时间，不用白不用，昨天读了一本漫画书《时间管理：如何充分利用你的24小时》，很有趣的一本小册子。这个漫画好像是一个系列，准备最近把感兴趣的都看一遍。&lt;/p&gt;
&lt;p&gt;最近看书的时间有点少了，而更多的时间都在看RSS订阅的内容，Pocket上存档的文章，以及知乎、Quora、Reddit、Hacker News上的一些文字。毫无疑问，书籍的信噪比肯定是大于后者之流的，如果要搞一个排名的话，信噪比的大小应该是这样的：书籍 &amp;gt; Pocket上存档的文章 &amp;gt; Hacker News = Reddit &amp;gt; RSS订阅内容 &amp;gt; Quora &amp;gt;= 知乎（至少Quora可以练习一下英语，笑）。当然，如果你是整天阅读微信朋友圈以及QQ空间，那么信噪比可能会 &amp;lt; 1。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以上是深夜的无聊吐槽内容，本来这段时间应该是去写代码或者阅读其他内容的，只不过因为结构化拖延的原因才来写Blog……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>学院派编程自学指南</title>
      <link>http://blog.jiayuanzhang.com/post/self-learning-programer-manual-college-part/</link>
      <pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/self-learning-programer-manual-college-part/</guid>
      <description>&lt;p&gt;由于本人目前也处在学习的阶段，文章中列出来的内容也并未全部学习过，所以文章的客观性可能存在一些问题，还望读者自行判断。&lt;/p&gt;
&lt;p&gt;这份指南会不定期更新，有好的建议也可以留言或者给我发邮件。&lt;/p&gt;
&lt;h1 id=&#34;准备&#34;&gt;准备&lt;/h1&gt;
&lt;p&gt;需要的所有工具就是一台可以连接上网络的电脑以及你本人。&lt;/p&gt;
&lt;h2 id=&#34;科学上网&#34;&gt;科学上网&lt;/h2&gt;
&lt;p&gt;很可惜，即使是现在，大部分学习计算机的学生还是不会科学上网。在当前的网络环境下，不会科学上网，意味着你不能用 Google 查资料，不能在 Hacker News 查看最新资讯，需要忍受龟速的 GitHub，云云。然而，科学上网本身却是一件成本非常低的事情，不想折腾的话，一年花个几百块钱买个现成的服务；有折腾精神的人，可以买个服务器自己假设架设上网工具。这一步很重要，不能跳过，否则后面指南中的许多内容都无法进行访问。&lt;/p&gt;
&lt;p&gt;关于科学上网的具体内容，就不再多说了，给你一个关键词：&lt;strong&gt;Lantern&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;学会使用-google-搜索&#34;&gt;学会使用 Google 搜索&lt;/h2&gt;
&lt;p&gt;学会了科学上网，你就能够使用 Google 了，为什么不是 Baidu？相信你用了 Google 之后就自然明白了。&lt;/p&gt;
&lt;p&gt;当了一个学期的助教之后发现，很多的同学其实是没有使用搜索引擎的意识的，遇到问题要么自己死磕，或者就直接求助于他人。这两种都不是很好的办法，正确的做法是&lt;strong&gt;在自己思考后没有结果，然后使用搜索引擎查找问题&lt;/strong&gt;，现阶段，你遇到的所有问题（几乎）都能在 Google 上找到现成的答案，如果没找到，肯定是你搜索的方式不正确。&lt;/p&gt;
&lt;p&gt;使用Google的基本搜索功能就能够解决大部分问题了，当然，如果想要学习更加高级的技巧，这里有一份指南：&lt;a href=&#34;https://www.zhihu.com/question/20161362&#34;&gt;如何用好Google等搜索引擎？&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;英语&#34;&gt;英语&lt;/h2&gt;
&lt;p&gt;你不得不承认，目前为止，编程世界的主流语言还是英文，所以英语能力的好坏决定了你编程能力的上界。中文资料和英文资料相比，实在是太匮乏了，就质量而言，也相对较低。比如我后面提到的很多的课程，都是英文的内容。&lt;/p&gt;
&lt;p&gt;值得庆幸的是，阅读编程资料所需要的英文水平并不需要很高，就个人经验来说，基本上四级水平就足够了，可能还会存在一些生词，但是基本上并不妨碍理解。&lt;/p&gt;
&lt;p&gt;英文的学习应该一直贯穿于编程的学习之中，作为一门工具语言，只需要花少量时间就可以带来比较大的收益（2/8法则）。&lt;/p&gt;
&lt;p&gt;本人的英文水平也不算好，但是基本上能够阅读技术书籍和文档，能够听懂公开课，所以还是有一些简单的经验可以分享一下。&lt;/p&gt;
&lt;h3 id=&#34;把系统换成英文的&#34;&gt;把系统换成英文的&lt;/h3&gt;
&lt;p&gt;有些同学可能看到英文就头疼，这很正常，因为在中文的环境下面生活的太久了。为此，可以试着将平常用的系统换成英文的，虽说不能学到几个单词（Copy/Paste 之类的词），但是可以让你不那么排斥英文。&lt;/p&gt;
&lt;h3 id=&#34;安装电子词典&#34;&gt;安装电子词典&lt;/h3&gt;
&lt;p&gt;OS X下推荐欧路词典，在APP Store中购买完整版的，因为需要添加外部的词典。&lt;/p&gt;
&lt;p&gt;这里推荐一部比较好的词典：《Collins 英汉双解词典》，它是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326142830.png&#34; alt=&#34;eudi&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要看它的英文解释，一个词看得次数多了也就记住了。&lt;/p&gt;
&lt;h3 id=&#34;每天阅读英文的资料&#34;&gt;每天阅读英文的资料&lt;/h3&gt;
&lt;p&gt;一些个人经常阅读的网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://quora.com/&#34;&gt;Quora&lt;/a&gt;：一个类似于知乎的问答类网站，可以挑自己感兴趣的内容来阅读。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://news.ycombinator.com/&#34;&gt;Hacker News&lt;/a&gt;：互联网资讯，业界发生的最新的事件都会在上面。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.reddit.com/r/programming/&#34;&gt;PROGRAMMING&lt;/a&gt;：Reddit 的 Programming 板块，和 Hacker News 类似，不过更加专注于技术内容方面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不要花太多时间在上面，每天浏览一下就行。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;英文学习的总结&#34;&gt;英文学习的总结&lt;/h2&gt;
&lt;p&gt;英语不是能够速成的东西，也不是三言两语能够讲完的东西，这里只是提供一个简单的指导，具体的学习计划还请自行搜索更加专业的学习指南。&lt;/p&gt;
&lt;h1 id=&#34;编程基础&#34;&gt;编程基础&lt;/h1&gt;
&lt;p&gt;完成了这一部分内容的学习后你应该具备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解什么是 Computer Science&lt;/li&gt;
&lt;li&gt;基本的计算机数学能力&lt;/li&gt;
&lt;li&gt;基本的程序开发能力&lt;/li&gt;
&lt;li&gt;基本的算法与数据结构的知识&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机科学导论&#34;&gt;计算机科学导论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/&#34;&gt;Introduction to Computer Science and Programming&lt;/a&gt;：面向&lt;strong&gt;无编程基础或者只有一点基础的人群&lt;/strong&gt;，使用&lt;strong&gt;Python&lt;/strong&gt;作为教学语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.extension.harvard.edu/open-learning-initiative/intensive-introduction-computer-science&#34;&gt;Intensive Introduction to Computer Science Open Learning Course&lt;/a&gt;：CS50，哈佛很火的一门课，在网易公开课上可以找到翻译的视频内容。涵盖的主题有算法（设计、应用、分析）；软件开发（抽象、封装、数据结构、Debug、测试）；计算机体系结构等等。基本上是一门大杂烩的导论课。使用的语言是&lt;strong&gt;C&lt;/strong&gt;、&lt;strong&gt;PHP&lt;/strong&gt;、&lt;strong&gt;JavaScript&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/view_play_list?p=FE6E58F856038C69&#34;&gt;Programming Abstractions&lt;/a&gt;：介绍了更加高级的编程主题（递归、算法分析、数据抽象等等），使用C++作为教学语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数学&#34;&gt;数学&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/&#34;&gt;Mathematics for Computer Science&lt;/a&gt;：介绍了学习计算机所需要的一些数学知识，内容包括集合、关系、证明方法、数论、图论等等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=h_9WjWENWV8&amp;amp;feature=share&amp;amp;list=PLTdIp1DywMlUpLHEg3ADhE6rrxhW_T5Rx&#34;&gt;Discrete Mathematics&lt;/a&gt;：离散数学。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编程语言&#34;&gt;编程语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/programming1&#34;&gt;Learn to Program: The Fundamentals&lt;/a&gt;：面向&lt;strong&gt;无编程基础或者只有一点基础的人群&lt;/strong&gt;，使用&lt;strong&gt;Python&lt;/strong&gt;作为教学语言。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/programming2&#34;&gt;Learn to Program: Crafting Quality Code&lt;/a&gt;：如何编写高效与正确的代码。需要有&lt;a href=&#34;https://www.coursera.org/course/programming1&#34;&gt;Learn to Program: The Fundamentals&lt;/a&gt;的基础。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs61a.org/&#34;&gt;The Structure and Interpretation of Computer Programs&lt;/a&gt;：经典的 SICP 的 Python 版。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算理论&#34;&gt;计算理论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PL601FC994BDD963E4&#34;&gt;Introduction to the Theory of Computation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/principlescomputing1&#34;&gt;Principles of Computing (Part 1)&lt;/a&gt;：介绍了 CS 中基本的数学和编程理论，需要有&lt;strong&gt;Python&lt;/strong&gt;基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法与数据结构&#34;&gt;算法与数据结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/&#34;&gt;Introduction to Algorithms&lt;/a&gt;：MIT的算法导论课，用《算法导论》作为教材，网上可以找到视频资源，网易公开课上有老版的翻译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;核心课程&#34;&gt;核心课程&lt;/h1&gt;
&lt;p&gt;学完了「编程基础」部分的内容后，应该已经可以开发一些复杂的程序了，「核心课程」的内容将深入学习计算机科学理论的几个重要的内容。&lt;/p&gt;
&lt;h2 id=&#34;数学-1&#34;&gt;数学&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/matrix&#34;&gt;Coding the Matrix: Linear Algebra through Computer Science Applications&lt;/a&gt;：线性代数以及在计算机中的应用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://inst.eecs.berkeley.edu/~cs70/sp16/&#34;&gt;Discrete Mathematics and Probability Theory&lt;/a&gt;：离散数学与概率论。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算理论-1&#34;&gt;计算理论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLslgisHe5tBM8UTCt1f66oMkpmjCblzkt&#34;&gt;Theory of Computation - Fall 2011&lt;/a&gt;：介绍了机器模型、上下文无关文法、图灵机等，使用的教材是 Michael Sipser 的 &lt;a href=&#34;http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X&#34;&gt;Introduction to the Theory of Computation&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法与数据结构-1&#34;&gt;算法与数据结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www-inst.eecs.berkeley.edu/~cs61b/fa15/&#34;&gt;Data Structures and Advanced Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.berkeley.edu/~jrs/170/&#34;&gt;Efficient Algorithms and Intractable Problems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统&#34;&gt;操作系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cs162.eecs.berkeley.edu/&#34;&gt;Operating Systems and Systems Programming&lt;/a&gt;：UCB 经典的操作系统课程，介绍了操作系统的基本概念、系统编程、网络、分布式系统、内存分配、多线程等等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.edx.org/course/introduction-linux-linuxfoundationx-lfs101x-2#!&#34;&gt;Introduction to Linux&lt;/a&gt;：介绍了 Linux 以及一些简单的命令行使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;程序语言理论&#34;&gt;程序语言理论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PL9D558D49CA734A02&#34;&gt;Programming Paradigms&lt;/a&gt;：编程范式。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/compilers&#34;&gt;Compilers&lt;/a&gt;：Stanford 的编译原理课。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://freevideolectures.com/Course/2249/Principles-of-Programming-Languages/1&#34;&gt;Principles of Programming Languages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机体系结构&#34;&gt;计算机体系结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PL5PHm2jkkXmgVhh8CHAu9N76TShJqfYDt&#34;&gt;Computer Architecture&lt;/a&gt;：CMU&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/comparch&#34;&gt;Computer Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.berkeley.edu/~istoica/classes/cs268/10/&#34;&gt;Computer Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCb1OiccPJ0wbMZMOleCvhWQ&#34;&gt;Fundamentals of Computer Networking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;编程工具&#34;&gt;编程工具&lt;/h1&gt;
&lt;h2 id=&#34;ide&#34;&gt;IDE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Python: &lt;a href=&#34;https://www.jetbrains.com/pycharm/&#34;&gt;PyCharm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java:&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;IntelliJ IDEA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C/C++: &lt;a href=&#34;https://www.visualstudio.com/en-us/visual-studio-homepage-vs.aspx&#34;&gt;Visual Studio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编辑器&#34;&gt;编辑器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Emacs/Vim&lt;/li&gt;
&lt;li&gt;Sublime Text 3&lt;/li&gt;
&lt;li&gt;VS Code&lt;/li&gt;
&lt;li&gt;Atom&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并不一定要用 Emacs 或者 Vim，Sublime Text 其实已经很强大了，足够做日常简单的编辑工作。（这里黑一下 Atom，启动速度太感人了，所以放在最后一个。）&lt;/p&gt;
&lt;h2 id=&#34;git--github&#34;&gt;Git &amp;amp; GitHub&lt;/h2&gt;
&lt;p&gt;使用版本控制来管理自己平时写的代码。&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/geeeeeeeeek/git-recipes/wiki&#34;&gt;git-recipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://git-scm.com/book/zh/v2?f=tt&amp;amp;hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&#34;&gt;Pro Git 2nd Edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;Git教程 - 廖雪峰&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;如何克服拖延&#34;&gt;如何克服拖延&lt;/h1&gt;
&lt;p&gt;资料是有了，但是拖延症不去学怎么办？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pomodorotechnique.com/&#34;&gt;番茄工作法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prakhar1989/awesome-courses&#34;&gt;https://github.com/prakhar1989/awesome-courses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.agupieware.com/2014/05/online-learning-bachelors-level.html&#34;&gt;http://blog.agupieware.com/2014/05/online-learning-bachelors-level.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1_kdHrT8izbROJNaxGflpcZm2ivsjRGF8j1hMzl3b8O0/htmlview&#34;&gt;https://docs.google.com/spreadsheets/d/1_kdHrT8izbROJNaxGflpcZm2ivsjRGF8j1hMzl3b8O0/htmlview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/programming/wiki/faq&#34;&gt;https://www.reddit.com/r/programming/wiki/faq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>极客的输入法：Squirrel（鼠须管）</title>
      <link>http://blog.jiayuanzhang.com/post/squirrel-tutorial/</link>
      <pubDate>Wed, 11 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/squirrel-tutorial/</guid>
      <description>&lt;p&gt;在OS X平台下，一直没有用到一个很顺手的输入法。系统自带的输入法虽然经过几次的版本更新已经有了很大的改进，但是离能用还有很大的距离。所以之前一直凑合着使用百度输入法，不过最近一直遇到一些奇怪的问题，官方又长时间没有进行更新，恰逢之前听说过&lt;code&gt;Squirrel&lt;/code&gt;这个输入法，于是就本着试用的心态用了一下，发现异常顺手，并且还有丰富的定制性，于是写一篇文章来介绍一下，也作为自己配置过程中的笔记。&lt;/p&gt;
&lt;p&gt;附上一段Gif效果展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326141508.png&#34; alt=&#34;luoshenfu&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;输入法的官方名称是&lt;code&gt;Rime&lt;/code&gt;，中文名是&lt;code&gt;中州韵输入法&lt;/code&gt;，但是在各自的平台下面又有不一样的别名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux
中州韵 ｜ ibus-rime&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows
小狼毫 ｜ Weasel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X
鼠须管 ｜ Squirrel&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用了一段时间发现它有以下几个优点其他输入法是比不上的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;速度很快，几乎没有延迟的时间&lt;/li&gt;
&lt;li&gt;极强的定制性，如果没有想要的功能还可以直接修改源码&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;对于繁体中文支持非常好&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;直接从官网下载安装包安装即可。&lt;/p&gt;
&lt;p&gt;Rime官网：&lt;a href=&#34;http://rime.im/&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Ctrl-~&lt;/code&gt;进行输入法的选择，这里选择&lt;code&gt;朙月拼音・簡化字&lt;/code&gt;即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326141701.png&#34; alt=&#34;rime02&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;默认的的配置其实已经可以使用了，但是为了更加符合自己的使用习惯，我们需要做一些自定义的配置。&lt;/p&gt;
&lt;p&gt;所有的配置文件都保存在&lt;code&gt;~/Library/Rime/&lt;/code&gt;这个目录下面。&lt;/p&gt;
&lt;p&gt;不建议直接修改原先的配置文件，因为这样更新之后会导致修改的内容丢失，正确的做法是建立&lt;code&gt;custom&lt;/code&gt;副本，这样自定义的配置内容会覆盖掉原来的。&lt;/p&gt;
&lt;p&gt;＊注：所有的修改完成了之后都需要重启输入法，快捷键&lt;code&gt;Option+Ctrl+~&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;配置外观&#34;&gt;配置外观&lt;/h3&gt;
&lt;p&gt;初始的外观不是很符合自己的审美，可以进行更换主题、更改字体和字号大小等操作来配置成自己喜欢的样子。&lt;/p&gt;
&lt;p&gt;新建配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch squirrel.custom.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将以下代码写入配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patch:
  style/color_scheme: dark_temple #主题
  style/font_point: 18 #字号大小
  style/horizontal: true #水平显示待选字
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;主题列表&#34;&gt;主题列表&lt;/h4&gt;
&lt;p&gt;自带的主题代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#   注：预设的配色方案及代码（指定为 style/color_scheme ）
#   碧水 - aqua
#   青天 - azure
#   明月 - luna
#   墨池 - ink
#   孤寺 - lost_temple
#   暗堂 - dark_temple
#   星际我争霸 - starcraft
#   谷歌 - google
#   晒经石 - solarized_rock
#   简约白 - clean_white
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;想要更换什么主题只要把代码替换掉就可以了。&lt;/p&gt;
&lt;h4 id=&#34;其他一些配置代码及其说明&#34;&gt;其他一些配置代码及其说明&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  style/page_size: 8			             # 设定候选词数目
  style/inline_preedit: false              # 关闭内嵌编码，这样就可以显示首行的拼音
  style/corner_radius: 10                  # 窗口圆角半径
  style/border_height: 0                   # 窗口边界高度，大于圆角半径才有效果
  style/border_width: 0                    # 窗口边界宽度，大于圆角半径才有效果
  style/line_spacing: 1                    # 候选词的行间距
  style/spacing: 5                         # 在非内嵌编码模式下，预编辑和候选词之间的距
  style/font_face: &amp;quot;Hiragino Sans GB W3&amp;quot;   # 字体名称
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多的一些配置代码可以在&lt;code&gt;squirrel.yaml&lt;/code&gt;中找到。&lt;/p&gt;
&lt;h3 id=&#34;定制标点符号&#34;&gt;定制标点符号&lt;/h3&gt;
&lt;p&gt;鼠须管有一个特别的功能就是输入一个标点的时候可以有很多的候选标点让你选择，比如说中括号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/forrestchang/img-repo/master/20190326141747.png&#34; alt=&#34;rime03&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是有的时候默认就想选择第一个，多出了一个选择的步骤无疑上会增加击键的次数，所以我们可以通过修改配置来解决这个问题，同时也可以自定义想要输入的符号。&lt;/p&gt;
&lt;p&gt;这里我们使用的是&lt;code&gt;朙月拼音・簡化字&lt;/code&gt;，所以需要建立相应的配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch luna_pinyin_simp.custom.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后写入以下配置（可根据自己的需要修改，这里的代码的意思是在全角和半角的状态下输入&lt;code&gt;&amp;lt;&lt;/code&gt;均以&lt;code&gt;《&lt;/code&gt;输出）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patch:
  punctuator/full_shape:
    &amp;quot;&amp;lt;&amp;quot;: &amp;quot;《&amp;quot;
  punctuator/half_shape:
    &amp;quot;&amp;lt;&amp;quot;: &amp;quot;《&amp;quot;
  punctuator/full_shape:
    &amp;quot;&amp;gt;&amp;quot;: &amp;quot;》&amp;quot;
  punctuator/half_shape:
    &amp;quot;&amp;gt;&amp;quot;: &amp;quot;》&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安静模式&#34;&gt;安静模式&lt;/h3&gt;
&lt;p&gt;之前一直使用百度输入法的原因就是因为它有一个安静模式，可以在特定的程序内关闭输入法，比如说&lt;code&gt;Emacs&lt;/code&gt;中大部分时间都是不需要输入中文的，所以当切换到这个程序的时候就自动将输入法切换到英文模式。&lt;/p&gt;
&lt;p&gt;需要找到应用软件的&lt;code&gt;Bundle Identifier&lt;/code&gt;，保存在&lt;code&gt;Info.plist&lt;/code&gt;这个文件当中。&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;squirrel.custom.yaml&lt;/code&gt;（没有自己创建）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patch:
  style/color_scheme: dark_temple
  style/font_point: 18
  style/horizontal: true

  app_options/com.apple.Xcode:
    ascii_mode: true
  app_options/com.runningwithcrayons.Alfred-2:
    ascii_mode: true
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;快捷键&#34;&gt;快捷键&lt;/h2&gt;
&lt;p&gt;鼠须管默认支持&lt;code&gt;Emacs&lt;/code&gt;的快捷键，所以基本上在&lt;code&gt;Emacs&lt;/code&gt;中使用到的一些操作方式都可以在这里使用到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;↑：Control+p&lt;/li&gt;
&lt;li&gt;↓：Control+n&lt;/li&gt;
&lt;li&gt;←：Control+b&lt;/li&gt;
&lt;li&gt;→：Control+f&lt;/li&gt;
&lt;li&gt;上頁：Alt+v&lt;/li&gt;
&lt;li&gt;下頁：Control+v&lt;/li&gt;
&lt;li&gt;句首：Control+a&lt;/li&gt;
&lt;li&gt;句末：Control+e&lt;/li&gt;
&lt;li&gt;回退：Control+h&lt;/li&gt;
&lt;li&gt;刪除：Control+d&lt;/li&gt;
&lt;li&gt;清空：Control+g&lt;/li&gt;
&lt;li&gt;刪詞：Control+k&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;完成以上的配置之后基本上就能够用得很顺手了，更多高级的配置方法可以参考官方的文档：&lt;a href=&#34;http://rime.im/docs/&#34;&gt;幫助與反饋&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rime.im/docs/&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dreamxu.com/install-config-squirrel/&#34;&gt;安装及配置 Mac 上的 Rime 输入法——鼠鬚管 (Squirrel)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用Emacs Org-mode &#43; GitHub Pages 来写博客</title>
      <link>http://blog.jiayuanzhang.com/post/how-to-use-emacs-and-org-mode-to-build-a-blog/</link>
      <pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/how-to-use-emacs-and-org-mode-to-build-a-blog/</guid>
      <description>&lt;p&gt;这个博客就是使用Emacs org-mode + GitHub Pages搭建的，博客的主题是org-mode官网的主题，非常的简洁；评论采用的disqus，访问统计使用的是Google和Baidu的统计代码。&lt;/p&gt;
&lt;p&gt;另外，本文中进行操作的环境是在OSX下完成的，Windows用户请自行参考脑补:)&lt;/p&gt;
&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;
&lt;p&gt;之前也折腾过好多的博客，Jekyll、Hexo、Farbox等，这些静态博客生成器都有一个共同点，都是采用的Markdown语法来进行书写的，而自己平时记笔记都是使用的Emacs org-mode，这样就导致了记笔记和写博客两个过程分裂开来了。&lt;/p&gt;
&lt;p&gt;昨晚偶然看到&lt;a href=&#34;http://dirlt.com/&#34;&gt;dirtysalt&amp;rsquo;s homepage&lt;/a&gt;，被深深的震撼了，博主写了很多的干货，专注与博客的内容而不是博客的外观。而自己也是一个极简主义者，觉得这样的博客样式还是挺好看的（很有Web1.0时代的复古风啊）。恰巧博主也是使用的Emacs来写博客，于是便花了一个上午的时间搜集相关的资料并把博客搭建起来了。&lt;/p&gt;
&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;
&lt;h3 id=&#34;github帐号与github-pages&#34;&gt;GitHub帐号与GitHub Pages&lt;/h3&gt;
&lt;p&gt;首先你需要一个存放博客的地方，这里采用的是GitHub，当让也可以使用其他的服务，只要支持静态页面展示即可。&lt;/p&gt;
&lt;p&gt;GitHub的注册过程省略。&lt;/p&gt;
&lt;p&gt;注册完GitHub帐号之后建立一个新的仓库，命名为 &lt;code&gt;xxx.github.io&lt;/code&gt; ，其中 &lt;code&gt;xxx&lt;/code&gt; 为你的用户名。&lt;/p&gt;
&lt;h3 id=&#34;emacs环境&#34;&gt;Emacs环境&lt;/h3&gt;
&lt;p&gt;我使用的是最近比较火的&lt;a href=&#34;https://github.com/syl20bnr/spacemacs&#34;&gt;spacemacs&lt;/a&gt; ，很多功能都配置好了，基本上手即用。&lt;/p&gt;
&lt;p&gt;如果不是用的spacemacs，确保你的Emacs版本为24，org-mode版本为8.0以上，不排除可能因为版本的原因出现各种各样的错误。&lt;/p&gt;
&lt;p&gt;什么，你还不知道Emacs是什么，那先去下载一个Emacs吧，使用org-mode基本不需要什么Emacs的基础，只需要记住几个快捷键就可以了。&lt;/p&gt;
&lt;h2 id=&#34;建立目录结构&#34;&gt;建立目录结构&lt;/h2&gt;
&lt;p&gt;随便在哪里建一个心得目录，这个目录就是存放你的org文件和html文件的地方。假设我们已经有了这么一个目录 &lt;code&gt;org&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir notes
$ mkdir public_html
$ mkdir gtd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，那个gtd目录你可以不要，那是用来做时间管理的，如果你不想用Emacs做时间管理的话，可以不用建那个目录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;notes: 这个目录就是用来存放元数据的地方，你的org文件、图片、CSS文件、PDF等全都是存放在这里的。&lt;/li&gt;
&lt;li&gt;public_html: 这个目录是用来存放导出的HTML文件的，那些非org格式的文件还会原封不动地拷贝过来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置emacs&#34;&gt;配置Emacs&lt;/h2&gt;
&lt;p&gt;这一步有一些复杂，没有Elisp基础的同学可能看不怎么懂，不过没关系，照着做就是了，现在看不懂可以以后学嘛。&lt;/p&gt;
&lt;p&gt;Emacs org-mode自带了很强大的导出功能，可以导出成HTML、markdown、PDF等格式的文件，我们这里使用自带的导出Project的功能，只不过在导出之前，要做一些配置，告诉Emacs要导出哪些东西，导出到哪里，采用什么规则。&lt;/p&gt;
&lt;p&gt;首先我们在配置文件中添加以下代码（普通的在.emacs中添加，spacemacs用户在.spacemacs中添加）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;  (&lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ox-publish&lt;/span&gt;)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;setq&lt;/span&gt; org-publish-project-alist
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;(

          &lt;span style=&#34;color:#75715e&#34;&gt;;; 把各部分的配置文件写到这里面来&lt;/span&gt;

          ))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后把其他的配置文件依次添加进来就可以了，主要有生成HTML的部分和原样拷贝的部分。&lt;/p&gt;
&lt;p&gt;下面来配置需要转换成HTML的内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;  (&amp;#34;blog-notes&amp;#34;
   :base-directory &amp;#34;~/org/notes&amp;#34;
   :base-extension &amp;#34;org&amp;#34;
   :publishing-directory &amp;#34;~/org/public_html/&amp;#34;
   :recursive t
   :publishing-function org-html-publish-to-html
   :headline-levels 4             ; Just the default for this project.
   :auto-preamble t
   :section-numbers nil
   :author &amp;#34;Yourname&amp;#34;
   :email &amp;#34;example@test.com&amp;#34;
   :auto-sitemap t                ; Generate sitemap.org automagically...
   :sitemap-filename &amp;#34;sitemap.org&amp;#34;  ; ... call it sitemap.org (it&amp;#39;s the default)...
   :sitemap-title &amp;#34;Sitemap&amp;#34;         ; ... with title &amp;#39;Sitemap&amp;#39;.
   :sitemap-sort-files anti-chronologically
   :sitemap-file-entry-format &amp;#34;%d %t&amp;#34;
   )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;:base-directory - 你存放笔记的目录（想将哪里的org文件导出成HTML）&lt;/li&gt;
&lt;li&gt;:base-extension - 导出的文件格式&lt;/li&gt;
&lt;li&gt;:publishing-directory - 导出HTML的目标目录&lt;/li&gt;
&lt;li&gt;:recursive - 设置为t会将子目录中的文件也导出&lt;/li&gt;
&lt;li&gt;:publishing-function - 使用哪个函数来进行publish（注：org 7与8在这个地方有区别）&lt;/li&gt;
&lt;li&gt;:auto-sitemap - 自动生存sitemap&lt;/li&gt;
&lt;li&gt;:sitemap-sort-files - 我这里采用的是按照从新到旧的排列方式&lt;/li&gt;
&lt;li&gt;:sitemap-file-entry-format - 这里采用时间+标题的方式生成sitemap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并不是所有的文件都需要转化为HTML的，比如说一些图片、PDF、CSS样式等，只需要原样拷贝到目标文件就行，配置代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;  (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blog-static&amp;#34;&lt;/span&gt;
   &lt;span style=&#34;color:#e6db74&#34;&gt;:base-directory&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;~/org/notes&amp;#34;&lt;/span&gt;
   &lt;span style=&#34;color:#e6db74&#34;&gt;:base-extension&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf&amp;#34;&lt;/span&gt;
   &lt;span style=&#34;color:#e6db74&#34;&gt;:publishing-directory&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;~/org/public_html/&amp;#34;&lt;/span&gt;
   &lt;span style=&#34;color:#e6db74&#34;&gt;:recursive&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;t&lt;/span&gt;
   &lt;span style=&#34;color:#e6db74&#34;&gt;:publishing-function&lt;/span&gt; org-publish-attachment
   )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;把这两段代码查到刚刚给的框架里面去即可。&lt;/p&gt;
&lt;p&gt;最后，我们再加一段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;  (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blog&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;:components&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blog-notes&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blog-static&amp;#34;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，基本的配置已经完成了，现在可以写一些org文件来生成HTML了。&lt;/p&gt;
&lt;p&gt;比如说我已经写完了一些org文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── blog-history.org
├── css
│   └── worg.css
├── cv.org
├── front-end-development
│   ├── css.org
│   └── html.org
├── how-to-use-org-mode-build-blog.org
├── index.org
├── personal
│   ├── how-to-study-efficiently.org
│   └── index.org
└── sitemap.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后使用&lt;code&gt;M-x org-publish-project&lt;/code&gt;，输入&lt;code&gt;blog&lt;/code&gt;，就会自动开始生成HTML文件了，现在已经可以在public_html文件夹中访问了。&lt;/p&gt;
&lt;p&gt;当然，index页面是需要自己来写的，可以参照我的主页来写，或者自由发挥。&lt;/p&gt;
&lt;h2 id=&#34;个性化定制&#34;&gt;个性化定制&lt;/h2&gt;
&lt;h3 id=&#34;添加css文件&#34;&gt;添加CSS文件&lt;/h3&gt;
&lt;p&gt;首先需要在notes文件夹内新建一个css文件夹，里面保存需要用到的CSS文件，这里我使用的是org-mode官网上用的CSS文件，非常的简洁。&lt;/p&gt;
&lt;p&gt;然后我们需要在 &lt;code&gt;blog-notes&lt;/code&gt; 这个配置中新增一条属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;:html-head&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;link rel=\&amp;#34;stylesheet\&amp;#34; type=\&amp;#34;text/css\&amp;#34; href=\&amp;#34;/css/worg.css\&amp;#34;/&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样子的话再每次生成HTML的时候都会自动加上CSS，这里建议使用绝对路径来访问css文件，要不然在notes文件夹中新建文件夹的时候就无效了。&lt;/p&gt;
&lt;h3 id=&#34;添加评论功能&#34;&gt;添加评论功能&lt;/h3&gt;
&lt;p&gt;这里使用的Disqus的评论系统，使用Duoshuo的话配置过程应该也一样。&lt;/p&gt;
&lt;p&gt;首先在Disqus中注册一个服务，获得一段代码，在 &lt;code&gt;blog-notes&lt;/code&gt; 中新增加一条属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;:html-postamble&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;p class=\&amp;#34;postamble\&amp;#34;&amp;gt;Last Updated %C. Created by %a&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;div id=\&amp;#34;disqus_thread\&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;script type=\&amp;#34;text/javascript\&amp;#34;&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  var disqus_shortname = &amp;#39;yourshortname&amp;#39;;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  (function() {
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           var dsq = document.createElement(&amp;#39;script&amp;#39;); dsq.type = &amp;#39;text/javascript&amp;#39;; dsq.async = true;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           dsq.src = &amp;#39;//&amp;#39; + disqus_shortname + &amp;#39;.disqus.com/embed.js&amp;#39;;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           (document.getElementsByTagName(&amp;#39;head&amp;#39;)[0] || document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]).appendChild(dsq);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           })();
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的是代码中的双引号前面需要加上反斜杠来转义。&lt;/p&gt;
&lt;h3 id=&#34;添加统计功能&#34;&gt;添加统计功能&lt;/h3&gt;
&lt;p&gt;使用百度和Google的统计服务，和添加评论功能类似，还是添加在这条属性里面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;:html-postamble&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;p class=\&amp;#34;postamble\&amp;#34;&amp;gt;Last Updated %C. Created by %a&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;script&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  var _hmt = _hmt || [];
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  (function() {
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           var hm = document.createElement(\&amp;#34;script\&amp;#34;);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           hm.src = \&amp;#34;//hm.baidu.com/hm.js?yourkey\&amp;#34;;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           var s = document.getElementsByTagName(\&amp;#34;script\&amp;#34;)[0];
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           s.parentNode.insertBefore(hm, s);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           })();
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;div id=\&amp;#34;disqus_thread\&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;script type=\&amp;#34;text/javascript\&amp;#34;&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  var disqus_shortname = &amp;#39;yourshortname&amp;#39;;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  (function() {
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           var dsq = document.createElement(&amp;#39;script&amp;#39;); dsq.type = &amp;#39;text/javascript&amp;#39;; dsq.async = true;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           dsq.src = &amp;#39;//&amp;#39; + disqus_shortname + &amp;#39;.disqus.com/embed.js&amp;#39;;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           (document.getElementsByTagName(&amp;#39;head&amp;#39;)[0] || document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]).appendChild(dsq);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           })();
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;script&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  (function(i,s,o,g,r,a,m){i[&amp;#39;GoogleAnalyticsObject&amp;#39;]=r;i[r]=i[r]||function(){
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           })(window,document,&amp;#39;script&amp;#39;,&amp;#39;//www.google-analytics.com/analytics.js&amp;#39;,&amp;#39;ga&amp;#39;);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  ga(&amp;#39;create&amp;#39;, &amp;#39;yourkey&amp;#39;, &amp;#39;auto&amp;#39;);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  ga(&amp;#39;send&amp;#39;, &amp;#39;pageview&amp;#39;);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样注意双引号的转义问题即可。&lt;/p&gt;
&lt;h2 id=&#34;托管到github上&#34;&gt;托管到GitHub上&lt;/h2&gt;
&lt;p&gt;生成了HTML文件之后需要把public_html目录托管到GitHub上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &amp;quot;first commit&amp;quot;
$ git remote add origin xxx
$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;xxx&lt;/code&gt;为你之前创建仓库的SSH路径。以后每次generate之后add、commit、push就可以了。&lt;/p&gt;
&lt;p&gt;现在访问 &lt;code&gt;xxx.github.io&lt;/code&gt; 已经可以看到你的博客啦：）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谈谈时间管理</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-time-management/</link>
      <pubDate>Fri, 14 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-time-management/</guid>
      <description>&lt;p&gt;初次看到时间管理这个概念大概是高二的时候，在此之前，我一直在使用所谓的To-do List来管理自己每天的学习任务（那个时候还不知道）。知道了时间管理这个概念后，惊讶于原来自己早就在对时间进行管理了，只不过最简单的管理方式（后来实践表明，仅仅一个任务清单就足够了）。&lt;/p&gt;
&lt;p&gt;在知道了时间管理这个概念之后，我开始大量的阅读关于时间管理的文章，期间又接触到了GTD（Getting Things Done）这个个人管理系统，还专门读了一遍David的那本书。然后就是不断地下载软件、使用、删除、下载……从PC端到iOS到纸笔GTD都试过。突然发现，自己陷入到一个怪圈，主要工作不是变成了完成任务，而变成了寻找“更高效”的软件系统。相信人都会陷入到这个怪圈中，然后时间一步一步地被吞噬掉。然后你开始发现，最开始计划好要做的事情依旧没做好，甚至要找的高效软件也没有找到，因为你总是认为还会有更高效更方便的软件。&lt;/p&gt;
&lt;p&gt;时间管理的初衷不是最大化的利用时间吗？而现在却浪费了更多的时间。这又是为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;懒惰&lt;/strong&gt;。是的，时间管理只不过是一个借口，一个用来迷惑自己“我是为了更高效的利用时间”的借口。说白了就是自己的懒惰，你就是不想完成任务，然后把“时间管理”当成幌子，找工具、看文章，试想一下，这些事情与你要完成的任务相比，哪一个更加困难？我想应该是你的任务更加困难吧，毕竟看文章只要看就行了。&lt;/p&gt;
&lt;p&gt;我是在阅读了李笑来*《把时间当作朋友》* 一书后突然明白了这个道理，哪里需要那么多花招去管理你的时间啊，JUST DO IT！尽管做就可以了，或者说找到一种方法，就一直用下去，不要换来换去，也不要再找别的方法了，甚至不要再看关于时间管理的文章。&lt;/p&gt;
&lt;p&gt;后来，通过李笑来的书，我又知道了*《奇特的一生》* 这本书（这是一本部头很小的书，几个小时便可以读完，网络上有免费的电子版），用了很快的时间读完了，除了震撼还是震撼。主人公柳比歇夫有一套强大而又完整的时间管理方法，并且坚持了五十几年。这套强大的系统也给他带来了巨大的成就：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;柳比歇夫生前发表了七十来部学术著作。其中有分散分析、生物分类学、昆虫学方面的经典著作；这些著作在国外广为翻译出版。各种各样的论文和专著，他一共写了五百多印张。五百印张，等于一万二千五百张打字稿。即使以专业作家而论，这也是个庞大的数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他的成就定然是不凡的，这本书中还提到了门捷列夫等人，他们都有一个共同的特点：拥有一套独特的管理系统（时间&amp;amp;知识），而且都是不断的改进，最后几乎完美的系统。&lt;/p&gt;
&lt;p&gt;原来强大的时间管理系统也能造就如此伟大的成绩啊。这时不禁又要问，到底要不要时间管理呢？经过一段时间的思考，答案是要的。或者说不是管理时间，而是管理你自己，因为时间终究是那么多时间。&lt;/p&gt;
&lt;p&gt;所以现在可能已经有了一个较为清晰的结论：我们需要管理时间，真的管理时间，而不是测试工具。坐在屏幕前阅读的你，如果还在为时间管理而困扰，依旧不知道选择哪款软件，我的建议是把注意力放到需要完成的任务上来。对于没有那么多繁杂事务的人（事实上绝大多数人没有），一个简单的任务清单就够了，做完一项任务划去一项，就是这么简单。&lt;/p&gt;
&lt;p&gt;还不知道时间管理是什么的同学，只需要阅读一两篇文章就够了，或者只要看一本书就够了，至于看什么书，对于不是“日理万机”的人，个人认为上文提到的两本书或许可以是一个选择。接着，就忘记时间管理这个说法吧，专注于要做的事，开始做！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么我要写博客</title>
      <link>http://blog.jiayuanzhang.com/post/why-i-blog/</link>
      <pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/why-i-blog/</guid>
      <description>&lt;p&gt;很显然，写一个长期的&lt;strong&gt;价值博客&lt;/strong&gt;会带来很多益处，却不会有什么明显的坏处（当然，在某些特定的国家讨论某些特定的话题不在此列）。&lt;/p&gt;
&lt;p&gt;下面是我了解到的写一个长期的价值博客所带来的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;督促自己进行有价值的思考&lt;/strong&gt;。写一篇优秀的文章是不容易的，在写之前，势必需要进行大量的思考、沉淀，要不然你就无事可写。（Note：这里的博客指的是干货文章，碎碎念、心情日记、吐槽文章等不算此列。关于这一点将在下文细说。）很显然，在动手写之前，搜索大量的资料、回忆以前思考过的内容、再将它们串联起来等过程就必不可少了，这就强迫了自己去思考、去总结。这样所带来的益处就是显而易见的：1）&lt;strong&gt;督促自己在平时生活学习中进行与价值的思考&lt;/strong&gt;，因为每一个有价值的思考内容都有可能成为你下一篇博客中所要论述的内容，这就不得不迫使自己思考、总结、记录平时的思考内容；2）&lt;strong&gt;升华平时的思考内容&lt;/strong&gt;，平时思考之事大多都是没有联系的，而想要完成一篇文章，必然需要有一定的结构和逻辑，这就要求自己将平时思考的内容串联起来，更加深入理解背后的本质；3）&lt;strong&gt;写本身就是最好的思考&lt;/strong&gt;，写一篇博客，需要将零散的、不具体的的内容用书面语表现出来，这就要求你需要一定的逻辑表达能力和写作功底。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可以结交很多志同道合的朋友&lt;/strong&gt;。1）毫无疑问，目前大多数人的社交都是在网络上完成的，在没有网络的时代，假设你需要结交一个外国人，那么出国就是你唯一的选择。而到了网路时代，这些所有的动作&lt;strong&gt;只需要一个点击就可以全部完成&lt;/strong&gt;，你可以在家里足不出户就结交到外国的同好；2）传统的认识一个人需要通过交流来完成，这个过程&lt;strong&gt;耗时周期长&lt;/strong&gt;，并且&lt;strong&gt;效率很低&lt;/strong&gt;，因为你每结交一个人，都需要重复的完成这一动作，即使现在有了Twitter等micro blog服务，但这依然是一种低效率的方式：你并不能完全通过他的微博来断定他是一个什么样的人，因为这些社交网站上的内容大多数都是心情日记等杂乱的东西。所以，一个价值博客就显得尤为重要了，这不仅大大简化了结交朋友的途径（&lt;strong&gt;一次写作，反复阅读&lt;/strong&gt;），并且可以客观的反映一个人在各方面的水平。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自己会不一定是真的会&lt;/strong&gt;，只有当自己能够清晰地、准确地教会其他人时，才算真的会了。大家肯定经常会有这样地经历：我自己是明白的，但是就是不知道怎么说，更通俗地讲就是“只可意会，不可言传”。这其实不能算真的会，或者说是会的不彻底。如果想要通过博客来教会别人，势必自己会先将这些不会的部分搞懂，这在一定程度上也强迫了自己去更深入的学习。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;虚心的接受批评&lt;/strong&gt;。自己在思考的过程中难免会有一些错误，可能自己不会发现，但是当它呈现在博客上与他人分享的时候，别人就有可能发现自己的错误。并且，在与他人讨论的过程中，也可以更加深入的思考问题，或者会跳出自己当初的思考境地，以另外一个角度审视问题，这样所带来的帮助也是显而易见的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一个优秀的博客就是一分优秀的简历&lt;/strong&gt;。刘未鹏在&lt;a href=&#34;http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/&#34;&gt;怎样花两年时间去面试一个人&lt;/a&gt;中论述过这个问题。一个优秀的价值博客可能会给你带来职业上的帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锻炼自己持之以恒的能力&lt;/strong&gt;。写一个优秀的博客是不容易的，如果长期更新博客的同学可能就会有体会，写一篇高质量的博客往往需要话费数小时的时间，这还不包括前期思考、搜集信息的时间。**既然写一个博客这么费力，并且还没什么报酬（大多数博客都是无偿的），我为什么要写？**其实，写一个长期的价值博客所带来的效益是很大的，但是它不是以可以用可见的物品来衡量的。简单的说，以上的几点都是写一个博客所带来的价值，这些价值都是不能用金钱来衡量的（如果你需要，一个优秀的博客也可以给你带来金钱效益）。但是坚持写一个博客并不那么简单，这需要你不断思考以获得可写之物，定期的更新博客会提升你自己坚持的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为什么要写价值博客&#34;&gt;为什么要写价值博客&lt;/h2&gt;
&lt;p&gt;什么是价值博客，简单的说就是可以给他人帮助的博客。显然，碎碎念、心情琐记等文章对他人并没有什么帮助，或者说帮助很小。或许你的朋友对这些文章感兴趣，这是因为他们认识你，想要了解你的生活。但是你要意识到，你的博客是面向所有人的（如果是的话），如果其他人并不认识你的话，他可能对你的生活并不怎么感兴趣，他阅读你的博客是为了获取有价值的内容。&lt;/p&gt;
&lt;p&gt;我也经常阅读一些博客的内容，但据我所见，现在的很多博客写的都是一些碎碎念，心情日记，往往这些博客我都要在几十篇文章中寻找干货来阅读，这无疑增加了读者的工作量。如果非要写这些心情琐记，个人建议是和自己的主博客（干货博客）分离开，并且这些东西只需要自己的朋友能够看到就足够了，大部分人想看的是你的价值内容。&lt;/p&gt;
&lt;p&gt;一个价值博客不是那么简单就可以写成的。现在很多人都是比较浮躁的，这些浮躁的风气在博客界也流行起来。经常在网上看到很多人声称一天一篇干货文章，或是每天一篇千字文。并不觉得这样做有什么意义，好的文章不是那么容易就写成的，一千字的文章想要详细的论说一件事情都很困难（也有可能是我的写作功底比较差），更别提能够有什么深度了。事实也正是如此，看过很多这样的文章，要不是文字十分肤浅，就是无话找话，不知所云。所以这也是一个价值博客所需要避免的（当然，一些资讯类的博客除外，例如&lt;a href=&#34;http://www.williamlong.info/&#34;&gt;月光博客&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;如何开始&#34;&gt;如何开始&lt;/h2&gt;
&lt;p&gt;很简单，找一个可以写的地方就开始写。&lt;/p&gt;
&lt;p&gt;如果你是一个爱折腾的人，我推荐Github Pages＋Octopress，十分纯粹，在本地写，写完直接上传即可，没有多余的事情，并且可以支持Markdown语法，大大提高了写作的效率。网络上的教程很多，个人认为官方的文档最适合入门了，可以照着一步一步来完成。如果英文不好的话，可以找一些其他人写的教程（自己估计也会写一篇）。&lt;/p&gt;
&lt;p&gt;如果你不是一个爱折腾的人，可以试试Wordpress，同样的，网络上也有很多教程。&lt;/p&gt;
&lt;p&gt;关见不在于你在哪里写，用什么写，而在于你博客的价值。要知道，很多大牛都是直接用Html写网页上传的。&lt;/p&gt;
&lt;h2 id=&#34;几个问题&#34;&gt;几个问题&lt;/h2&gt;
&lt;h3 id=&#34;q1写了博客没人来阅读怎么办&#34;&gt;Q1:写了博客没人来阅读怎么办？&lt;/h3&gt;
&lt;p&gt;这应该是大多数人所面临的一个问题，当你洋洋洒洒写了上千字时，收获的却只是几十的阅读量，这肯定会一定程度上打击写作者。如果面临这种问题，就需要自己分析一下原因了，如果你写的不是有价值的内容，那么出现这种情况是必然的。**既然你的东西对我没有价值，我为什么要浪费自己的生命去阅读它？**如果你写的博客是有价值的，那么你大可不必担心，因为是金子总要发光的，或者你可以将它转载到别的地方（有价值的内容才值得转载）
。如果你的博客是有价值的，那你就坚持写下去，肯定会有人来读。&lt;/p&gt;
&lt;h3 id=&#34;q2我不知道写些什么怎么开始&#34;&gt;Q2:我不知道写些什么，怎么开始？&lt;/h3&gt;
&lt;p&gt;**你在思考什么，就写什么。**只要是经过思考的内容，都是值得写的，如果不知道写些什么，可以先写下几个关键词，然后再由这些关键词引申出去。比如看了一本书、看了一部电影，你想到了什么？深入的思考一下，总能找到可以写的东西。&lt;/p&gt;
&lt;p&gt;再一个就需要你在生活中积累了，例如我会将大脑中不成形的想法简单的记录下来，以供以后使用。这样做的好处是，当你翻开以前记录的东西时，你会发现你简直有写不完的东西！学会思考，你就不缺东西写。&lt;/p&gt;
&lt;p&gt;如果你写的是一个技术类博客的话，那就更简单了。把技术笔记写下来就可以来，这里的笔记不是指你阅读技术书籍时所写的笔记，它必须是加工过的，因为你是写出来给别人看的,你做笔记时可以随意涂画，想怎么写就怎么写，但是要给别人看明白，就需要有条理地叙述。或者你也可以写自己地研究成果，总之有价值就行。关于技术文章的写作，以后会写一篇具体地文章来说明。&lt;/p&gt;
&lt;h3 id=&#34;q3博客地排版怎么办&#34;&gt;Q3:博客地排版怎么办？&lt;/h3&gt;
&lt;p&gt;如果你使用Markdown写作，那么排版就不是什么大问题。如果你用其他地来排版，也应该不是什么问题，个人建议写完一篇文章之后再排版修改，要不然写一点就停下来排版势必会打断思路，也主客颠倒了。&lt;/p&gt;
&lt;h3 id=&#34;q4如何坚持写&#34;&gt;Q4:如何坚持写？&lt;/h3&gt;
&lt;p&gt;这应该是最困难的一个问题，很多的优秀博客已经消失了，都没能坚持下来。要做到坚持更新，我认为可以尝试一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;制定写作计划&lt;/strong&gt;－－没有计划的写作可能会三分钟热度，可以制定一个每周（这是最短的周期了，一周能完成一篇价值博客已经很不错了）或每月的写作计划，翻看自己思考的记录，找一些可以写的东西，然后就开始写，一旦开了头，下面的工作就十分简单了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设定一个Deadline&lt;/strong&gt;－－例如每周日之前必须完成这周要写的内容，当然，如果你实在没什么可写的话，就不要写，记住，只写有价值的内容，写作不是为了完成任务。这种情况很少会发生，因为如果你积极思考的话，肯定会找到很多要写的东西。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学会自我管理&lt;/strong&gt;－－这就涉及到时间管理层面上了，这方面的内容网络上也有很多，例如GTD，读者可以自行去寻找。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;q5有什么建议吗&#34;&gt;Q5:有什么建议吗？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;写完一篇博客不要立即就发表，先放下来，过几天再去看它，看有没有价值发表，是不是碎碎念？往往这时候会对所写的内容有更深的看法，这时候就可以进一步加工。很多时候我们翻看以前写的文章，是不是感觉很幼稚？人总是在不断的成长。&lt;/li&gt;
&lt;li&gt;多读，多写。广泛地涉猎各个领域地书籍，平时要多阅读，这里地阅读可以是书籍、价值博客等（不是微博、每日资讯）。书籍和博客地半衰期往往很长，有的十几年前地博客文章，现在拿出来还是很好地阅读内容。当然，书籍就更不用说了。微博和新闻类地内容更新周期短，半衰期短，其实读不读都无所谓，那些新闻资讯，除了一些大事，其他的都是没有必要每天花时间阅读的，如果要读，可以每周或每月集中阅读一次，为了使这些信息有价值，别忘了做笔记。&lt;/li&gt;
&lt;li&gt;多思考。如果想要获得源源不绝的灵感，就请多思考。关于思考的方法，如果要详细讲的话，可以写很多。这里推荐一个简单的高效思考方法：利用零碎时间来思考。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;q6有什么推荐的博客吗&#34;&gt;Q6:有什么推荐的博客吗？&lt;/h4&gt;
&lt;p&gt;下面的都是我平常经常阅读的博客，建议订阅RSS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mindhacks.cn/&#34;&gt;刘未鹏 | MIND HACKS&lt;/a&gt;－－思维改变生活，篇篇是干货，值得反复阅读。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/&#34;&gt;阮一峰的网络日志&lt;/a&gt;－－作者的博客内容很多很杂，但每一篇都是作者思考后的成果，值得阅读。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yangzhiping.com/&#34;&gt;杨志平的网志&lt;/a&gt;－－篇篇干货，对心理学和Ruby有研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎样才能找到这些优秀的博客呢？一个较好的方法是，从它们博客的友链中寻找，虽然并不一定准确，但也八九不离十。多用RSS聚合软件。我一般在网上遇到了较好的文章都会发送到Pocket中，不仅可以利用空闲时间阅读，也可以作为存档。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;这片文章很早就准备写了，先前在Evernote中写了几点，现在的这篇是从那几点中发散出来的结果。所以不要怕没有写，开了头，后面的路就比较顺了。&lt;/p&gt;
&lt;p&gt;自己文笔有限，难免有些造句措辞使用不当，就当是笑话看看好了。&lt;/p&gt;
&lt;p&gt;以前的博客都在丢失了（空间到期为续费），现在转到这个新的环境重新开始，这样也好，以前的博客里也有很多碎碎念，现在可以推倒重来了。&lt;/p&gt;
&lt;p&gt;如果你也是一个爱思考，并且有分享精神的人，我建议你现在就去写一个博客。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
