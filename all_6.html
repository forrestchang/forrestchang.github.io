<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Hack Notes
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Hack Notes" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:forrestchang.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_blank" href="portfolio.html">Portfolio</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Hack Notes</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="life.html">Life</a></li>
        
            <li><a href="machine-learning.html">ML</a></li>
        
            <li><a href="python.html">Python</a></li>
        
            <li><a href="productivity.html">Productivity</a></li>
        
            <li><a href="technology.html">Tech</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14824093902273.html">
                
                  <h1>Swift 中的内存管理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>这篇文章是在阅读《The Swift Programming Language》Automatic Reference Counting（ARC，自动引用计数）一章时做的一些笔记，同时参考了其他的一些资料。</p>

<p>在早期的 iOS 开发中，内存管理是由开发者手动来完成的。因为传统的垃圾回收机制对于移动平台来说十分低效，苹果采用的是引用计数（RC，Reference Counting）的方式来管理内存，开发者需要通过手工的方式增加或减少一个实例的引用计数。在 iOS 5 之后，引入了 ARC 自动引用计数，使得开发者不需要手动地调用 <code>retain</code> 和 <code>release</code> 来管理引用计数，但是实际上这些方法还是会被调用，只不过是交给了编译器来完成，编译器会在合适的地方帮我们加入这些方法。</p>

<p><strong>什么是自动引用计数？</strong></p>

<p>每当你创建一个类的实例的时候，ARC 便会自动分配一块内存空间来存放这个实例的信息，当这个实例不再被使用的时候，ARC 便释放实例所占用的内存。一般每个被管理的实例都会与一个引用计数器相连，这个计数器保存着当前实例被引用的次数，一旦创建一个新的引用指向这个实例，引用计数器便加 1，每当指向该实例的引用失效，引用计数器便减 1，当某个实例的引用计数器变成 0 的时候，这个实例就会被立即销毁。</p>

<p>在 Swift 中，对引用描述的关键字有三个：<code>strong</code>，<code>weak</code> 和 <code>unowned</code>，所有的引用没有特殊说明都是 <code>strong</code> 强引用类型。在 ARC 中，只有指向一个实例的所有 <code>strong</code> 强引用都断开了，这个实例才会被销毁。</p>

<p>举一个简单的例子：</p>

<pre><code class="language-swift">class A {
    let name: String
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;A deinit&quot;)
    }
}

var a1: A?
var a2: A?

a1 = A(name: &quot;A&quot;)
a2 = a1

a1 = nil
</code></pre>

<p>上面这个例子中，虽然 <code>a1</code> 这个 <code>strong</code> 强引用断开了，但是还有 <code>a2</code> 这个强引用指向这个实例，所以不会在命令行中输出 <code>A deinit</code>，当我们把 <code>a2</code> 也设置为 <code>nil</code> 时，与这个实例关联的所有强引用均断开了，这个实例便会被销毁，在命令行中打印 <code>A deinit</code>。</p>

<p><strong>循环强引用（Strong Reference Cycles）</strong></p>

<p>但是，在某些情况下，一个类实例的强引用数永远不能变为 0，例如两个类实例互相持有对方的强引用，因而每个类实例都让对方一直存在，这就是所谓的强引用循环（Strong Reference Cycles）。</p>

<p>这里引用 TSPL 中的例子：</p>

<pre><code class="language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}
</code></pre>

<p>每一个 <code>Person</code> 实例有一个可选的初始化为 <code>nil</code> 的 <code>Apartment</code> 类型，因为一个人并不总是拥有公寓。同样，每一个 <code>Apartment</code> 实例都有一个可选的初始化为 <code>nil</code> 的 <code>Person</code> 类型，因为一个公寓并不总是属于一个人。</p>

<p>接下来的代码片段定义了两个可选类型的变量 <code>john</code> 和 <code>unit4A</code>，并分别设定为下面的 <code>Person</code> 和 <code>Apartment</code> 的实例，这两个变量都备受设定为 <code>nil</code>：</p>

<pre><code class="language-swift">var john: Person?
var unit4A: Apartment?
</code></pre>

<p>现在可以创建特定的 <code>Person</code> 和 <code>Apartment</code> 实例，并将它们赋值给 <code>john</code> 和 <code>unit4A</code> 变量：</p>

<pre><code class="language-swift">john = Person(name: &quot;John Appleseed&quot;)
unit4A = Apartment(unit: &quot;4A&quot;)
</code></pre>

<p>下面一段代码将这两个实例关联起来：</p>

<pre><code class="language-swift">john!.apartment = unit4A
unit4A!.tenant = john
</code></pre>

<p>将两个实例关联在一起后，强引用的关系如图所示：</p>

<p><img src="media/14824093902273/14607053938205.jpg" alt="14607053938205"/></p>

<p>这两个实例关联之后，会产生一个循环强引用，当断开 <code>john</code> 和 <code>unit4A</code> 所持有的强引用时，引用计数器并不会归零，所以这两块空间也得不到释放，这就导致了内存泄漏。</p>

<p>可以将其中一个类中的变量设定为 <code>weak</code> 弱引用来打破这种强引用循环：</p>

<pre><code class="language-swift">class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}
</code></pre>

<p><img src="media/14824093902273/14607057294969.jpg" alt="14607057294969"/></p>

<p>当断开 <code>john</code> 和 <code>unit4A</code> 所持有的强引用时，<code>Person instance</code> 的引用计数器变成 0，实例被销毁，从而 <code>Apartment instance</code> 的引用计数器也变为 0，实例被销毁。</p>

<p><strong>什么时候使用 <code>weak</code>？</strong></p>

<p>当两个实例是 optional 关联在一起时，确保其中的一个使用 <code>weak</code> 弱引用，就像上面所说的那个例子一样。</p>

<p><strong><code>unowned</code> 无主引用</strong></p>

<p>在某些情况下，声明的变量总是有值得时候，我们需要使用 <code>unowned</code> 无主引用。</p>

<p>同样借用一下 TSPL 中的例子：</p>

<pre><code class="language-swift">class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}
</code></pre>

<p>这里定义了两个类，<code>Customer</code> 和 <code>CreditCard</code>，模拟了银行客户和客户的信用卡，在这个例子中，每一个类都是将另一个类的实例作为自身的属性，所以会产生循环强引用。</p>

<p>和之前那个例子不同的是，<code>CreditCard</code> 类中有一个非可选类型的 <code>customer</code> 属性，因为，一个客户可能有或者没有一张信用卡，但是一张信用卡总是关联着一个用户。</p>

<pre><code class="language-swift">var john: Customer?
john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>

<p>关联两个实例后，它们的引用关系如图所示：</p>

<p><img src="media/14824093902273/14607068387297.jpg" alt="14607068387297"/></p>

<p>当断开 <code>john</code> 变量持有的强引用时，再也没有指向 <code>Customer</code> 的强引用了，所以该实例被销毁了，其后，再也没有指向 <code>CreditCard</code> 的强引用了，该实例也被销毁了。</p>

<p><strong>什么时候使用 <code>unowned</code> 无主引用？</strong></p>

<p>两个实例 A 和 B，如果实例 A 必须在实例 B 存在的前提下才能存在，那么实例 A 必须用 <code>unowned</code> 无主引用指向实例 B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。</p>

<p>例如上面那个例子所说，银行客户可能没有信用卡，但是每张信用卡总是绑定着一个银行客户，所以信用卡这个类就需要用 <code>unowned</code> 无主引用。</p>

<p><strong>无主引用以及隐市解析可选属性</strong></p>

<p>还有一种情况，两个属性都必须有值，并且初始化完成之后永远不会为 <code>nil</code>。在这种情况下，需要一个类使用 <code>unowned</code> 无主引用，另一个类使用<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选属性</a>。</p>

<p><strong>闭包引起的循环强引用</strong></p>

<p>在 Swift 中，闭包和函数都属于引用类型。并且闭包还有一个特性：可以在其定义的上下文中捕获常量或者变量。所以，在一个类中，闭包被赋值给了一个属性，而这个闭包又使用了这个类的实例的时候，就会引起循环强引用。</p>

<p>Swift 提供了一种方法来解决这个问题：闭包捕获列表（closure capture list）。在定义闭包的同时定义捕获列表作为闭包的一部分，捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例之间的循环强引用一样，声明每个捕获的引用为弱引用或者无主引用。</p>

<p>捕获列表中的每一项都由一对元素组成，一个元素是 <code>weak</code> 或者 <code>unowned</code> 关键字，另一个元素是类实例的引用（例如最常见得是 <code>self</code>），这些在方括号内用逗号隔开。</p>

<p>具体的使用方法请参考<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/16_Automatic_Reference_Counting.html#resolving_strong_reference_cycles_for_closures">官方文档</a>。</p>

<p><strong>何时使用 <code>weak</code>，何时使用 <code>unowned</code></strong></p>

<p>在闭包和捕获的实例总是相互引用并且总是同时销毁的时候，将闭包内的捕获定义为 <code>unowned</code> 无主引用。</p>

<p>在被捕获的实例可能变成 <code>nil</code> 的情况下，使用 <code>weak</code> 弱引用。如果被捕获的引用绝对不会变成 <code>nil</code>，应该使用 <code>unowned</code> 无主引用，而不是 <code>weak</code> 弱引用。</p>

<p><strong>Garbage Collection（GC，垃圾回收）</strong></p>

<p>其实 ARC 应该也算 GC 的一种，不过我们一谈到 GC，大多都会想到 Java 中的垃圾回收机制，相比较 GC，ARC 简单得许多。以后有机会可以讨论一下 Java 中的内存管理。</p>

<p>另外，需要注意的一点是，这里所讲的都是针对于<code>引用类型</code>，<code>结构体</code>和<code>枚举</code>在 Swift 中属于值类型，不在 ARC 的考虑范围之内。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/4/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14824093902273.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14824089876210.html">
                
                  <h1>更有效率的程序员（一）：时间记录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>两年前，曾经写过一篇有关时间管理的<a href="http://forrestchang.github.io/2014/02/12/time-management/">文章</a>，那个时候还在上高二，对于时间管理仅仅是有一点肤浅的了解，自然写出来的文字也是比较幼稚的。经过两年的实践，积累了很多时间管理的经验，想要拿出来分享一下。预计会写一个系列，包括使用的工具和日常的 Workflow。</p>

<p>日常使用的工具有这些：</p>

<ul>
<li>纸质笔记本（Moleskine）</li>
<li>OmniFocus</li>
<li>Evernote</li>
<li>Toggl</li>
</ul>

<p>这篇文章从题目也可以看出来，主要讲一些关于时间记录的内容，对应的工具是 Toggl。关于 Toggl，我已经在知乎的<a href="https://www.zhihu.com/question/36546814/answer/69161024">一个回答</a>里面推荐过了，这里会更加详细地介绍一下使用流程，在谈论术之前，先来说说道的问题，为什么要做时间记录。</p>

<p>其实我们对时间是很不敏感的，相信你一定有过这样的体验：早晨醒来，干劲满满，准备打开电脑把昨天没有写完的代码解决，这时想到邮件还没看，先查一下邮件吧，反正花不了多少时间，在查看邮件的时候又发现知乎上有人给你发私信了，在到知乎上看一下私信，顺便回复一下，既然上了知乎，那么去首页看看订阅的内容里面有没有什么有意思的东西吧，看到一个有意思的回答，是推荐你买买买的，于是乎又打开淘宝看了看商品的具体情况，顺便加到购物车里，这是候发现已经中午了，算了，先去吃饭吧，代码等等吃完饭再写，吃过午饭后又觉得有一点困意，那就睡一会儿吧，一觉醒来，发现已经四点多了，不行了，赶紧写代码，等等，这个 bug 好像找不到问题所在啊，算了，去 Stack Overflow 上找找吧，在 Stack Overflow 上找到了答案，链接到一篇具体的解释文章，点进去看了看，发现太长了，还是先加到 Pocket 中，以后再看吧，这个人的博客似乎写得不错，浏览一下 Archive 页面看看还有没有其他的好文章，从头到尾浏览了一遍，心中不禁惊叹，写得真好！然后想到今天 Reddit 好像还没看，说不定又有什么好东西，于是又上 /r/programming 刷了一会儿，看到了几篇牛逼的文章，时间也不早了，该吃晚饭了，吃完晚饭自然又不想写代码，休息一会儿，逛一下 Bilibili 吧，看了几个视频之后突然想到今天的代码还没有写，于是又接着关掉网页去写代码，搞到深夜，终于把代码写完了，朋友圈发一条状态「奋战到深夜，终于把代码改完了！」。</p>

<p>多么充实的一天，你这样想到，今天似乎做了很多事情。但是实际上呢？有效的时间几乎只有两三个小时。所以你需要把做什么事用了多长时间记录下来，然后就会发现这「充实」的一天过得是多么可怕了。</p>

<p>根据这些时间的时间记录的经验来看，至少有以下三点好处：</p>

<ol>
<li>提高对时间的感知能力，发现和避免时间黑洞。记录下时间的时候，你会刻意地关注目前手上正在做的事，如果是一些浪费时间的事，会使你减少花在上面的时间。</li>
<li>更好地制定计划。有段时间给自己制定的计划老是不能够完成，目标定得太高，再怎么跳也抓不到，通过记录一些事情所花费的时间，就可以更好地做计划，比如说看完一本书需要用多少时间。</li>
<li>激励自己。积累了一段时间的数据之后，就可以看到在某一方面投入了多少时间了，根据 10000 小时定律，可以知道自己与专家级别的能力还相差多少。</li>
</ol>

<p>当然，凡事有利就必有弊。</p>

<ol>
<li>时间记录本身也会花费时间（可以通过工具来弥补）。</li>
<li>最开始的时候总是会忘记记录。</li>
<li>事无巨细地记录时间，增加压力（这一点会在下面详细说明）。</li>
</ol>

<p>简单地讲了一下「道」层面的问题，想要继续深入的可以看一下<a href="https://book.douban.com/subject/1115353/">《奇特的一生》</a>这本书。下面说一说「术」的层面。</p>

<h3 id="toc_0">简单的系统</h3>

<p>其实最开始的时候一支笔、一本本子、一块手表就够了，这一阶段主要是养成时间记录的习惯，当然使用 Evernote 或者 OneNote 之类的软件也是可以的。可以按照以下的模板来记录：</p>

<blockquote>
<p>2016/04/10<br/>
7:00 - 8:30 阅读 xxx xx 页（1h30min）<br/>
9:00 - 9:45 完成 xxx 项目 xx 功能的开发（45min）<br/>
...</p>

<p>总结：<br/>
编程时间：xx h xx min<br/>
阅读时间：xx h xx min<br/>
有效时间合计：xx h xx min<br/>
娱乐时间：xx h xx min<br/>
...</p>
</blockquote>

<p>具体的分类可以根据自己的需求来进行。如果对时间记录没有接触过的同学可以选择这个方法试着用一段时间，看有没有什么改变。</p>

<h3 id="toc_1">Toggl</h3>

<p>前面说了这么多，中与引来了今天的主角：<a href="https://www.toggl.com/">Toggl</a>。什么是 Toggl，简单得来说，是一款时间记录的工具，试用过市面上几乎所有时间记录的工具，发现 Toggl 是最符合《奇特的一生》中的工作流的。</p>

<h4 id="toc_2">安装</h4>

<p>Toggl 几乎包含了全部平台，其中最强大的属于 Web 版，各种高级的报表功能需要在 Web 版上面才能试使用。</p>

<ul>
<li><a href="https://www.toggl.com/best-free-time-tracking-app-for-iphone">iPhone App</a></li>
<li><a href="https://www.toggl.com/best-free-time-tracking-app-for-android">Android App</a></li>
<li><a href="https://support.toggl.com/toggl-desktop-for-windows">Windows Desktop App</a></li>
<li><a href="https://support.toggl.com/toggl-desktop-for-mac-osx">Mac Desktop App</a></li>
<li><a href="https://support.toggl.com/toggl-desktop-for-linux">Linux Desktop App</a></li>
</ul>

<p>并且它还提供了 <a href="https://github.com/toggl/toggl_api_docs/blob/master/toggl_api.md">API</a>，可以自由定制。</p>

<h4 id="toc_3">基本使用</h4>

<p>下面主要介绍 Web 版的内容。注册完登陆进计时页面就是如下图所示：</p>

<p><img src="media/14824089876210/14602871668402.jpg" alt="14602871668402"/></p>

<ol>
<li>你当前正在记录的内容（如果不确定，可以先不填，这个是比其他软件优秀的原因之一，有时候只是想先记录下时间，之后再进行区分）；</li>
<li>当前记录内容所属分类，可以添加 Tag，后面的美元符号可以添加这个任务的花费，基本没有用到过这个功能；</li>
<li>记录的时间，可以手动添加时间；</li>
<li>Timeline，每天做了什么事情用了多少时间就记录在这里（周六周日没有怎么使用，所以比较空）；</li>
<li>一周记录时间汇总。</li>
</ol>

<p>知道了以上的内容之后就可以开始记录了，比如说就把学习 Toggl 的使用当成第一个记录的内容。</p>

<h4 id="toc_4">更好的分类</h4>

<p>详细的分类可以更好地输出报表。我使用的是三级的分类：大类-具体领域分类-task。Toggl 默认只可以使用两个层级的分类，Project - Task，但是可以把 Client 这个用作最大的分类，这样就可以进行三个层级的分类，下面是我的分类内容；</p>

<ul>
<li>基本工作（Client）

<ul>
<li>计算机（Project）</li>
<li>英语</li>
<li>健身</li>
<li>写作</li>
<li>阅读</li>
<li>工作（几乎用不到，因为还在学校里）</li>
</ul></li>
<li>固定日程

<ul>
<li>上课</li>
<li>睡觉</li>
<li>杂事</li>
</ul></li>
<li>娱乐

<ul>
<li>上网</li>
<li>游戏</li>
<li>视频/电影</li>
</ul></li>
</ul>

<p>分级不宜过多，否则会增加选择的压力，可以在使用的过程中不断改进。</p>

<p>最大的类别（Clients）可以在 Workspace Settings 中添加：</p>

<p><img src="media/14824089876210/14602879238718.jpg" alt="14602879238718"/></p>

<p>Project 的类别在 Projects 选项中添加，可以给每个 Project 不同的颜色以示区分。</p>

<p>Tag 很少使用，可以为一些相同类型的事情设定相关的 Tag 来作为补充。</p>

<h4 id="toc_5">强大的统计功能</h4>

<p>使用纸笔做时间记录的麻烦之处就是统计的时候需要花费很多精力去计算，用 APP 就可以免除这些过程，直接根据记录的内容生成非常漂亮的报表，下面的是我这一周的统计内容，从柱状图可以看出这周的效率是逐渐递减的-_-|||</p>

<p><img src="media/14824089876210/14602882623445.jpg" alt="14602882623445"/></p>

<p>Reports 支持三种模式：Summary, Detailed, Weekly。上面的是 Summary 的 Reports，Detailed 会把你做的所有事情列出来，Weekly 会以周视图的方式来显示：</p>

<p><img src="media/14824089876210/14602884725256.jpg" alt="14602884725256"/></p>

<p>Reports 支持强大的过滤功能，可以根据需要选择 Reports 的时间长度、Project 内容、Tag 内容等等。比如说我想查看这周用在 iOS Dev 上的时间是多少，只需要选择 iOS Dev 这个 Tag 就可以了：</p>

<p><img src="media/14824089876210/14602886317764.jpg" alt="14602886317764"/></p>

<h4 id="toc_6">Dashboard</h4>

<p>Toggl 还提供了仪表盘视图，在这里你可以看到最常 Track 的项目以及一些其他内容。</p>

<p><img src="media/14824089876210/14602889789430.jpg" alt="14602889789430"/></p>

<p>如果在本地 APP 里面打开了 Timeline Track，还可以在 Timeline For Today 这一栏里面查看使用了什么软件，用了多长时间。</p>

<h4 id="toc_7">Workflow</h4>

<p>每天从 Todo 里面拿出一件事情，打开计时器，开始做，本着「做一件事情就把它做好的原则」去完成。积累了一段时间的数据之后，就可以更好地计划自己了，比如说本周阅读多少专业书籍，写多少代码。具体的 Workflow 需要结合 OmniFocus 和笔记本来完成，所以会在下一篇文章中来说明。</p>

<h4 id="toc_8">FAQ</h4>

<h5 id="toc_9">什么事情都需要记录吗？</h5>

<p>只需要记录重要的事情。日常生活中的吃喝拉撒记录了没有任何用处，有一段时间我一直在记录自己的睡眠时间，不过后来固定了之后就不记录了。</p>

<h5 id="toc_10">忘了记录怎么办？</h5>

<p>这个只能慢慢地养成记录的习惯，如果记得大概的时间的话，可以手动录入时间。</p>

<h5 id="toc_11">手边没有电脑怎么办？</h5>

<p>一般我都是用手机进行记录，如果连手机也不在手边的话，可以先拿张纸记着，之后再手动录入上去。</p>

<h3 id="toc_12">后记</h3>

<p>其实，等你做了一段时间的时间日志会发现，会发现效率并没有提高多少，有时候不得不承认这个悲伤的事实，根据自己的时间日志，最高效的一天记录了 7 个小时的学习时间，相比较那些动不动就每天学习 8 小时的人来说，还是差太多了，不过好歹也算是做出了一点点努力。</p>

<p>写这篇文章的契机是看到了 pluskid 写的<a href="http://freemind.pluskid.org/misc/knowledge-accumulate/">《关于知识整理、积累与记忆》</a>，想到自己也有挺多经验可以分享的，于是便以试试的心态动笔开始写。</p>

<p>仓促成文，错误在所难免，还望指正。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/4/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='productivity.html'>Productivity</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14824089876210.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="linux-basic.html">
                
                  <h1>Linux 基础笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Shell 的基本操作</h2>

<h3 id="toc_1">常用快捷键</h3>

<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Tab</code></td>
<td>命令补全</td>
</tr>
<tr>
<td><code>Ctrl+c</code></td>
<td>强行终止当前程序</td>
</tr>
<tr>
<td><code>Ctrl+d</code></td>
<td>键盘输入结束或退出终端</td>
</tr>
<tr>
<td><code>Ctrl+s</code></td>
<td>暂定当前程序，暂停后按下任意键恢复运行</td>
</tr>
<tr>
<td><code>Ctrl+z</code></td>
<td>将当前程序放到后台运行，恢复到前台命令 <code>fg</code></td>
</tr>
<tr>
<td><code>Ctrl+a</code></td>
<td>将光标移动到行首</td>
</tr>
<tr>
<td><code>Ctrl+e</code></td>
<td>将光标移动到行尾</td>
</tr>
<tr>
<td><code>Ctrl+k</code></td>
<td>删除从光标所在位置到行末</td>
</tr>
<tr>
<td><code>Alt+Backspace</code></td>
<td>向前删除一个单词</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">常用通配符</h3>

<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>*</code></td>
<td>匹配0或多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配 list 中的任意单一字符</td>
</tr>
<tr>
<td><code>[!list]</code></td>
<td>匹配除 list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td><code>[c1-c2]</code></td>
<td>匹配c1-c2中的任意单一字符，如[0-9][a-z]</td>
</tr>
<tr>
<td><code>{string1,string2,...}</code></td>
<td>匹配其中一个字符串</td>
</tr>
<tr>
<td><code>{c2..c2</code></td>
<td>匹配c1-c2中全部字符，如{1..10}</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">用户管理</h2>

<h3 id="toc_4">查看用户</h3>

<pre><code>$ who am i
</code></pre>

<p>或者</p>

<pre><code>$ who mon likes
</code></pre>

<p><code>who</code> 命令其他常用参数</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-a</code></td>
<td>打印能打印的全部</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>打印死掉的进程</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>同 <code>am i</code>, <code>mom likes</code></td>
</tr>
<tr>
<td><code>-q</code></td>
<td>打印当前登陆用户数及用户名</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>打印当前登陆用户登陆信息</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>打印运行等级</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">创建用户</h3>

<p>创建用户需要 <code>root</code> 用户的权限，所以需要使用 <code>sudo</code> 这个命令。使用 <code>sudo</code> 名利需要满足两个条件：</p>

<ol>
<li>知道当前登陆用户的密码</li>
<li>当前用户必须在 <code>sudo</code> 用户组</li>
</ol>

<pre><code>$ su &lt;user&gt; # 切换用户到 user
</code></pre>

<pre><code>$ sudo &lt;cmd&gt; # 以 root 权限运行命令
</code></pre>

<pre><code>$ su - &lt;user&gt; # 切换用户，并且环境变量同时改变到目标用户的环境变量
</code></pre>

<p>新建用户命令：</p>

<pre><code>$ sudo adduser &lt;username&gt;
</code></pre>

<p>创建用户的同时会为用户创建 home 目录。</p>

<h3 id="toc_6">用户组</h3>

<p>在 Linux 中每个用户都有一个用户组，它们共享一些资源和权限，同时拥有私有资源。</p>

<h4 id="toc_7">查看自己的用户组</h4>

<pre><code>$ groups &lt;username&gt;
</code></pre>

<p>或者，查看<code>/etc/group</code>文件</p>

<pre><code>$ cat /etc/group | sort
</code></pre>

<p><code>sort</code> 表示将读取的文本进行一个字典排序再输出。</p>

<h5 id="toc_8"><code>etc/group</code> 文件格式说明</h5>

<p>/etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：</p>

<blockquote>
<p>group_name:password:GID:user_list</p>
</blockquote>

<h4 id="toc_9">将其他用户加入 sudo 用户组</h4>

<p>使用 <code>usermod</code> 命令可以为用户组添加用户，使用该命令需要有 root 权限。</p>

<p>使用一个具有 root 权限的用户为一个不具有 root 权限的用户添加 <code>sudo</code> 权限：</p>

<pre><code>$ sudo usermod -G sudo &lt;username&gt;
</code></pre>

<h3 id="toc_10">删除用户</h3>

<pre><code>$ sudo deluser &lt;username&gt; --remove-home
</code></pre>

<h2 id="toc_11">文件权限</h2>

<h3 id="toc_12">查看文件权限</h3>

<pre><code>$ ls -l
</code></pre>

<p><img src="media/14587025785185/14587048876862.jpg" alt=""/></p>

<p><img src="media/14587025785185/14587049042865.jpg" alt=""/></p>

<p><img src="media/14587025785185/14587049141674.jpg" alt=""/></p>

<h4 id="toc_13">文件类型</h4>

<p>Linux 里面一切皆文件。</p>

<h4 id="toc_14">文件权限</h4>

<ul>
<li>读权限：可以读取某个文件的内容</li>
<li>写权限：可以编辑和修改某个文件</li>
<li>执行权限：通常指可以运行的二进制程序文件或者脚本文件</li>
</ul>

<p>注：一个目录要同时具有读权限和执行权限才可以打开，要有写权限才允许在其中创建其他文件。Linux 不是用过文件的后缀名来区分文件的类型。</p>

<h4 id="toc_15">链接数</h4>

<p>链接到该文件所在的 inode 结点的文件名数目。</p>

<h3 id="toc_16">修改文件权限</h3>

<h4 id="toc_17">方法1：二进制数字表示</h4>

<p><img src="media/14587025785185/14587054006459.jpg" alt=""/></p>

<p>修改<filename>只能自己使用：</p>

<pre><code>$ chmod 700 &lt;filename&gt;
</code></pre>

<h4 id="toc_18">方法2：加减赋值操作</h4>

<pre><code>$ chmod go-rw &lt;filename&gt;
</code></pre>

<p>&#39;g&#39;&#39;o&#39;还有&#39;u&#39;，分别表示group，others，user，&#39;+&#39;，&#39;-&#39; 就分别表示增加和去掉相应的权限。</p>

<h2 id="toc_19">目录结构</h2>

<p>Windows 是以存储介质为主的，之下才是目录；而 Unix 是以目录为主的，存储介质是挂载在目录上的。Linux 以树形目录结构的形式来构建整个系统。</p>

<h3 id="toc_20">FHS 标准</h3>

<blockquote>
<p>FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。</p>
</blockquote>

<p>FHS 定义了两层规范，第一层是，/下面的各个目录应该要放什么文件数据，例如 /etc 应该要放设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。</p>

<p>第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件，/usr/share 放置共享数据等等。</p>

<p><img src="media/14587025785185/14587064442333.jpg" alt=""/></p>

<p>FSH 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会持续更新，FSH 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四中交互作用的形态，如下表示：</p>

<p><img src="media/14587025785185/14587065471253.jpg" alt=""/></p>

<h3 id="toc_21">目录路径</h3>

<h4 id="toc_22">绝对路径</h4>

<p>以根目录为起点的完整路径。</p>

<h4 id="toc_23">相对路径</h4>

<p>相对于你当前目录的路径。</p>

<h2 id="toc_24">文件的基本操作</h2>

<h3 id="toc_25">新建</h3>

<h4 id="toc_26">新建空白文件</h4>

<pre><code>$ touch test
</code></pre>

<p>关于 <code>touch</code> 命令，其主要是用来更改文件时间戳的。</p>

<h4 id="toc_27">新建目录</h4>

<pre><code>$ mkdir testDir
</code></pre>

<p>使用 <code>-p</code> 参数，可以创建一个多级目录，例如：</p>

<pre><code>$ mkdir -p father/son/grandson
</code></pre>

<h3 id="toc_28">复制</h3>

<h4 id="toc_29">复制文件</h4>

<pre><code>$ cp test testDir
</code></pre>

<h4 id="toc_30">复制目录</h4>

<pre><code>$ cp -r father family
</code></pre>

<h3 id="toc_31">删除</h3>

<pre><code>$ rm test
</code></pre>

<p>参数 <code>-f</code> 可以强制删除一些为只读权限的文件。</p>

<pre><code>$ rm -f test
</code></pre>

<p>删除一个目录：</p>

<pre><code>$ rm -r testDir
</code></pre>

<h3 id="toc_32">移动文件</h3>

<pre><code>$ mv testFile testDir
</code></pre>

<h3 id="toc_33">重命名文件</h3>

<p><code>mv</code> 命令还有重命名的作用：</p>

<pre><code>$ mv oldName newName
</code></pre>

<h3 id="toc_34">查看文件</h3>

<h4 id="toc_35"><code>cat</code> 与 <code>tac</code></h4>

<p>这两个命令都是用来打印文件内容到标准输出（终端），其中<code>cat</code> 为正序显示，<code>tac</code> 为倒序显示。</p>

<blockquote>
<p>标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘；标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。</p>
</blockquote>

<p>可以使用<code>-n</code> 参数来显示行号：</p>

<pre><code>$ cat -n &lt;filename&gt;
</code></pre>

<h4 id="toc_36"><code>nl</code></h4>

<p>添加行号并打印，比 <code>cat</code> 更加强大，参数说明：</p>

<pre><code>-b : 指定添加行号的方式，主要有两种：
    -b a:表示无论是否为空行，同样列出行号(&quot;cat -n&quot;就是这种方式)
    -b t:只列出非空行的编号并列出（默认为这种方式）
-n : 设置行号的样式，主要有三种：
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示，且不加 0
    -n rz:在行号字段最右边显示，且加 0
-w : 行号字段占用的位数(默认为 6 位)
</code></pre>

<h3 id="toc_37">查看文件类型</h3>

<p>使用 <code>file</code> 命令来查看文件类型：</p>

<pre><code>$ file /bin/ls
</code></pre>

<p><img src="media/14587025785185/14587183045128.jpg" alt=""/></p>

<p>这表示这是一个可执行文件。</p>

<h2 id="toc_38">环境变量</h2>

<h3 id="toc_39">变量</h3>

<p>使用<code>declare</code>命令可以创建一个变量：</p>

<pre><code>$ declare tmp
</code></pre>

<p>读取变量的值，使用<code>echo</code>命令和<code>$</code>符号：</p>

<pre><code>$ echo $tmp
</code></pre>

<h3 id="toc_40">环境变量</h3>

<p>环境变量就是作用域比自己定义的变量要大，如 Shell 的环境变量作用于自身和它的子进程。例如 Shell 环境变量作用于自身和它的子进程。在类 UNIX 系统中，每个进程都有其各自的环境变量设置，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。</p>

<p>通常我们会涉及到的环境变量有三种：</p>

<ul>
<li>当前 Shell 进程私有用户自定义变量，只在当前 Shell 中有效</li>
<li>Shell 本身内建的变量</li>
<li>从自定义变量导出的环境变量</li>
</ul>

<p><code>set</code>, <code>env</code>, <code>export</code>这三个命令可以用来打印相关环境变量，区别在于涉及的是不同范围的环境变量：</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>set</code></td>
<td>显示当前 shell 所有环境变量，包括其内建环境变量、用户自定义变量及导出的环境变量</td>
</tr>
<tr>
<td><code>env</code></td>
<td>显示与当前用户相关的环境变量，还可以让命令在制定环境中运行</td>
</tr>
<tr>
<td><code>export</code></td>
<td>显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量</td>
</tr>
</tbody>
</table>

<p><img src="media/14587025785185/14592405427797.jpg" alt=""/></p>

<h3 id="toc_41">命令的查找路径与顺序</h3>

<p>Shell 通过环境变量<code>PATH</code>来搜索命令。</p>

<p>查看 <code>PATH</code> 环境变量的内容：</p>

<pre><code>$ echo $PATH
</code></pre>

<p>输出的内容为：</p>

<pre><code>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
</code></pre>

<p>这些目录下面存放的都是可执行文件。</p>

<h3 id="toc_42">添加自定义路径到<code>PATH</code> 环境变量</h3>

<p><code>PATH</code>里面的路径是以<code>:</code>作为分隔符，所以可以这样添加自定义路径：</p>

<pre><code>$ PATH=$PATH:/home/xxxx
</code></pre>

<p>注意到这里一定要使用绝对路径。</p>

<p>这种修改的方式只对当前的 Shell 有效，要想让每个用户都讷讷够使用，需要更改相应的配置文件，例如<code>zsh</code>需要修改相应的<code>.zshrc</code>。</p>

<h3 id="toc_43">修改和删除已有变量</h3>

<p>可以使用<code>unset</code>命令来删除一个环境变量：</p>

<pre><code>$ unset temp
</code></pre>

<h3 id="toc_44">如何让环境变量立即生效</h3>

<p>在修改了配置文件后，可以使用<code>source</code>命令来让其立即生效：</p>

<pre><code>$ source .zshrc
</code></pre>

<h2 id="toc_45">搜索文件</h2>

<h3 id="toc_46"><code>whereis</code>简单快速</h3>

<pre><code>$ whereis who
</code></pre>

<p><code>whereis</code>只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。</p>

<h3 id="toc_47"><code>locate</code>快而全</h3>

<p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行<code>updatedb</code>命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次<code>updatedb</code>命令。他可以用来查找指定目录下的不同文件类型，例如查找/usr/share/下所有的 jpg 文件：</p>

<pre><code>$ locate /usr/share/\*.jpg
</code></pre>

<p>注意要添加<code>*</code>号前面的反斜杠转义，否则会无法找到</p>

<h3 id="toc_48"><code>which</code>小而精</h3>

<p>我们通常使用<code>which</code>来确定是否安装了某个指定的软件，因为它只从<code>PATH</code> 环境变量指定的路径中去搜索命令：</p>

<pre><code>$ which man
</code></pre>

<h3 id="toc_49"><code>find</code> 精而细</h3>

<p><code>find</code>命令应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找，而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p>

<p>在指定目录下搜索指定文件名的文件：</p>

<pre><code>$ find /etc/ -name interface
</code></pre>

<p><code>find</code> 命令的基本参数格式为：<code>find [path] [option] [action]</code></p>

<p>与时间相关的命令参数：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-atime</code></td>
<td>最后访问时间</td>
</tr>
<tr>
<td><code>-ctime</code></td>
<td>创建时间</td>
</tr>
<tr>
<td><code>-mtime</code></td>
<td>最后修改时间</td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/3/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='technology.html'>Tech</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/linux-basic.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14824076959660.html">
                
                  <h1>2016 Week 12 Review</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>这周是2016年的第12周，上一周没有写 Roundup。</p>

<p>这周的主题是<code>跑步</code>，大连的天气开始变暖，终于可以去操场跑步了，不过由于学校在海边，风还是很大的。今天跑完了一个线上马拉松（10km 健康赛），明天大连国际马拉松开始开放报名，打算参加半程马拉松，不知道能不能报上名，毕竟今年有一个目标就是参加一次马拉松（全马或者半马）。比赛日期是5.22，需要利用剩余的两个月的时间积累一下跑量（一周跑5次，每次10km）。</p>

<p>编程方面，本来打算利用 Flask 写一个网站的，结果拖到今天 Document 也只看了一点点，很显然只能移到下一周来完成了，除了这个就改了改之前写的一些代码。从上周开始看 CSAPP 这本书，看的时候顺带做习题（所有的题目），所以进度很慢，大概每天几页的样子，CMU 的几个 lab 还没有开始做，等看完一部分就去完成这部分的 lab。</p>

<p>阅读方面，没有读任何书，大部分的时间还是用在了浅阅读上，比如看知乎和 Quora 上的各种问答，阅读别人写的博客之类的。下周的目标是读完《你的灯亮着吗》这本书。</p>

<p>这周没怎么背单词，现在想是否真的要去考托福了，因为自己的 GPA 有点低，即使有 TOEFL 成绩也申请不上好的学校。不过即使是不考 TOEFL，英语还是要学的。</p>

<p>再一次地更换了博客的 Generator，这次还换成了 Hexo，用 Atom 来写作，之前还在<a href="http://forrestchang.github.io/2016/02/13/self-learning-guide/">一篇文章</a>中黑过 Atom，没想到这么快就叛逃了，23333 。不过还是得吐槽一下，我装了不少 Package，打开的时候真的是好卡，还掉帧，优化做得确实太渣了，要不是你 UI 漂亮，插件丰富，肯定不用你！转移的过程中没有转移评论内容，因为看了一下 Disqus 中的评论，太乱了（因为之前切换过好几次），转移起来有点麻烦，索性直接不要了，反正评论也不是很多。另外 RSS 地址可能有点变化，如果使用 RSS 阅读器的同学可能需要更新一下 RSS 地址（搞得好像真的有人看似的）。</p>

<p>马上23：00了，赶紧去睡觉了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/3/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='life.html'>Life</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14824076959660.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14824082548997.html">
                
                  <h1>Apple Music，古典音乐，阅读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">Apple Music</h3>

<p>自从Apple Music（以下简称「AM」）发布以来，就一直在使用，从最开始的免费试用到现在每个月10￥的订阅。自从Windows时代就使用iTunes听音乐了（当时有一部iPod），在没有AM的时候，都是从论坛下好别人买的专辑来听。一方面在国内想要在iTunes Store上购买专辑过于麻烦（两个账号需要来回切换），另一方面作为一个学生党iTunes Store上两首歌就相当于一顿饭的价钱对于我来说也有点小贵了，所以AM刚推出的时候，还是比较开心的，没想到入华后价格竟然只要10￥每月，就只相当于两首歌的钱！</p>

<p>这几个月使用下来，发现还是存在不少的问题。</p>

<ol>
<li>操作逻辑复杂。例如听到一首好听的歌，标注了心之后，它是不会出现在你的播放列表中的，因为标注心只是为了优化推荐的算法。所以每次听到一首好听的曲子，都要进行两个步骤：先添加到库中，再标注心。这样才会在你的Smart Playlist中显示出来。这个估计是iTunes的遗留问题，因为iTunes是以Library的方式来管理的，所以需要先添加进Library中，才能进行进一步的操作，不过AM作为一个流媒体音乐服务，这样做显然是多此一举了。</li>
<li>每个设备间同步存在问题。我一般都是在Mac上听音乐，不过偶尔也会使用iPhone来听，但是很多加心得歌曲到了iPhone上面就变成没有加心的了。所以现在我也懒得使用iPhone来听歌了，或者就随便打开一个推荐的播放列表来听。</li>
<li>网络问题。这个应该是最要吐槽的一点了，听歌时断时续是最不能忍的事情了。不知道是Apple在国内没有设置服务器还是什么其他原因，有时候即使开着代理缓冲的速度也很慢。有些专辑就只能先下载下来，然后再听。</li>
</ol>

<p>这是我使用过程中遇到的三个比较影响体验的问题，当然还有其他小的，比如说什么中文歌的名字全是英文（使用英文系统的原因，日文歌的名字全是罗马音等等之类的，只不过这些暂时还能够忍受，不是太影响听音乐的体验（个人很少听中文和日文的歌曲）。</p>

<p>作为一个数据控，如果听歌的数据不能够记录下来，那么就好像和没听一样（强迫症的症状），虽然iTunes也可以记录歌曲的播放次数，上一次播放时间之类的数据，不过还是过于简单了。之前一直使用的是Last.fm，使用AM了之后发现Last.fm的客户端没办法抓取到数据了，后来找到了「Bowtie」这个小工具，连Radio中播放的内容都能够抓取到，太强大了。分析一首歌听了多少遍的意义并不是很大，但是累计了这么多的数据之后还是可以发现了一些有趣的东西的，比如说我听的最多的歌手是竟然是「ColdPlay」。</p>

<p>如果作为一个音乐服务来说，AM还存在着很多问题，不过毕竟还是一个新生的流媒体服务，希望下一次大的更新之后能够提高一些用户体验。</p>

<p>PS. 也使用过一段时间的Xiami和网易云音乐，因为种种原因放弃了。</p>

<h3 id="toc_1">古典音乐</h3>

<p>关于古典音乐，其实我只有很少的了解，也只听过很少的入门曲目，最开始听古典是因为「The 50 Most Essential Pieces of Classical Music」这张专辑，这张专辑里面基本上都是一些非常经典的曲目，例如当初看《V字仇杀队》中的「1812 Festival Overture」，以及每个人都熟悉的「Canon in D Major」，如果从来没听过古典，推荐去听一下这个专辑，一定会发现很多熟悉的音乐。</p>

<p>上学期选修了一门《西方古典音乐鉴赏》，然而并没有很认真地听课，不过还是了解了一些知识。然后看了木遥在博客上的一系列<a href="http://blog.farmostwood.net/305.html">介绍古典音乐的文章</a>，算是对古典音乐有了一个初步的认识。</p>

<p>如果说是欣赏古典音乐，还是达不到那个层次的，因为现在古典音乐的作用就是在阅读或者写代码的时候提供一个相对较安静的环境，说白了，还是出于一种功利的目的在听（为了更好地完成其他工作）。</p>

<p>今天听AM的Classical Radio听到很很多以前听过，但是忘了名字的曲子（不得不说，古典音乐的曲子名字太难记了），统统加心添加进Library中。现在听音乐的基本流程就是，先范听，听到喜欢的在去把Artist的所有作品依次听下去，这样会找到不少喜欢的内容。</p>

<h3 id="toc_2">阅读</h3>

<p>前几天Kindle上突然推送了有关Kindle Unlimited的内容，类似于AM，按月订阅，然后可以阅读所有的订阅内容。刚开始还是蛮高兴的，不过看了一下在计划中的书目，基本上没有想看的，果然想看的书还是需要付费啊。不过有7天的试用时间，不用白不用，昨天读了一本漫画书《时间管理：如何充分利用你的24小时》，很有趣的一本小册子。这个漫画好像是一个系列，准备最近把感兴趣的都看一遍。</p>

<p>最近看书的时间有点少了，而更多的时间都在看RSS订阅的内容，Pocket上存档的文章，以及知乎、Quora、Reddit、Hacker News上的一些文字。毫无疑问，书籍的信噪比肯定是大于后者之流的，如果要搞一个排名的话，信噪比的大小应该是这样的：书籍 &gt; Pocket上存档的文章 &gt; Hacker News = Reddit &gt; RSS订阅内容 &gt; Quora &gt;= 知乎（至少Quora可以练习一下英语，笑）。当然，如果你是整天阅读微信朋友圈以及QQ空间，那么信噪比可能会 &lt; 1。</p>

<hr/>

<p>以上是深夜的无聊吐槽内容，本来这段时间应该是去写代码或者阅读其他内容的，只不过因为结构化拖延的原因才来写Blog……</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/2/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='life.html'>Life</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="http://forrestchang.github.io/14824082548997.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_5.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_7.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="asset/img/avatar.jpg" /></div>
            
                <h1>Hack Notes</h1>
                <div class="site-des"></div>
                <div class="social">







<a target="_blank" class="weibo" href="http://weibo.com/tisoga" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="https://twitter.com/Tisoga" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="https://github.com/forrestchang" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:forrestchang7@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="life.html"><strong>Life</strong></a>
        
            <a href="machine-learning.html"><strong>ML</strong></a>
        
            <a href="python.html"><strong>Python</strong></a>
        
            <a href="productivity.html"><strong>Productivity</strong></a>
        
            <a href="technology.html"><strong>Tech</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14878992387553.html">换了一个新地方写东西</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14871569977647.html">Python 风格指南笔记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14832795759469.html">2017 Week 1 Review</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14827163208652.html">2016 Week 52 Review</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14824086421976.html">推荐系统笔记</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>


<script type="text/javascript">
    var disqus_shortname = 'tisogasnotes'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'tisogasnotes'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
<script>
                            var _hmt = _hmt || [];
                            (function() {
                                    var hm = document.createElement("script");
                                    hm.src = "https://hm.baidu.com/hm.js?001e800887eba2f8f57ec8059aafdad6";
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(hm, s);
                                    })();
                            </script>

  </body>
</html>
