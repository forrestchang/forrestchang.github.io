<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Lifelong Hacker</title>
    <link>http://blog.jiayuanzhang.com/categories/programming/</link>
    <description>Recent content in Programming on Lifelong Hacker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 02 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.jiayuanzhang.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>读《代码大全》</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-code-complete-part-1/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-code-complete-part-1/</guid>
      <description>这本书最开始是大一的时候买的，买回来后翻了一些章节就成为了显示器的支架，直到最近工作了一段时间才重新开始读，这一次阅读和几年前初次阅读有很大不同，大一阅读时候的编码经验仅仅是局限于算法方面，对大型项目的构建没有特别多感触；这一次是在写了很多业务代码，积累了一定问题的基础上去阅读的，阅读的深度自然不是第一次阅读可以比较的。
和这本书类似的还有一本叫做 《程序员修炼之道——从小工到专家》（我也写过 笔记）。这本书讲了很多软件工程领域的行话和规则，比如熟悉的 DRY 原则，如果觉得《代码大全》比较厚（大概九百多页），也可以先读一下这本书。
《代码大全》并不是一本需要从头到尾依次阅读的书，章节和章节之间的联系也不是很大，完全可以随便挑选感兴趣的章节来阅读。这次阅读我主要遵从书上的建议，按照以下顺序来阅读：
 第 11 章：变量名的力量 第 8 章：防御式编程 第 7 章：高质量的子程序 第 18 章：表驱动法 第 4 章：关键的「构建」决策 第 33 章：个人性格 第 32 章：自说明代码 其他章节按照顺序或者兴趣度依次阅读  这个「读《代码大全》」系列的文章主要是记录一些阅读笔记。之前的阅读笔记比较喜欢把书上的内容抄下来，但是实际上发现，「抄书」可能抄完就忘了，因为「抄」其实很简单，不需要动脑，打字快的话也不会觉得很累。这次阅读笔记主要是「问题 - 回答」的模式来写，在阅读每章之前，先提出几个问题，然后在阅读的过程中解决问题。
第 11 章：变量名的力量 问题：
 怎样给一个变量命名？ 长名字还是短名字？ 命名的最佳实践有哪些？ 有哪些常见的命名方法？ 在命名中应该要避免的东西有哪些？  怎样给一个变量命名？  通常，对变量的描述就是最佳的变量名。
 书中举了几个简单的例子，例如表示美国奥林匹克代表团成员数量的变量 numberOfPeopleOnTheUsOlympicTeam，表示某国代表团在现代奥运会上获得的最高分数的变量 maximumNumberOfPointsInModernOlympics。这种变量命名的好处是一眼就能看出这个变量表示的是什么，它们都是非常明确的。而像 nums 和 maxPoints 就相对来说没有那么明确，至于 n 和 m 这样的命名就是非常差的描述，移除了上下文根本无法理解。
这种对变量描述的命名方法也有一个缺点：变量名太长了，这一点会之后讨论。
另外一个命名的方法是「以问题为导向（Problem Orientation）」。
 一个好名字通常表达的是「什么（what）」，而不是「如何（how）」。如果一个名字反映了计算的某些方面而不是问题本省，那么它反应的就是「how」，而不是「what」了，应该避免取这样的名字。 书中也举了几个例子，例如一条员工数据记录可以称作 inputRec 或者 employeeData，inputRec 是一个反映输入、记录这些计算概念的计算机术语，二 employeeData 则直指问题领域。</description>
    </item>
    
    <item>
      <title>SFTP 使用详解</title>
      <link>http://blog.jiayuanzhang.com/post/linux-command-sftp/</link>
      <pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/linux-command-sftp/</guid>
      <description>「Linux 命令详解」这个系列的文章将会介绍 Linux/Unix/macOS 系统中使用到的常用命令，包括该命令的简单介绍、常用参数解释以及最佳实践，如果需要快速使用这个命令，直接跳到最佳实践部分即可。
「Linux 命令详解」系列文章：
 Linux命令详解：SFTP  一、介绍 SFTP（Secure File Transfer Protocol，安全文件传输协议）是一种基于可靠数据流（data stream），提供文件存取和管理的网络传输协议，它在网络协议层的结构如下图所示：
与 FTP 协议相比，SFTP 在客户端与服务器间提供了一种更为安全的文件传输方式，如果你还在使用 FTP 来进行文件传输，强烈建议切换到更为安全的 SFTP 上来。
本篇文章将会介绍 SFTP 的链接，以及在交互式命令行中的一些常用命令，并对一些参数进行解释，最后给出实际使用中的最佳实践。目前已经有很多 GUI 客户端支持 SFTP 协议，但是不在本篇文章的讨论范围之内。
二、使用 SFTP 进行连接 因为 SFTP 是基于 SSH 协议的，所以默认的身份认证方法与 SSH 协议保持一致。通常我们使用 SSH Key 来进行连接，如果你已经可以使用 SSH 连接到远程服务器上，那么可以使用以下命令来连接 SFTP：
sftp user_name@remote_server_address[:path]  如果远程服务器自定义了连接的端口，可以使用 -P 参数：
sftp -P remote_port user_name@remote_server_address[:path]  连接成功后将进入一个 SFTP 的解释器，可以发现命令行提示符变成了 sftp&amp;gt;，使用 exit 命令可以退出连接。
如果连接地址存在 path 并且 path 不是一个目录，那么 SFTP 会直接从服务器端取回这个文件。</description>
    </item>
    
    <item>
      <title>跨域资源共享（CORS）详解</title>
      <link>http://blog.jiayuanzhang.com/post/cors-tutorial/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/cors-tutorial/</guid>
      <description>Web 后端开发者很少会去充分了解跨域问题，原因是他们很少和 JavaScript 打交道。但是作为一个 Web 开发者，知道跨域请求和如何解决跨域问题可以和前端开发者在沟通上变得更为顺畅。
这篇文章会介绍和跨域请求相关的一些概念，以及如何在后端（Python）解决浏览器的跨域请求问题。
一、什么是跨域请求 首先，我们要了解什么是跨域请求。简单来说，当一台服务器资源从另一台服务器（不同的域名或者端口）请求一个资源时，就会发起一个跨域 HTTP 请求。
举个简单的例子，http://example-a.com/index.html 这个 HTML 页面请求了 http://example-b.com/resource/image.jpg 这个图片资源时（发起 Ajax 请求，非 &amp;lt;img&amp;gt; 标签），就是发起了一个跨域请求。
在不做任何处理的情况下，这个跨域请求是无法被成功请求的，因为浏览器基于同源策略会对跨域请求做一定的限制。
二、浏览器同源策略 这就引出了浏览器的同源策略（Same-origin policy），同源策略限制了从同一个源加载的文档或者脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
什么是同源？同源需要同时满足三个条件：
 请求的协议相同（例如同为 http 协议） 请求的域名相同（例如同为 www.example.com） 请求的端口相同（例如同为 80 端口）  第 2 点需要注意的是，必须是域名完全相同，比如说 blog.example.com 和 mail.example.com 这两个域名，虽然它们的顶级域名和二级域名（均为 example.com）都相同，但是三级域名（blog 和 mail）不相同，所以也不能算作域名相同。
如果不同时满足这上面三个条件，那就不符合浏览器的同源策略。
修改 document.domain 参数可以更改当前的源，例如 blog.example.com 想要访问父域 example.com 的资源时，可以执行以下 JavaScript 脚本来进行修改：
document.domain = &#39;example.com&#39;;  但是 document.domain 不能被设置为 foo.com 或者是 bar.com，因为它们不是 blog.example.com 的超级域。
当然，也不是所有的交互都会被同源策略拦截下来，下面两种交互就不会触发同源策略：</description>
    </item>
    
    <item>
      <title>读《程序员修炼之道》（二）</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-2/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-2/</guid>
      <description>重复的危害 系统中的每一项知识都必须具有单一、无歧义、权威的表示。（感觉翻译得怪怪的）
 Tip 11 DRY - Don&amp;rsquo;t Repeat Yourself 不要重复你自己
 重复是怎样发生的  强加的重复（imposed duplication）：开发者觉得他们无可选择 —— 环境似乎要求重复。 无意的重复（inadvertent duplication）：开发者没有意识到他们在重复信息。 无耐性的重复（impatient duplication）：开发者偷懒，他们重复，因为那样似乎更容易。 开发者之间的重复（interdeveloper duplication）：同一团队（或不同团队）的几个人重复了同样的信息。  强加的重复  信息的多种表示
我们也许在编写客户-服务器应用，在客户和服务器端使用了不同的语言，并且需要在两端都表示某种共有的结构。我们或许需要一个类，其属性是某个数据库表的 schema。
解决办法是编写简单的过滤器或代码生成器。可以在每次构建（build）软件时，使用简单的代码生成器，根据公共的元数据表示构建多种语言下的结构。可以用最初用于构建 schema 的元数据，自动生成类定义。
 代码中的文档
代码为什么需要注释：糟糕的代码才需要许多注释。
DRY 法则告诉我们，要把低级的知识放在代码中，它属于那里；把注释保留给其他高级说明。否则，我们就是在重复知识，而每一次改变都意味着既要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟。
 文档与代码
你撰写文档，然后编写代码。有些东西变了，你修订文档、更新代码。文档和代码都含有同一知识表示。
可以根据文档来生成测试。
 语言问题
许多语言会在源码中强加可观的重复。如果语言使模块的接口与其实现分离，就常常会出现这样的情况。C/C++ 有头文件，在其中重复了被导出变量、函数和（C++）类的名称和类型信息。
再思考一下头文件和实现文件中的注释。绝对没有理由在这两种文件之间重复函数或类头注释（head comment）。应该用头文件记载接口问题，用实现文件记载代码的使用者无需了解的实际细节。
  无意的重复 有时，重复来自设计中的错误。
举个例子：
class Line { public: Point start; Point end; double lenght; };  第一眼看上去这个类似乎是合理的。线段显然有起点和终点，并总是有长度的。但这里有重复，长度是由起点和终点决定的：改变其中一个，长度就会变化。最好是让长度编程计算字段：
class Line { public: Point start; Point end; double lenght() { return start.</description>
    </item>
    
    <item>
      <title>读《程序员修炼之道》（一）</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-1/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-the-pragmatic-programmer-part-1/</guid>
      <description>实习到现在差不多两个月了，博客也一直荒废了没写。这次更新就先来写写读书笔记好了。
这本书从书名来看其实很像那种鸡汤类的书，英文名「The Pragmatic Programmer」（注重实效的程序员）看上去就好了许多。豆瓣评分 8.6 分。大一的时候买的书，之前随意地写过几年的玩具代码，所以初读这本书的时候觉得很有道理，但是读完了之后发现什么也没有记住。用徐宥的话来说就是「读者如果没有类似的经历，看到这些珠玑，也只是觉得把玩颇为有趣而已，极少能有同感。」大一的时候读这是这种感觉。
出来实习之后，接触到实际生产中的代码，在代码量比较大的情况下（几十万行），之前书中所讲的一些问题都一一浮现了。为了写出优雅的代码，有必要把这本书再读一遍，可能以后还要反复读很多遍（不是所有的内容看一遍就能内化在心里的），所以每读一部分就记一点笔记，留作日后复习用。
给自己制定以下阅读的计划，因为这本书每一张的内容读起来都比较轻松，所以预计用两周的时间读完：
 每 1-2 天阅读一章（共 8 章） 每一章都写一篇笔记，读的时候可以做一些摘录，读完一章之后写一篇总结性的笔记；  下面是「序言」和「第一章」的笔记。
序 注重实效的程序员都有哪些特征  早期的采纳者/快速的改编者：给你一样新东西，你很快能把握它，并把它与你的知识的其余部分结合在一起（尝试新技术）； 好奇：你喜欢提问，你是收集小知识的林鼠（建立自己的知识 wiki）； 批判的思考者：你会首先抓住事实，而不是照搬别人所说的； 有现实感：你会设法理解你面临的每个问题的内在本质（事情有多困难，需要花多长时间完成？） 多才多艺：你尽力熟悉广泛的技术和环境；  （审视一下自己，上面几点好像都没有做到，或者说有的做到了但是并不到位。）
 Tip 1 Care About Your Craft 关心你的技艺
 如何做到上面所说的？在你做某件事情的时候思考你在做什么。
 Tip 2 Think! About Your Work 思考！你的工作
 它是一个持续的过程 每天为提炼你所拥有的技能而工作，为把新的工具增加到你的技能列表中二工作。草坪不是一天修成的。
第一章：注重实效的哲学 我的源码让猫给吃了  在所有的弱点中，最大的弱点就是害怕暴露弱点。—— J.B.Bossuet
 如果你确实同意要为某个结果负责，你就应该切实负起责任。当你犯错误的时候，不要责备别人或别的东西，或是拼凑借口。你可以选择提供解决方案，而不是寻找借口。
 Tip 3 Provide Options, Don&amp;rsquo;t Make Lame Excuses 提供各种选择，不要找蹩脚的借口
 在你走向任何人，告诉他们为何某件事做不到、为何耽搁、为何出现问题之前，先停下来，听一听你心里的声音。在你去告诉他们坏消息之前，是否还有其他你可以再试一试的办法？有时，你其实知道他们会说什么，所以还是不要给他们添麻烦。
（这一点深有感触，在实习的这一段时间里面，经常因为一些小事去麻烦 leader，比如说环境跑步起来，某个莫名其妙的报错等，这虽然有文档不全的原因在，不过自己也没想着去补全文档这种解决办法。）</description>
    </item>
    
    <item>
      <title>2016 音乐总结</title>
      <link>http://blog.jiayuanzhang.com/post/digital-life-in-2016-music-part/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/digital-life-in-2016-music-part/</guid>
      <description>最近知乎上的一个朋友和我私信聊了一些关于效率工具以及 Workflow（此处指的是「工作流」）方面的一些问题。聊的内容比较碎片，所以还是打算写一篇文章来具体讨论一下。考虑到会涉及很多不同的主题，所以还是一个主题写一篇，这样也可以控制文章的长度。暂定按照以下主题来写：音乐篇、阅读篇、写作篇和时间管理篇。
音乐对我来说，应该算是日常生活中比较重要的一项内容了，除了一些需要特别 Focus 的工作（例如看数学）不会听音乐外，其他时间都会戴着耳机。2016 年彻底地转入到 Apple Music 中来，期间试用过一段时间的 Spotify，网易云音乐几乎没怎么打开过。这篇打算讨论一下所有（尽量）听音乐方面相关的问题。
用什么设备听 我的大多数电子设备都是 Apple 系的，包括 rMBP、iPhone、iPad，所以听音乐也都是围绕着这些设备来。严格的来说，并不能算一个「音乐发烧友」，我对设备的要求并不是太高，甚至对音源也没有太高的要求，Apple Music 的音质已经完全能够满足了，无损音源内容几乎不听，其一是没有购买 CD 的习惯，所以没有合法的途径获取无损资源；其二是一直都是拿 iTunes 听音乐，无损还需要转格式编辑信息，过于麻烦。
主力播放器是 Macbook，几乎 80% 的时间都是在 Macbook 上听（写代码、阅读、写作等）。另外便是新购入的 iPhone 7，主要是外出坐车、跑步或是睡前听一下（之前是用 5s）。iPad 很少用来听音乐。
使用的耳机是 Westone UM Pro 30，使用体验很好，对比 Apple 自带的耳机有惊艳的提升，而且长时间佩戴也没有不适感（几乎没有戴着耳机的感觉）。想要具体了解得可以去搜相关的评测来看。
耳机是在 7 发售之前买的，传闻 7 要去掉耳机接口的时候其实我是不信的，结果还真去掉了。这导致了插 7 上需要多接一根转接线，略显累赘，所以现在在 iPhone 上听歌就直接拿自带的耳机了。
为什么不用网易云音乐 我知道，我也很讨厌类似「我为什么不 xxx」的说法，「不用就不用，还要批判一番」，但是还是要写一写。
其实我很早就开始使用网易云音乐了，那个时候一些热门的歌曲下评论还只有几百条，不像现在，动辄上千上万条评论。也安利过身边好多人用，曾经是长期的会员用户，所以还是有一些资格来谈论一下这个音乐服务的。
很明显，网易云音乐最初就是模仿 Spotify 的，包括界面设计，几乎一模一样。除了借鉴 Spotify 之外，网易云音乐还加入了很多自己的「创新」，而正是这些所谓的创新，让我开始慢慢得不想用它。
 评论：其实我是赞成加入评论功能的，但是网易云的评论已经偏离了音乐评论的范围，变成了编故事、讲段子、骗赞评论的聚集地。认真评论音乐的几乎没有，我不知道如果想看段子为什么不上微博？这一点实际上让一个音乐软件变成了社交软件，不好意思，我只想好好听音乐。 歌曲：网易云上很多歌曲的信息混乱不堪，包括专辑信息、专辑封面、年份等，很多单曲甚至没有专辑信息，直接被编排到「热门歌曲串烧」这样的专辑里，我有强迫症，看着挺 low 的。并且很多的歌来源都不明确，大多数都是网友上传，甚至很多 Bilibili 鬼畜区的音乐也被上传上来，哪天听推荐就冷不丁得听到。 专辑封面不完整：网易云的一大特色就是模仿唱片机旋转，想看一下专辑封面是什么样还要点到专辑列表里面去看。在我看来，在电子设备上「拟物」是一种很没有效率的事，就像之前电子书的模拟翻页一样，「翻页」这个动作本来就是一个三维的过程，在手机上再怎么模拟也达不到现实中的效果，「瀑布式」的阅读方式才是正确的选择。所以我推崇「反拟物化」、「扁平化」和「极简化」的设计风格。 歌单：几乎所有的歌单都是由用户创建，和 Apple Music 与 Spotify 专门的音乐编辑创建的歌单相比，高下立判。  在我看来，听音乐是一件很纯粹的事，而网易云给这件纯粹的事加了太多的东西。</description>
    </item>
    
    <item>
      <title>推荐系统笔记</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-recommandation-system/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-recommandation-system/</guid>
      <description>开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。
这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。
基于用户的协同过滤 协同过滤（Collaborative filtering） 一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。
测试数据集 为了演示一些算法，我们需要从这个网站上下载一份数据集。这里因为是作为演示使用，所以只需要下载ml-latest-small.zip这一份简单的数据集就可以了。
相似度计算 在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的相似度评价值。
欧几里德距离评价（Euclidean Distance Score） 欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作$(p_1, p_2, p_3, p_4, &amp;hellip;)$和$(q_1, q_2, q_3, q_4, &amp;hellip;)$，则欧几里德距离的计算公式为：
$$ \sqrt{((p_1-q_1)^2+(p_2-q_2)^2+&amp;hellip;+(p_n-qn)^2)} = \sqrt{(\sum{i=1}^n(p_i-q_i)^2)} $$
创建 recommendations.py。
用代码表示：
from math import sqrt # 返回一个有关 person1 与 person2 的基于距离的相似度评价 def sim_distance(prefs, person1, person2): # 得到 shared_items 的列表 shared_items = {} for item in prefs[person1]: if item in prefs[person2]: shared_items[item] = 1 # 如果两者没有共同之处，则返回 0 if len(shared_items) == 0: return 0 # 计算所有差值的平方和 sum_of_squares = sum([pow(prefs[person1][item]-prefs[person2][item], 2)for item in prefs[person1] if item in prefs[person2]]) return 1 / (1 + sqrt(sum_of_squares))  欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。</description>
    </item>
    
    <item>
      <title>搭建 Python 科学计算环境</title>
      <link>http://blog.jiayuanzhang.com/post/build-python-scienfic-computing-environment/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/build-python-scienfic-computing-environment/</guid>
      <description>最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。
安装虚拟环境 不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在virtualenv 相关笔记这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用alias），这样就避免每次一打开就输入一长串命令了。
因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。
然后使用以下命令一键安装所需要的库：
sudo pip install numpy pandas matplotlib jupyter scikit-learn  安装不上的请检查是不是需要翻墙。
IPython 熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。
开启 IPython Notebook 使用以下命令来打开 IPython Notebook：
(ENV2.7)$ jupyter notebook  这样 server 就启动了，浏览器会自动打开一个目录树。
Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。
然后我们新建一个 IPython Notebook 用作演示：
In [1] 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 matplotlib 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。
内省 在变量的前面或后面加上一个 ?</description>
    </item>
    
    <item>
      <title>virtualenv 相关笔记</title>
      <link>http://blog.jiayuanzhang.com/post/notes-on-virtualenv/</link>
      <pubDate>Sun, 17 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/notes-on-virtualenv/</guid>
      <description>安装 直接使用 pip 来进行安装：
$ sudo pip install virtualenv  用途 主要用来创建隔离的 Python 开发环境，比如说一个项目需要用到 2.7 的库，另一个项目需要用到 3.0 的库，我们就可以使用 virtualenv 来分别给这两个项目创建虚拟的 Python 环境，这样可以有效的避免冲突。
virtualenv 会创建一个拥有独立安装目录的 Python 环境，该隔离环境不会与其他 virtualenv 环境共享模块（可以选择是否访问全局安装目录）。
使用 创建虚拟环境 最基本的使用：
$ virtualenv ENV  其中 ENV 是用来存放虚拟环境的目录。
$tree -L 1 ENV ENV ├── bin ├── include ├── lib └── pip-selfcheck.json  其中 lib 和 include 目录是用来存放新的虚拟 Python 环境的依赖库，Package 被安装到 lib/pythonX.X/site-packages/ 中，bin 目录中是新的 Python 解释器。pip 和 setuptools 默认被安装的。
active script 进入虚拟环境：</description>
    </item>
    
    <item>
      <title>Swift 中的内存管理</title>
      <link>http://blog.jiayuanzhang.com/post/garbage-collection-in-swift-lang/</link>
      <pubDate>Fri, 15 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/garbage-collection-in-swift-lang/</guid>
      <description>这篇文章是在阅读《The Swift Programming Language》Automatic Reference Counting（ARC，自动引用计数）一章时做的一些笔记，同时参考了其他的一些资料。
在早期的 iOS 开发中，内存管理是由开发者手动来完成的。因为传统的垃圾回收机制对于移动平台来说十分低效，苹果采用的是引用计数（RC，Reference Counting）的方式来管理内存，开发者需要通过手工的方式增加或减少一个实例的引用计数。在 iOS 5 之后，引入了 ARC 自动引用计数，使得开发者不需要手动地调用 retain 和 release 来管理引用计数，但是实际上这些方法还是会被调用，只不过是交给了编译器来完成，编译器会在合适的地方帮我们加入这些方法。
什么是自动引用计数？
每当你创建一个类的实例的时候，ARC 便会自动分配一块内存空间来存放这个实例的信息，当这个实例不再被使用的时候，ARC 便释放实例所占用的内存。一般每个被管理的实例都会与一个引用计数器相连，这个计数器保存着当前实例被引用的次数，一旦创建一个新的引用指向这个实例，引用计数器便加 1，每当指向该实例的引用失效，引用计数器便减 1，当某个实例的引用计数器变成 0 的时候，这个实例就会被立即销毁。
在 Swift 中，对引用描述的关键字有三个：strong，weak 和 unowned，所有的引用没有特殊说明都是 strong 强引用类型。在 ARC 中，只有指向一个实例的所有 strong 强引用都断开了，这个实例才会被销毁。
举一个简单的例子：
class A { let name: String init(name: String) { self.name = name } deinit { print(&amp;quot;A deinit&amp;quot;) } } var a1: A? var a2: A? a1 = A(name: &amp;quot;A&amp;quot;) a2 = a1 a1 = nil  上面这个例子中，虽然 a1 这个 strong 强引用断开了，但是还有 a2 这个强引用指向这个实例，所以不会在命令行中输出 A deinit，当我们把 a2 也设置为 nil 时，与这个实例关联的所有强引用均断开了，这个实例便会被销毁，在命令行中打印 A deinit。</description>
    </item>
    
    <item>
      <title>Linux 基础笔记</title>
      <link>http://blog.jiayuanzhang.com/post/linux-basic-notes/</link>
      <pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/linux-basic-notes/</guid>
      <description>Shell 的基本操作 常用快捷键    按键 作用     Tab 命令补全   Ctrl+c 强行终止当前程序   Ctrl+d 键盘输入结束或退出终端   Ctrl+s 暂定当前程序，暂停后按下任意键恢复运行   Ctrl+z 将当前程序放到后台运行，恢复到前台命令 fg   Ctrl+a 将光标移动到行首   Ctrl+e 将光标移动到行尾   Ctrl+k 删除从光标所在位置到行末   Alt+Backspace 向前删除一个单词    常用通配符    字符 含义     * 匹配0或多个字符   ? 匹配任意一个字符   [list] 匹配 list 中的任意单一字符   [!</description>
    </item>
    
    <item>
      <title>学院派编程自学指南</title>
      <link>http://blog.jiayuanzhang.com/post/self-learning-programer-manual-college-part/</link>
      <pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/self-learning-programer-manual-college-part/</guid>
      <description>由于本人目前也处在学习的阶段，文章中列出来的内容也并未全部学习过，所以文章的客观性可能存在一些问题，还望读者自行判断。
这份指南会不定期更新，有好的建议也可以留言或者给我发邮件。
准备 需要的所有工具就是一台可以连接上网络的电脑以及你本人。
科学上网 很可惜，即使是现在，大部分学习计算机的学生还是不会科学上网。在当前的网络环境下，不会科学上网，意味着你不能用 Google 查资料，不能在 Hacker News 查看最新资讯，需要忍受龟速的 GitHub，云云。然而，科学上网本身却是一件成本非常低的事情，不想折腾的话，一年花个几百块钱买个现成的服务；有折腾精神的人，可以买个服务器自己假设架设上网工具。这一步很重要，不能跳过，否则后面指南中的许多内容都无法进行访问。
关于科学上网的具体内容，就不再多说了，给你一个关键词：Lantern。
学会使用 Google 搜索 学会了科学上网，你就能够使用 Google 了，为什么不是 Baidu？相信你用了 Google 之后就自然明白了。
当了一个学期的助教之后发现，很多的同学其实是没有使用搜索引擎的意识的，遇到问题要么自己死磕，或者就直接求助于他人。这两种都不是很好的办法，正确的做法是在自己思考后没有结果，然后使用搜索引擎查找问题，现阶段，你遇到的所有问题（几乎）都能在 Google 上找到现成的答案，如果没找到，肯定是你搜索的方式不正确。
使用Google的基本搜索功能就能够解决大部分问题了，当然，如果想要学习更加高级的技巧，这里有一份指南：如何用好Google等搜索引擎？。
英语 你不得不承认，目前为止，编程世界的主流语言还是英文，所以英语能力的好坏决定了你编程能力的上界。中文资料和英文资料相比，实在是太匮乏了，就质量而言，也相对较低。比如我后面提到的很多的课程，都是英文的内容。
值得庆幸的是，阅读编程资料所需要的英文水平并不需要很高，就个人经验来说，基本上四级水平就足够了，可能还会存在一些生词，但是基本上并不妨碍理解。
英文的学习应该一直贯穿于编程的学习之中，作为一门工具语言，只需要花少量时间就可以带来比较大的收益（2/8法则）。
本人的英文水平也不算好，但是基本上能够阅读技术书籍和文档，能够听懂公开课，所以还是有一些简单的经验可以分享一下。
把系统换成英文的 有些同学可能看到英文就头疼，这很正常，因为在中文的环境下面生活的太久了。为此，可以试着将平常用的系统换成英文的，虽说不能学到几个单词（Copy/Paste 之类的词），但是可以让你不那么排斥英文。
安装电子词典 OS X下推荐欧路词典，在APP Store中购买完整版的，因为需要添加外部的词典。
这里推荐一部比较好的词典：《Collins 英汉双解词典》，它是这个样子的：
主要看它的英文解释，一个词看得次数多了也就记住了。
每天阅读英文的资料 一些个人经常阅读的网站：
 Quora：一个类似于知乎的问答类网站，可以挑自己感兴趣的内容来阅读。 Hacker News：互联网资讯，业界发生的最新的事件都会在上面。 PROGRAMMING：Reddit 的 Programming 板块，和 Hacker News 类似，不过更加专注于技术内容方面。  不要花太多时间在上面，每天浏览一下就行。
英文学习的总结 英语不是能够速成的东西，也不是三言两语能够讲完的东西，这里只是提供一个简单的指导，具体的学习计划还请自行搜索更加专业的学习指南。
编程基础 完成了这一部分内容的学习后你应该具备：
 了解什么是 Computer Science 基本的计算机数学能力 基本的程序开发能力 基本的算法与数据结构的知识  计算机科学导论  Introduction to Computer Science and Programming：面向无编程基础或者只有一点基础的人群，使用Python作为教学语言。 Intensive Introduction to Computer Science Open Learning Course：CS50，哈佛很火的一门课，在网易公开课上可以找到翻译的视频内容。涵盖的主题有算法（设计、应用、分析）；软件开发（抽象、封装、数据结构、Debug、测试）；计算机体系结构等等。基本上是一门大杂烩的导论课。使用的语言是C、PHP、JavaScript。 Programming Abstractions：介绍了更加高级的编程主题（递归、算法分析、数据抽象等等），使用C++作为教学语言。  数学  Mathematics for Computer Science：介绍了学习计算机所需要的一些数学知识，内容包括集合、关系、证明方法、数论、图论等等。 Discrete Mathematics：离散数学。  编程语言  Learn to Program: The Fundamentals：面向无编程基础或者只有一点基础的人群，使用Python作为教学语言。 Learn to Program: Crafting Quality Code：如何编写高效与正确的代码。需要有Learn to Program: The Fundamentals的基础。 The Structure and Interpretation of Computer Programs：经典的 SICP 的 Python 版。  计算理论  Introduction to the Theory of Computation Principles of Computing (Part 1)：介绍了 CS 中基本的数学和编程理论，需要有Python基础。  算法与数据结构  Introduction to Algorithms：MIT的算法导论课，用《算法导论》作为教材，网上可以找到视频资源，网易公开课上有老版的翻译。  核心课程 学完了「编程基础」部分的内容后，应该已经可以开发一些复杂的程序了，「核心课程」的内容将深入学习计算机科学理论的几个重要的内容。</description>
    </item>
    
    <item>
      <title>使用Emacs Org-mode &#43; GitHub Pages 来写博客</title>
      <link>http://blog.jiayuanzhang.com/post/how-to-use-emacs-and-org-mode-to-build-a-blog/</link>
      <pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.jiayuanzhang.com/post/how-to-use-emacs-and-org-mode-to-build-a-blog/</guid>
      <description>这个博客就是使用Emacs org-mode + GitHub Pages搭建的，博客的主题是org-mode官网的主题，非常的简洁；评论采用的disqus，访问统计使用的是Google和Baidu的统计代码。
另外，本文中进行操作的环境是在OSX下完成的，Windows用户请自行参考脑补:)
起因 之前也折腾过好多的博客，Jekyll、Hexo、Farbox等，这些静态博客生成器都有一个共同点，都是采用的Markdown语法来进行书写的，而自己平时记笔记都是使用的Emacs org-mode，这样就导致了记笔记和写博客两个过程分裂开来了。
昨晚偶然看到dirtysalt&amp;rsquo;s homepage，被深深的震撼了，博主写了很多的干货，专注与博客的内容而不是博客的外观。而自己也是一个极简主义者，觉得这样的博客样式还是挺好看的（很有Web1.0时代的复古风啊）。恰巧博主也是使用的Emacs来写博客，于是便花了一个上午的时间搜集相关的资料并把博客搭建起来了。
准备 GitHub帐号与GitHub Pages 首先你需要一个存放博客的地方，这里采用的是GitHub，当让也可以使用其他的服务，只要支持静态页面展示即可。
GitHub的注册过程省略。
注册完GitHub帐号之后建立一个新的仓库，命名为 xxx.github.io ，其中 xxx 为你的用户名。
Emacs环境 我使用的是最近比较火的spacemacs ，很多功能都配置好了，基本上手即用。
如果不是用的spacemacs，确保你的Emacs版本为24，org-mode版本为8.0以上，不排除可能因为版本的原因出现各种各样的错误。
什么，你还不知道Emacs是什么，那先去下载一个Emacs吧，使用org-mode基本不需要什么Emacs的基础，只需要记住几个快捷键就可以了。
建立目录结构 随便在哪里建一个心得目录，这个目录就是存放你的org文件和html文件的地方。假设我们已经有了这么一个目录 org ：
$ mkdir notes $ mkdir public_html $ mkdir gtd  当然，那个gtd目录你可以不要，那是用来做时间管理的，如果你不想用Emacs做时间管理的话，可以不用建那个目录。
 notes: 这个目录就是用来存放元数据的地方，你的org文件、图片、CSS文件、PDF等全都是存放在这里的。 public_html: 这个目录是用来存放导出的HTML文件的，那些非org格式的文件还会原封不动地拷贝过来。  配置Emacs 这一步有一些复杂，没有Elisp基础的同学可能看不怎么懂，不过没关系，照着做就是了，现在看不懂可以以后学嘛。
Emacs org-mode自带了很强大的导出功能，可以导出成HTML、markdown、PDF等格式的文件，我们这里使用自带的导出Project的功能，只不过在导出之前，要做一些配置，告诉Emacs要导出哪些东西，导出到哪里，采用什么规则。
首先我们在配置文件中添加以下代码（普通的在.emacs中添加，spacemacs用户在.spacemacs中添加）：
(require &#39;ox-publish) (setq org-publish-project-alist &#39;( ;; 把各部分的配置文件写到这里面来 ))  然后把其他的配置文件依次添加进来就可以了，主要有生成HTML的部分和原样拷贝的部分。
下面来配置需要转换成HTML的内容：
(&amp;quot;blog-notes&amp;quot; :base-directory &amp;quot;~/org/notes&amp;quot; :base-extension &amp;quot;org&amp;quot; :publishing-directory &amp;quot;~/org/public_html/&amp;quot; :recursive t :publishing-function org-html-publish-to-html :headline-levels 4 ; Just the default for this project.</description>
    </item>
    
  </channel>
</rss>