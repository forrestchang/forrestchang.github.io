<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Jiayuan's Blog]]></title>
  <link href="http://jiayuanzhang.com/atom.xml" rel="self"/>
  <link href="http://jiayuanzhang.com/"/>
  <updated>2019-02-22T17:26:50+08:00</updated>
  <id>http://jiayuanzhang.com/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[Linux 命令行详解：SFTP]]></title>
    <link href="http://jiayuanzhang.com/linux-command-sftp.html"/>
    <updated>2019-02-16T23:12:20+08:00</updated>
    <id>http://jiayuanzhang.com/linux-command-sftp.html</id>
    <content type="html">
<![CDATA[<p>「Linux 命令详解」这个系列的文章将会介绍 Linux/Unix/macOS 系统中使用到的常用命令，包括该命令的简单介绍、常用参数解释以及最佳实践，如果需要快速使用这个命令，直接跳到最佳实践部分即可。</p>

<p>「Linux 命令详解」系列文章：</p>

<ul>
<li><a href="http://jiayuanzhang.com/post/linux-sftp-tutorial/">Linux命令详解：SFTP</a></li>
</ul>

<h2 id="toc_0">一、介绍</h2>

<p>SFTP（Secure File Transfer Protocol，安全文件传输协议）是一种基于可靠数据流（data stream），提供文件存取和管理的网络传输协议，它在网络协议层的结构如下图<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>所示：</p>

<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxx2ngca7kj31dv0u0dij.jpg" alt="sftp-layer"/></p>

<p>与 FTP 协议相比，SFTP 在客户端与服务器间提供了一种更为安全的文件传输方式，如果你还在使用 FTP 来进行文件传输，强烈建议切换到更为安全的 SFTP 上来。</p>

<p>本篇文章将会介绍 SFTP 的链接，以及在交互式命令行中的一些常用命令，并对一些参数进行解释，最后给出实际使用中的最佳实践。目前已经有很多 GUI 客户端支持 SFTP 协议，但是不在本篇文章的讨论范围之内。</p>

<h2 id="toc_1">二、使用 SFTP 进行连接</h2>

<p>因为 SFTP 是基于 SSH 协议的，所以默认的身份认证方法与 SSH 协议保持一致。通常我们使用 SSH Key 来进行连接，如果你已经可以使用 SSH 连接到远程服务器上，那么可以使用以下命令来连接 SFTP：</p>

<pre><code class="language-bash">sftp user_name@remote_server_address[:path]
</code></pre>

<p>如果远程服务器自定义了连接的端口，可以使用 <code>-P</code> 参数：</p>

<pre><code class="language-bash">sftp -P remote_port user_name@remote_server_address[:path]
</code></pre>

<p>连接成功后将进入一个 SFTP 的解释器，可以发现命令行提示符变成了 <code>sftp&gt;</code>，使用 <code>exit</code> 命令可以退出连接。</p>

<p>如果连接地址存在 <code>path</code> 并且 <code>path</code> 不是一个目录，那么 SFTP 会直接从服务器端取回这个文件。</p>

<h2 id="toc_2">三、连接参数详解</h2>

<ul>
<li><code>-B</code>: buffer_size，制定传输 buffer 的大小，更大的 buffer 会消耗更多的内存，默认为 32768 bytes；</li>
<li><code>-P</code>: port，制定连接的端口号；</li>
<li><code>-R</code>: num_requests，制定一次连接的请求数，可以略微提升传输速度，但是会增加内存的使用量。</li>
</ul>

<h2 id="toc_3">四、目录管理</h2>

<p>在 SFTP 解释器中可以使用 <code>help</code> 命令来查看帮助文档。</p>

<pre><code class="language-bash">sftp&gt; help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to &#39;path&#39;
chgrp grp path                     Change group of file &#39;path&#39; to &#39;grp&#39;
chmod mode path                    Change permissions of file &#39;path&#39; to &#39;mode&#39;
chown own path                     Change owner of file &#39;path&#39; to &#39;own&#39;
df [-hi] [path]                    Display statistics for current directory or
                                   filesystem containing &#39;path&#39;
exit                               Quit sftp
get [-afPpRr] remote [local]       Download file
reget [-fPpRr] remote [local]      Resume download file
reput [-fPpRr] [local] remote      Resume upload file
help                               Display this help text
lcd path                           Change local directory to &#39;path&#39;
lls [ls-options [path]]            Display local directory listing
lmkdir path                        Create local directory
ln [-s] oldpath newpath            Link remote file (-s for symlink)
lpwd                               Print local working directory
ls [-1afhlnrSt] [path]             Display remote directory listing
lumask umask                       Set local umask to &#39;umask&#39;
mkdir path                         Create remote directory
progress                           Toggle display of progress meter
put [-afPpRr] local [remote]       Upload file
pwd                                Display remote working directory
quit                               Quit sftp
rename oldpath newpath             Rename remote file
rm path                            Delete remote file
rmdir path                         Remove remote directory
symlink oldpath newpath            Symlink remote file
version                            Show SFTP version
!command                           Execute &#39;command&#39; in local shell
!                                  Escape to local shell
?                                  Synonym for help
</code></pre>

<p>SFTP 解释器中预置了常用的命令，但是没有自带的 Bash 来得丰富。</p>

<p>1）显示当前的工作目录：</p>

<pre><code class="language-bash">sftp&gt; pwd
Remote working directory: /
</code></pre>

<p>2）查看当前目录的内容：</p>

<pre><code class="language-bash">sftp&gt; ls
Summary.txt     info.html       temp.txt        testDirectory
</code></pre>

<p>3）使用 <code>-la</code> 参数可以以列表形式查看，并显示隐藏文件：</p>

<pre><code class="language-bash">sftp&gt; ls -la
drwxr-xr-x    5 demouser   demouser       4096 Aug 13 15:11 .
drwxr-xr-x    3 root       root           4096 Aug 13 15:02 ..
-rw-------    1 demouser   demouser          5 Aug 13 15:04 .bash_history
-rw-r--r--    1 demouser   demouser        220 Aug 13 15:02 .bash_logout
-rw-r--r--    1 demouser   demouser       3486 Aug 13 15:02 .bashrc
drwx------    2 demouser   demouser       4096 Aug 13 15:04 .cache
-rw-r--r--    1 demouser   demouser        675 Aug 13 15:02 .profile
. . .
</code></pre>

<p>4）切换目录：</p>

<pre><code class="language-bash">sftp&gt; cd testDirectory
</code></pre>

<p>5）建立文件夹：</p>

<pre><code class="language-bash">sftp&gt; mkdir anotherDirectory
</code></pre>

<p>以上的命令都是用来操作远程服务器的，如果想要操作本地目录呢？只需要在每个命令前添加 <code>l</code> 即可，例如显示本地操作目录下的文件：</p>

<pre><code class="language-bash">sftp&gt; lls
localFiles
</code></pre>

<p>使用 <code>!</code> 可以直接运行 Shell 中的指令：</p>

<pre><code class="language-bash">sftp&gt; !df -h
Filesystem      Size   Used  Avail Capacity iused               ifree %iused  Mounted on
/dev/disk1s1   466Gi  360Gi  101Gi    79% 3642919 9223372036851132888    0%   /
devfs          336Ki  336Ki    0Bi   100%    1162                   0  100%   /dev
/dev/disk1s4   466Gi  4.0Gi  101Gi     4%       5 9223372036854775802    0%   /private/var/vm
map -hosts       0Bi    0Bi    0Bi   100%       0                   0  100%   /net
map auto_home    0Bi    0Bi    0Bi   100%       0                   0  100%   /home
</code></pre>

<h2 id="toc_4">五、传输文件</h2>

<h3 id="toc_5">5.1 从远程服务器拉取文件</h3>

<p>使用 <code>get</code> 命令可以从远程服务器拉取文件到本地：</p>

<pre><code class="language-bash">sftp&gt; get remoteFile [newName]
</code></pre>

<p>如果不指定 <code>newName</code>，将使用和远程服务器相同的文件名。</p>

<p>使用 <code>-r</code> 参数可以拉取整个目录：</p>

<pre><code class="language-bash">sftp&gt; get -r remoteDirectory
</code></pre>

<h3 id="toc_6">5.2 从本地上传文件到服务器</h3>

<p>使用 <code>put</code> 命令可以从本地上传文件到服务器：</p>

<pre><code class="language-bash">sftp&gt; put localFile
</code></pre>

<p>同样的，可以使用 <code>-r</code> 参数来上传整个目录，但是有一点要注意，<strong>如果服务器上不存在这个目录需要首先新建</strong>：</p>

<pre><code class="language-bash">sftp&gt; mkdir folderName
sftp&gt; put -r folderName
</code></pre>

<h2 id="toc_7">六、最佳实践</h2>

<p>1）连接远程服务器</p>

<pre><code class="language-bash">sftp remote_user@remote_host
</code></pre>

<p>2）使用端口进行连接</p>

<pre><code class="language-bash">sftp -P remote_port remote_user@remote_host
</code></pre>

<p>3）从远程服务器拉取文件</p>

<pre><code class="language-bash">get /path/remote_file
</code></pre>

<p>4）上传本地文件到服务器</p>

<pre><code class="language-bash">put local_file
</code></pre>

<p>5）查看远程服务器目录内容</p>

<pre><code class="language-bash">ls
</code></pre>

<p>6）查看本地目录内容</p>

<pre><code class="language-bassh">lls
</code></pre>

<p>7）执行本地 Shell 命令</p>

<pre><code class="language-bash">![command]
</code></pre>

<h2 id="toc_8">参考资料</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol">SSH File Transfer Protocol</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server">How To Use SFTP to Securely Transfer Files with a Remote Server</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>图片使用 Sketch 绘制，灵感来源于<a href="https://draveness.me/">面向信仰编程</a>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 后端开发者也需要了解的跨域问题]]></title>
    <link href="http://jiayuanzhang.com/cors-tutorial.html"/>
    <updated>2019-02-16T23:20:16+08:00</updated>
    <id>http://jiayuanzhang.com/cors-tutorial.html</id>
    <content type="html">
<![CDATA[<p>Web 后端开发者很少会去充分了解跨域问题，原因是他们很少和 JavaScript 打交道。但是作为一个 Web 开发者，知道跨域请求和如何解决跨域问题可以和前端开发者在沟通上变得更为顺畅。</p>

<p>这篇文章会介绍和跨域请求相关的一些概念，以及如何在后端（Python）解决浏览器的跨域请求问题。</p>

<h2 id="toc_0">一、什么是跨域请求</h2>

<p>首先，我们要了解什么是跨域请求。简单来说，当一台服务器资源从另一台服务器（不同的域名或者端口）请求一个资源时，就会发起一个跨域 HTTP 请求。</p>

<p>举个简单的例子，<code>http://example-a.com/index.html</code> 这个 HTML 页面请求了 <code>http://example-b.com/resource/image.jpg</code> 这个图片资源时（发起 Ajax 请求，非 <code>&lt;img&gt;</code> 标签），就是发起了一个跨域请求。</p>

<p>在不做任何处理的情况下，这个跨域请求是无法被成功请求的，因为浏览器基于<strong>同源策略</strong>会对跨域请求做一定的限制。</p>

<h2 id="toc_1">二、浏览器同源策略</h2>

<p>这就引出了<strong>浏览器的同源策略（Same-origin policy）</strong>，同源策略限制了从同一个源加载的文档或者脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>

<p>什么是同源？同源需要同时满足三个条件：</p>

<ol>
<li>请求的协议相同（例如同为 http 协议）</li>
<li>请求的域名相同（例如同为 <code>www.example.com</code>）</li>
<li>请求的端口相同（例如同为 80 端口）</li>
</ol>

<p>第 2 点需要注意的是，必须是域名完全相同，比如说 <code>blog.example.com</code> 和 <code>mail.example.com</code> 这两个域名，虽然它们的顶级域名和二级域名（均为 <code>example.com</code>）都相同，但是三级域名（<code>blog</code> 和 <code>mail</code>）不相同，所以也不能算作域名相同。</p>

<p>如果不同时满足这上面三个条件，那就不符合浏览器的同源策略。</p>

<p>修改 <code>document.domain</code> 参数可以更改当前的源，例如 <code>blog.example.com</code> 想要访问父域 <code>example.com</code> 的资源时，可以执行以下 JavaScript 脚本来进行修改：</p>

<pre><code class="language-javascript">document.domain = &#39;example.com&#39;;
</code></pre>

<p>但是 <code>document.domain</code> 不能被设置为 <code>foo.com</code> 或者是 <code>bar.com</code>，因为它们不是 <code>blog.example.com</code> 的超级域。</p>

<p>当然，也不是所有的交互都会被同源策略拦截下来，下面两种交互就不会触发同源策略：</p>

<ul>
<li>跨域写操作（Cross-origin writes），例如超链接、重定向以及表单的提交操作，特定少数的 HTTP 请求需要添加预检请求（preflight）；</li>
<li>跨域资源嵌入（Cross-origin embedding）：
<ul>
<li><code>&lt;script&gt;</code> 标签嵌入的跨域脚本；</li>
<li><code>&lt;link&gt;</code> 标签嵌入的 CSS 文件；</li>
<li><code>&lt;img&gt;</code> 标签嵌入图片；</li>
<li><code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 标签嵌入多媒体资源；</li>
<li><code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code>, <code>&lt;applet&gt;</code> 的插件；</li>
<li><code>@font-face</code> 引入的字体，一些浏览器允许跨域字体（cross-origin fonts），一些需要同源字体（same-origin fonts）；</li>
<li><code>&lt;frame&gt;</code> 和 <code>&lt;iframe&gt;</code> 载入的任何资源，站点可以使用 <code>X-Frame-Options</code> 消息头来组织这种形式的跨域交互。</li>
</ul></li>
</ul>

<p>如果浏览器缺失同源策略这种安全机制会怎么样呢？设想一下，当你登陆了 <code>www.bank.com</code> 银行网站进行操作时，浏览器保存了你登录时的 Cookie 信息，如果没有同源策略，在访问其他网站时，其他网站就可以读取还未过期的 Cookie 信息，从而伪造登陆进行操作，造成财产损失。</p>

<h2 id="toc_2">三、CORS（Cross-origin resource sharing，跨域资源共享）</h2>

<p>虽然同源策略一定程度上保证了安全性，但是如果是一个正常的请求需要跨域该怎么做呢？</p>

<p>常见的方法有四种：</p>

<ol>
<li>JSONP</li>
<li><code>&lt;iframe&gt;</code> 标签</li>
<li>CORS（Cross-origin resource sharing，跨域资源共享）</li>
<li>代理服务器</li>
</ol>

<p>前两种方式本质上是利用浏览器同源策略的漏洞来进行跨域请求，不是推荐的做法，只能作为低版本浏览器的缓兵之计。</p>

<p>代理服务器的做法是让浏览器访问同源服务器，再由同源服务器去访问目标服务器，这样虽然可以避免跨域请求的问题，但是原本只需要一次的请求被请求了两次，无疑增加了时间的开销。</p>

<p>目前主流的方法是使用 CORS 的方式，这也是下面主要讲的内容。</p>

<h3 id="toc_3">3.1 什么是 CORS</h3>

<p>CORS 其实是浏览器制定的一个规范，它的实现则主要在服务端，它通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。</p>

<p>对于那些会对服务器数据产生副作用的 HTTP 请求，浏览器会使用 <code>OPTIONS</code> 方法发起一个预检请求（preflight request），从而可以获知服务器端是否允许该跨域请求，服务器端确认允许后，才会发起实际的请求。在预检请求的返回中，服务器端也可以告知客户端是否需要身份认证信息。</p>

<h3 id="toc_4">3.2 简单请求（Simple requests）</h3>

<p>某些请求不会触发 CORS 预检请求，我们称这样的请求为简单请求。</p>

<p>若请求满足下面所有条件，则该请求可视为简单请求：</p>

<ul>
<li><code>GET</code>, <code>HEAD</code>, <code>POST</code> 方法之一；</li>
<li>Header 仅有以下字段：
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code> 为下面三者之一：</li>
<li>text / plain`</li>
<li><code>multipart / form-data</code></li>
<li><code>application / x-www.form-urlencoded</code></li>
<li><code>DPR</code></li>
<li><code>Downloadlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul></li>
<li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器，<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问；</li>
<li>请求中没有使用 <code>ReadableStream</code> 对象。</li>
</ul>

<p>举一个例子<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>，例如站点 <code>http://foo.example</code> 的网页应用想要访问 <code>http://bar.other</code> 的资源，<code>http://foo.example</code> 的网页中可能包含类似于下面的 JavaScript 代码：</p>

<pre><code class="language-javascript">var invocation = new XMLHttpRequest();
var url = &#39;http://bar.other/resources/public-data/&#39;;
   
function callOtherDomain() {
  if(invocation) {    
    invocation.open(&#39;GET&#39;, url, true);
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
</code></pre>

<p>熟悉 JavaScript 的同学可能发现这段代码向 <code>http://bar.other/resources/public-data/</code> 发起了一个 <code>GET</code> 请求，请求和响应的报文如下。</p>

<p>请求报文：</p>

<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxsiwv09frj31uo0rsn1s.jpg" alt="2018-12-02-request-msg"/></p>

<p>响应报文：</p>

<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxsiwz302wj31uo0rsn0i.jpg" alt="2018-12-02-response-msg"/></p>

<p>在请求报文中，<code>Origin</code> 字段表明该请求来源于 <code>http://foo.example</code>。</p>

<p>在响应报文中，<code>Access-Control-Allow-Origin</code> 字段被设置为 <code>*</code>，表明该资源可以被任意的域访问。</p>

<p>使用 <code>Origin</code> 和 <code>Access-Control-Allow-Origin</code> 就能完成最简单访问控制。如果服务端仅允许来自 <code>http://foo.example</code> 域的访问，应该把 进行如下设置：</p>

<pre><code class="language-http">Access-Control-Allow-Origin: http://foo.example
</code></pre>

<h3 id="toc_5">3.3 预检请求（Preflight Request）</h3>

<p>和简单请求不同，「需预检的请求」要求必须先使用 <code>OPTIONS</code> 方法发送一个预检请求到服务器，以获知服务器是否允许该请求，或者是否需要携带身份认证信息。「预检请求」的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>

<p>当一个请求满足以下任一条件时，该请求需要首先发送预检请求。</p>

<ul>
<li>使用了下面任一 HTTP 方法：<code>PUT</code>、<code>DELETE</code>、<code>CONNECT</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>PATCH</code>；</li>
<li>Header 中设置了除简单请求 Header 字段外的其他字段（见简单请求中的 Header 字段说明）；</li>
<li><code>Content-Type</code> 的值不属于下列之一：
<ul>
<li><code>application/x-www-form-urlencoded</code></li>
<li><code>multipart/form-data</code></li>
<li><code>text/plain</code></li>
</ul></li>
<li>请求中的 <code>XMLHttpRequestUpload</code> 对象注册了任意多个事件监听器；</li>
<li>请求中使用了 <code>ReadableStream</code> 对象。</li>
</ul>

<p>例如下面这个例子[<sup>1]：</sup></p>

<pre><code class="language-javascript">var invocation = new XMLHttpRequest();
var url = &#39;http://bar.other/resources/post-here/&#39;;
var body = &#39;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&#39;;
    
function callOtherDomain(){
  if(invocation)
    {
      invocation.open(&#39;POST&#39;, url, true);
      invocation.setRequestHeader(&#39;X-PINGOTHER&#39;, &#39;pingpong&#39;);
      invocation.setRequestHeader(&#39;Content-Type&#39;, &#39;application/xml&#39;);
      invocation.onreadystatechange = handler;
      invocation.send(body); 
    }
}
</code></pre>

<p>上面的代码使用 POST 请求发送一个 XML 文档，该请求中包含了一个自定义的 Header 字段 <code>X-PINGOTHER: pingpong</code>。另外，该请求的 <code>Content-Type</code> 为 <code>application/xml</code>，因此，该请求需要首先发起「预检请求」。</p>

<p>OPTIONS 请求报文：</p>

<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxtit1a99sj31uo0rs0yi.jpg" alt="2018-12-03-option-request-msg"/></p>

<p>OPTIONS 响应报文：</p>

<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxtiwydue5j31uo0rsjwi.jpg" alt="2018-12-03-option-response-msg"/></p>

<p>OPTIONS 方法是 HTTP/1.1 中定义的方法，用以从服务器获取更多的信息，该方法不会对服务器资源产生影响。预检请求的 Headers 中携带了两个字段：</p>

<pre><code class="language-http">Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
</code></pre>

<p><code>Access-Control-Request-Method: POST</code> 字段告诉服务器，实际请求将使用 <code>POST</code> 方法；<code>Access-Control-Request-Headers</code> 字段告诉服务器，实际请求将携带两个自定义请求的 Header 字段：<code>X-PINGOTHER</code> 和 <code>Content-Type</code>，服务器根据此决定，该实际请求是否被允许。</p>

<p>OPTIONS 响应报文表明服务器将接受后续的实际请求，其中：</p>

<pre><code class="language-http">Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
</code></pre>

<ul>
<li><code>Access-Control-Allow-Origin</code>表示允许 <code>http://foo.example</code> 的域进行访问；</li>
<li><code>Access-Control-Allow-Methods</code> 表明允许客户端发送 <code>POST</code>，<code>GET</code>，<code>OPTIONS</code> 请求；</li>
<li><code>Access-Control-Allow-Headers</code> 表明语序客户端携带 <code>X-PINGOTHER</code> 和 <code>Content-Type</code> Header 字段；</li>
<li><code>Access-Control-Max-Age</code> 表明该响应的有效时间为 86400 秒（24 小时），在有效时间内，浏览器无需为同一请求再次发起预检请求。（注，浏览器自身维护了一个最大有效时间，如果该 Header 字段超过了最大有效时间，将不会生效）。</li>
</ul>

<p>预检请求完成之后，发送实际的请求，请求报文如下：</p>

<pre><code class="language-http">POST /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: http://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: http://foo.example
Pragma: no-cache
Cache-Control: no-cache

&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;
</code></pre>

<p>响应报文：</p>

<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some GZIP&#39;d payload]
</code></pre>

<h3 id="toc_6">3.4 附带身份认证的请求</h3>

<p>一般而言，对于跨域 <code>XMLHTTPRequest</code> 或者 <code>Fetch</code> 请求，浏览器不会发送身份凭证信息，如果需要发送身份凭证信息，需要把 <code>XMLHTTPRequest</code> 的 <code>withCredentials</code> 属性设置为 <code>true</code>。</p>

<p>举个例子[<sup>1]，下面这段代码表示</sup> <code>http://foo.example</code> 向 <code>http://bar.other</code> 发送一个 <code>GET</code> 请求，并且设置 <code>Cookies</code>。</p>

<pre><code class="language-javascript">var invocation = new XMLHttpRequest();
var url = &#39;http://bar.other/resources/credentialed-content/&#39;;
    
function callOtherDomain(){
  if(invocation) {
    invocation.open(&#39;GET&#39;, url, true);
    invocation.withCredentials = true;
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
</code></pre>

<p>通过把 <code>withCredentials</code> 设置为 <code>true</code>，从而向服务器发送一个携带 <code>Cookies</code> 的请求。因为这是一个简单的 <code>GET</code> 请求，所以浏览器不会发起预检请求，但是，服务端的响应中如果未携带 <code>Access-Control-Allow-Credentials: true</code> ，浏览器不会把响应内容返回给请求的发送者。</p>

<p>对于携带身份认证的请求，服务器不得设置 <code>Access-Control-Allow-Origin</code> 的值为 <code>*</code>。</p>

<h3 id="toc_7">3.5 用于 CORS 的 Headers</h3>

<p>下面列出所有用于 HTTP 请求和响应中的 Header 字段，具体的使用请查阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers">相关文档</a>。</p>

<p>HTTP 请求 Headers：</p>

<ul>
<li><code>Origin</code>：表明预检请求或实际请求的源站，它不包含任何路径信息，只是服务器名称（URI）；</li>
<li><code>Access-Control-Request-Method</code>：用于预检请求，作用是将实际请求所使用 HTTP 方法告诉服务器；</li>
<li><code>Access-Control-Request-Headers</code>：用于预检请求，作用是将实际请求所使用的 Header 字段告诉服务器；</li>
</ul>

<p>HTTP 响应 Headers：</p>

<ul>
<li><code>Access-Control-Allow-Origin</code>：指定了允许访问该资源的外域 URI；</li>
<li><code>Access-Control-Expose-Headers</code>：让服务器把允许浏览器访问的头放入白名单，这样浏览器就能使用 <code>getResponseHeader</code> 方法来访问了；</li>
<li><code>Access-Control-Max-Age</code>：指定了预检请求的结果能够被缓存多久；</li>
<li><code>Access-Control-Allow-Credentials</code>：指定了当浏览器的<code>credentials</code>设置为 true 时是否允许浏览器读取 response 的内容；</li>
<li><code>Access-Control-Allow-Headers</code>：用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</li>
</ul>

<h2 id="toc_8">四、服务器端实现</h2>

<p>为了实现 CORS，在服务器端需要做一些工作，最主要的就是在响应 Header 中添加指定的字段。</p>

<p>如果是使用 Python + Flask 的开发的话，可以在 <code>after_app_request</code> 钩子函数中添加指定的响应头：</p>

<pre><code class="language-python">@app.after_app_request
def after_request(response):
    &quot;&quot;&quot;正常请求结束后的处理&quot;&quot;&quot;
    # ... some code here
    
    response.headers[&#39;Access-Control-Allow-Origin&#39;] = &#39;http://example.com&#39;
    response.headers[&#39;Access-Control-Allow-Methods&#39;] = &#39;GET, PUT, POST, DELETE, HEAD, OPTIONS&#39;
    response.headers[&#39;Access-Control-Allow-Headers&#39;] = (
        &#39;Content-Type, Authorization, X-Requested-With&#39;
    )
    
    # ... some code here
    
    return response
</code></pre>

<p>其他语言在对应的钩子函数中处理即可。</p>

<h2 id="toc_9">参考资料</h2>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing (CORS)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>这个例子的来源：[Cross-Origin Resource Sharing (CORS)&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[任务管理系统最佳实践]]></title>
    <link href="http://jiayuanzhang.com/omnifocus-3-tutorial.html"/>
    <updated>2018-11-23T09:43:40+08:00</updated>
    <id>http://jiayuanzhang.com/omnifocus-3-tutorial.html</id>
    <content type="html">
<![CDATA[<p>这篇文章主要分享一下我多年使用的一套任务管理系统的经验，工具是次要的，主要是一些想法的实践。有了基本的思路，无论是 OmniFocus、Todoist 还是 org-mode（Emacs 中的一个时间管理模式），都可以有自己的一套方式来实践。本篇文章主要以 OmniFocus 3 为载体来介绍这些内容。</p>

<p>每个人都有一套适合自己的工作流，所以读者不必要完全按照我所写的来操作，正确的方式是从中获取一些灵感，实践并融合到自己的工作流当中。</p>

<h2 id="toc_0">什么是一个好的任务管理系统</h2>

<p>首先，任务管理系统的目的是为了更好得完成任务，一切脱离这个基本条件的系统都是不可用的。如果你觉得一个最简单的 Todo List 就能很好地完成任务，那么这就是最适合你的任务管理系统。</p>

<p>在我看来，一个优秀的任务管理系统至少需要满足以下条件：</p>

<ol>
<li>收集能力</li>
<li>在特定的情况下要知道可以做哪些事情</li>
</ol>

<p>「收集能力」指的是这个任务系统要能够容纳（几乎）所有的内容，一个任务、一条想法、一封未读的邮件、一个笔记、一个链接、没有报销的发票等等。</p>

<p>具体实践起来并不是真的需要把所有的东西都塞进任务系统里面，例如我使用 Evernote 作为剪裁和笔记的工具，很显然把每条笔记都复制一份到 OmniFocus 中很不现实，但是我会在 OmniFocus 中添加一个「定期清理 Evernote Inbox」的任务，这样就相当于把 Evernote 作为 OmniFocus 的子 Inbox，来统一进行管理。对于一些支持 URL Schema 的应用，完全可以在 OmniFocus 中建立一个链接直接指定，这样在 OmniFocus 中也可以直接打开其他应用中的内容了。</p>

<p>收集能力决定了要处理的内容，第二个条件则决定了一个任务系统是否高可用。具体的情境来说，你要知道早上的时候该干哪些事，工作的时候该干哪些事，无聊的时候该干哪些事等等，而不是依靠大脑来记录什么时间要做什么事情，这样很容易进入游离的状态。</p>

<p>一个任务系统做好了这两件事情，至少不会让你感到「有事可做，但无从下手」的状况，真正的执行还是需要靠自己的意志力了，从另一种情况下来说，即使意志力不强，完全可以找一些「不太重要、很轻松」的事，这在一定程度上利用了「结构性拖延」的办法来完成一些任务。</p>

<h2 id="toc_1">任务管理系统的三要素</h2>

<p>到现在为止，我还没有讲到一种具体工具的使用。因为工具是次要的，了解了本质的思想，使用什么工具都没有问题。纵观各种任务管理的工具：OmniFocus、Todoist、Things、org-mode，它们支持的功能也各不相同，Project、无限层级、Defer、Due、Repeat、Context、Label、Tag、Filter、Perspective 等等，有没有被这些名词给吓到？难道我们每切换一种系统都需要再重新学习一遍？</p>

<p>抛开这些名词，我们来分析一下一个任务系统到底是由什么组成的。在我看来，一个任务系统最本质的东西只有三个：任务、附加元素和过滤器。</p>

<p><strong>任务</strong>：一个最小可执行的单元即为一个任务。这个是最好理解的，所以不做过多解释。</p>

<p><strong>附加元素</strong>：作用在任务上的不同维度的限制。这句话读起来有点拗口，举个简单例子，「去 XXX 取快递（截止今天 10:00）」，其中，「截止今天 10:00」就是在时间维度上对这个任务的一个限制。同样的，「项目」、「标签」等等这些都是作用在某个任务上的附加元素。</p>

<p><strong>过滤器</strong>：组合不同附加元素的过滤规则。只有附加元素并没有什么实际的作用，但是有了过滤器之后，就可以编写不同的过滤规则来过滤指定规则的任务。例如，我想知道「最近 10 天内重要的事情」，那么过滤规则可能就是「Due date &lt; 10 and flagged」。</p>

<p>了解了上面三个基本的概念，那么再重新审视各种任务管理工具，就可以从一个比较宏观的角度来看待了，这也可以避免切换工具造成的重新学习成本。</p>

<h2 id="toc_2">OmniFocus 3 实践</h2>

<p>把上面任务系统的基本三要素运用到 OmniFocus 上，任务就是一个个的单独 Todo item，附加元素就是 Todo item 所属的项目、Due Date、Defer Date、Tags、Flag、Repeat rule 等，过滤器就是透视（Perspective）。</p>

<p>接下来的内容我会通过 OmniFocus 3 为载体，来具体介绍如何实现一个可靠的任务管理系统，并介绍一些实际实践过的 Workflow 流程。</p>

<h3 id="toc_3">项目的设定</h3>

<p>项目的设定建议使用统一的一套项目设定，例如，我的 OmniFocus 的项目和 Evernote 笔记的项目几乎是一一对应的，这样做的好处可以保证你的项目分类始终处于一个有序的状态。</p>

<p>如果想保证项目比较有序，分成三个层级即可：大的领域（Folder）- 子领域（Folder）- 项目（Project）。</p>

<p>例如，我的项目分级如下：</p>

<p><img src="media/15429374209015/15429375074012.jpg" alt=""/></p>

<p>我主要分成了 5 个比较大的项目：工作、学习、生活、兴趣、系统，基本上可以涵盖涉及到的所有领域了。在每个大的项目中再细分出小的项目，这个可以根据自己的需要来进行细分。OmniFocus 支持无限层级的项目划分，但是个人只建议分三层，最后一层直接是任务就可以了，这样可以保证项目层级不会过于复杂。</p>

<p>可以看到很多项目下面都有用<code>[]</code>括起来的项目，这个是 Single List 项目，这样一些不属于某个项目里面的内容就可以放到这个列表里了。</p>

<p>项目的分类并不一定要按照我的来，只要保证一定的规整化即可。</p>

<p>一些项目设定的 Tips：</p>

<ul>
<li>如果不是 Single List，项目需要一个既定的完成条件，在某一时刻或某一条件下，这个项目是要能够被标记为 Completed 或者 Dropped，这样可以避免一个项目长时间地呆在任务系统中；</li>
<li>项目中的任务最好是最小可执行的，如果是比较大的任务，可以利用 OmniFocus 的无限任务层级继续细分。</li>
</ul>

<h3 id="toc_4">标签的设定</h3>

<p>OmniFocus 3 的标签系统可以在自带功能的基础上添加更多的附加元素，从而在设定过滤器的时候更加准确地过滤出符合的任务。基于此目的，可以根据需求设定出适合自己的标签系统。</p>

<p>OmniFocus 3 缺失的一个很常见的功能就是 Schedule，一个任务在时间维度上应该有有截止日期（Due）和安排日期（Schedule）两个元素，Due 表示在某一天之前必须被完成，Schedule 表示被安排到某一天做，所以可以设定如下标签来完成 Schedule 的功能：</p>

<ul>
<li>Schedule
<ul>
<li>ThisMonth：被安排到这个月</li>
<li>ThisWeek：被安排到这周</li>
<li>Today：被安排到今天</li>
<li>Recenly：最近需要做的事</li>
</ul></li>
</ul>

<p>这样在做计划的时候，打上对应的标签，就可以使用过滤器过滤出对应的任务了，比如我想看「这个月和工作相关的任务」，那么就可以指定 Project 为「Work」项目，标签为「ThisMonth」，这样对应的任务就可以使用这个过滤器过滤出来，具体的过滤器设定下面会讲到。</p>

<p>另外一个可以借鉴的设定就是精力值标签：</p>

<ul>
<li>Energy
<ul>
<li>LowEnergy</li>
<li>MediumEnergy</li>
<li>HighFocus</li>
</ul></li>
</ul>

<p>例如，我们工作了一整天之后，还剩一段时间才下班，精力已经下降到一个很低的值，这个时候已经不适合完成一些需要非常专注的工作了，但是一些工作上的杂事，例如打印东西，提交报表等简单的工作可以利用这个时间来完成，这个时候我们就可以设定一个过滤器，过滤出 Project 为「Work」，标签为「LowEnergy」的任务。</p>

<p>我们可以看到，标签系统可以极大地扩展附加元素的内容，给过滤器添加更多的过滤维度。标签系统的设定应该根据自己的需求来，如果设定的标签却没有在过滤器中用到的话，那么也仅仅是个任务添加了一个没有用上的附加元素而已，意义不大。</p>

<h3 id="toc_5">过滤器的设定</h3>

<p>过滤器的目的就是组合各种条件，过滤出所需要的任务来，之前所有的任务上的附加元素都是为了过滤器而设定的。</p>

<p>过滤器在 OmniFocus 3 中就是透视（Perspective）。在 OmniFocus 3 中，透视功能被很大的增强了，支持类似于 iTunes 智能播放列表一样的设定。</p>

<p><img src="media/15429374209015/15429375353594.png" alt=""/></p>

<p>但是仔细使用下来会发现，OmniFocus 3 的过滤器设定依然是有局限的，并不能想 iTunes 那样自由地对元素进行操作</p>

<p><img src="media/15429374209015/15429375496942.png" alt=""/></p>

<p>尽管如此，相比较 OmniFocus 2 残疾一样的过滤器设定，已经好太多了。用过 Todoist 的同学可能会知道，Todoist 的过滤器设定支持自定义的一套语法，OmniFocus 3 与之相比，还是要差了许多，主要是提供的可过滤元素太少，过滤条件也不够自由，但是结合标签系统也基本上能满足日常的使用。</p>

<p>同标签系统一样，过滤器的设定依然需要结合自己的情况来。我主要设定了以下几个过滤器，这些过滤器都是在实践中经常使用到的。</p>

<p><img src="media/15429374209015/15429375650764.png" alt=""/></p>

<h4 id="toc_6">Routine 过滤器</h4>

<p>这个过滤器主要被用于制定计划，例如，我每天早上去公司都会有 Morning Review，来规划今天一天的工作任务。这个时候，我只需要打开这个过滤器，依次把上面的事情做完，今天的计划安排就被制定好了。</p>

<p>过滤器的详细设定如下：</p>

<p><img src="media/15429374209015/15429375761901.png" alt=""/></p>

<p>其中，「Routine」Folder 中就是设定的具体内容：</p>

<p><img src="media/15429374209015/15429375828892.png" alt=""/></p>

<p>这一个过滤器的设定是和我的 Workflow 紧密相连的，如果你没有做 Morning Review 之类的习惯，可以不需要设定这个过滤器。</p>

<h4 id="toc_7">Today 过滤器</h4>

<p>这个过滤器被使用的次数最多，类似于 Forecast 的功能，但是相比较 Forecast，自定义的程度更大。</p>

<p>过滤器的详细设定如下：</p>

<p><img src="media/15429374209015/15429375913788.png" alt=""/></p>

<p>这个过滤器将会把符合以下条件的任务过滤出来：</p>

<ul>
<li>即将截止或者标注为 Today 标签的任务</li>
<li>状态为 Available 的任务</li>
<li>非 Routine Folder 下的任务</li>
</ul>

<p>显示方式以 Project 为维度显示：</p>

<p><img src="media/15429374209015/15429375983004.png" alt=""/></p>

<p>对比 Forecast Perspective，它只是把对应的任务都展示了出来，在任务的层级上没有自定义的那么清晰。</p>

<p><img src="media/15429374209015/15429376033628.png" alt=""/></p>

<p>如果想要 Forecast 显示特定标签的任务，可以参考如下设定：</p>

<p><img src="media/15429374209015/15429376084839.png" alt=""/></p>

<h4 id="toc_8">Work 过滤器</h4>

<p>这个过滤器和 Today 类似，只不过指定了所属项目为「Work」文件夹下面的任务，这个主要是在工作中只想专注于和工作相关的任务。</p>

<p>过滤器的详细设定如下：</p>

<p><img src="media/15429374209015/15429376147803.png" alt=""/></p>

<p>除了指定了特殊的项目目录，其他的设置和 Today 的设定没有区别。</p>

<h4 id="toc_9">To-Sth 过滤器</h4>

<p>日常的使用中，我会把没有看的文章、需要写的东西、要读的书、要搜索的内容都存在 OmniFocus 中，所以需要一个过滤器能够快速过滤出这些内容。</p>

<p>首先使用这个过滤器需要先设置一套标签系统：</p>

<p><img src="media/15429374209015/15429376202346.png" alt=""/></p>

<p>过滤器的详细设定如下：</p>

<p><img src="media/15429374209015/15429376264748.png" alt=""/></p>

<p>实际的使用场景：比如我想阅读一些和 Python（一门编程语言）相关的内容，那么我只需要打开这个 Perspective，挑选标签为「To-Read」，然后从搜索框中搜索 Python 关键字就可以了。</p>

<p><img src="media/15429374209015/15429376317835.png" alt=""/></p>

<h4 id="toc_10">Future 过滤器</h4>

<p>这个过滤器主要被用于制定计划，在 Weekly Review 和 Daily Review 中会被频繁地使用到。需要基于以下的标签设定：</p>

<p><img src="media/15429374209015/15429376376699.png" alt=""/></p>

<p>过滤器的详细设定如下：</p>

<p><img src="media/15429374209015/15429376419800.png" alt=""/></p>

<h4 id="toc_11">EasyDo 过滤器</h4>

<p>这个过滤器会把一些简单的或者不需要太多精力的任务过滤出来</p>

<p>过滤器的详细设定如下：</p>

<p><img src="media/15429374209015/15429376481889.png" alt=""/></p>

<p>完成时间小于 15 分钟或者被标注为「LowEnergy」标签的任务会被过滤出来。</p>

<h3 id="toc_12">Workflow</h3>

<p>今年使用 OmniFocus 已经完成了 1500+ 的任务，经过这么长时间的使用，已经有了自己的一套任务处理流程了，随着 OmniFocus 3 的更新，这套任务处理的流程也经过了一些优化。在这整个 Workflow 中，主要分为三个部分：计划、执行、总结。</p>

<h4 id="toc_13">计划</h4>

<p>很多人都不重视计划这个环节，想到什么做什么，这样不仅会做事没有条理，也会分不清任务的优先级。</p>

<p>一般来说，如果不知道怎么做计划的话，有一个长期计划和一个短期计划就可以了。长期计划主要是一个大体的方向，可以是年度计划或者月度计划；短期计划则需要明确具体要做哪些事情，可以是周计划或者日计划。</p>

<p>实践过程中使用最多的就是周计划和日计划。在 OmniFocus 中，我设定了两个项目，分别是 Weekly Review 和 Morning Review。</p>

<p>在做 Weekly Review 的时候，我会先在 Evernote 中大概写一下这周需要做哪些事情，然后在 OmniFocus 中打开 Future 过滤器，选择 ThisMonth 标签，把需要完成的项目和任务打上 ThisWeek 标签。</p>

<p>在做 Morning Review 的时候，我会打开 Future 过滤器，选择 ThisWeek 和 Recently 标签，然后挑选今天需要完成的事情打上 Today 标签，这样，在 Today 和 Work 过滤器中就可以看到今天要做的事情了。</p>

<h4 id="toc_14">执行</h4>

<p>执行应该是整个 Workflow 中最重要的一个环节，如果只是计划了，但是最后任务却没有被完成，那做计划也只是白费力气。</p>

<p>执行的关键就是要在对的时间内做对的事，这也是为什么要设置那么多过滤器的原因，在工作的时候就只展示工作相关要做的事，在没有精力的时候就只展示简单易做的事情。</p>

<p>如果你做事情的时候很容易分心，可以参考一下番茄工作法，一般我会设置为专注 50 分钟，然后休息 10 分钟。默认的 25 分钟时间过短，可能刚进入状态就要被打断。</p>

<p>另外可以尝试使用「结构化拖延法」（Structured Procrastination）。结构化拖延法就是忽略优先级高的事，而是从小的事，优先级比较低的事情开始做，这样慢慢地进入工作的状态，然后再去完成优先级高的事情。</p>

<h4 id="toc_15">总结</h4>

<p>总结是为了更好地计划。总结给计划提供了更多的参考条件，可以当做计划的一把标尺。</p>

<p>很多时候我们做计划都会看高自己完成任务的能力，结果就是一周过去了发现实际上并没有能够完成计划的内容，如果没有总结的话，下次做计划的时候还是按照这种量来计划，必定也是完成不了的，久而久之，就失去了做计划的动力。如果每周都做总结的话就能够知道这周完成了哪些内容，哪些内容没有完成，原因是什么，这样就能在下周的计划里面做改进。这种「反馈-调节」的机制可以促进整个任务处理流程的良性循环。</p>

<p>一方面，如果你在 Evernote 中有写周计划的话，那么在每周的 Review 时候就可以打开对应的项目，在 Project 视图里面选择 All，这样就可以把所有的任务（包括已完成的）都展示出来，方便对照查看完成了哪些，又有哪些是没有完成的。</p>

<p><img src="media/15429374209015/15429376573108.png" alt=""/></p>

<p>另一方面，OmniFocus 3 提供了自带的 Review 透视，建立每个项目的时候可以选择多少天 Review 一次。实践上，一般工作上需要每天跟进的项目，会把 Review 的时间设置为每天一次，一般的项目设置为一周 Review 一次即可。为了防止忘记 Review，可以把这个 Review 的任务添加到 Morning Review 或者 Weekly Review 中。</p>

<h2 id="toc_16">后记</h2>

<p>OmniFocus 2 刚发布时就开始使用了，期间还使用过 org-mode 和 Todoist，OmniFocus 3 发布了之后就立马重新迁移过来。虽然 OmniFocus 3 还存在着一些不足，但是已经能够很好地满足目前的工作流了。主要的使用场景大部分是在 macOS 上，iOS 基本上只是用来查看。</p>

<p>这篇文章中所写的内容都是经过了很长时间实践之后得出的经验，一个好的任务系统是需要不断优化迭代的，如果你觉得自己的系统不怎么好用，不妨想一下哪些地方需要优化，然后慢慢改进它。掌握了任务管理的本质之后，不管是切换到什么工具都能够游刃有余。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三十五周]]></title>
    <link href="http://jiayuanzhang.com/2018-week-35.html"/>
    <updated>2018-09-01T16:39:12+08:00</updated>
    <id>http://jiayuanzhang.com/2018-week-35.html</id>
    <content type="html">
<![CDATA[<p>重启之前写 Weekly Review 的习惯，一方面为了总结上一周都做了什么，另一方面也为了督促自己多多做事，不要碌碌无为。</p>

<p>2018 这半年多的时间里面博客一直没有再继续写下去，工作占去了大部分的时间，剩下的时间又都分配给爱好，所以写博客这件事就暂时搁置了下来。过去一年的时间里面主要发展了两个爱好，摄影和滑板，即使是爱好，也会想把它做好，所以空闲下来的时间大部分精力都花在了上面。经过这半年多的时间来看，一个人不太可能同时把好几件事做得不错，所以在未来的一段时间内，需要考虑一下舍弃掉一项爱好了，或者只是仅仅当做爱好，不用去过于较真。</p>

<p>自从工作了，发现刻意学习专业知识的时间越来越少，大部分情况都是工作中遇到什么东西不太了解然后找相关资料学习一下，Vue.js、PHP 就是在工作中学会的，虽然不能说熟练，但是应对基本开发内容还是没什么问题。Vue.js 看了一下官方文档就开始写了，PHP 甚至都没有看什么东西，就只是看了一下公司之前的源码，毕竟语言的内容大部分都是相通的，PHP 又和 Python 同为动态语言，基本上东西都差不多，熟悉了一天就开始上手开发业务了，增删改查的内容也不太需要太多技术含量。</p>

<p>这种学习方式可以被称之为「自顶向下」的学习方法，和学校的「自底向上」的学习方法孰优孰劣，还得视情况而来。前者可以快速用起来，不用了解底层的内容，上手快，耗费时间短，但很容易停留在「顶」，没有继续深入下去，最后浮于表面；后者更加系统，学完会有一个整体的脉络，但是耗费时间长，底层的知识没办法实践，最后流于理论。所以正确的方式应该是把这两者结合起来，例如我主要是一个「后端开发工程师」，那对于 Vue.js 的一些底层实现理论，现在确实没有必要太了解，之后有需要的时候再看也不迟；而 CPython 底层的实现却是需要了解的内容，了解底层实现的缺陷在哪里，才能更好地进行优化。所以学习也要分好优先级，毕竟精力有限，不太重要的学习内容可以先靠后。</p>

<p>说道学习，再谈一下「刻意学习」的问题，学习不是堆时间、拼谁比谁学的更久，更重要的是用对方法，这一点在学滑板的过程中领会很深。之前很长一段时间练习滑板都是在堆砌时间，虽说也有进步，但是太缓慢了，大部分的时候都是呆在「舒适区」内做一些自己已经熟练的动作，后来看到了 Rodney Mullen <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 的学习方法：</p>

<blockquote>
<p>In short, Mullen is a very driven, smart individual. While many skaters spend a similar amount of hours skating every day as Mullen has, very few use those hours as efficiently as he did.</p>

<p>The minimum amount of time to spend on the board to impove is two hours a day, every day, without fail. One hour a day is enough to maintain skills, but you&#39;ll never impove. Five hours+ a day is the key to rapid development.</p>

<p>Mullen prefers to skate alone, and so those two hours are spent skateboarding, and nothing else. In the 80s, he&#39;d use a Casio watch with a stopwatch to time his sessions and make sure his sessions were long enough, even pausing the stopwatch when he took a short break.</p>

<p>He breaks down his five hour weekend sessions thus:</p>

<ul>
<li>30 minutes: warming up, not worring about consistency.</li>
<li>3 hours: practicing his contest run, breaking it down into three 40 second segments, and doing them over and over again until he could do them without looking at his board.</li>
<li>90 minutes: learning new tricks.</li>
</ul>

<p>He also kept a skate notebook, writing down ideas for tricks, noting down observations on how his board flipped, and observing how different foot positions affected tricks.</p>
</blockquote>

<p>简单来说，Mullen 一直在按照计划来练习，而不是漫无目的地「玩」滑板，这也是他能成为大师的原因之一吧。</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>滑板教父，街式滑板的发源者。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员修炼之道》阅读笔记（二）]]></title>
    <link href="http://jiayuanzhang.com/notes-on-the-pragmatic-programmer-2.html"/>
    <updated>2017-08-17T07:26:48+08:00</updated>
    <id>http://jiayuanzhang.com/notes-on-the-pragmatic-programmer-2.html</id>
    <content type="html">
<![CDATA[<h3 id="toc_0">重复的危害</h3>

<p>系统中的每一项知识都必须具有单一、无歧义、权威的表示。（感觉翻译得怪怪的）</p>

<blockquote>
<p>Tip 11<br/>
DRY - Don&#39;t Repeat Yourself<br/>
不要重复你自己</p>
</blockquote>

<h4 id="toc_1">重复是怎样发生的</h4>

<ul>
<li>强加的重复（imposed duplication）：开发者觉得他们无可选择 —— 环境似乎要求重复。</li>
<li>无意的重复（inadvertent duplication）：开发者没有意识到他们在重复信息。</li>
<li>无耐性的重复（impatient duplication）：开发者偷懒，他们重复，因为那样似乎更容易。</li>
<li>开发者之间的重复（interdeveloper duplication）：同一团队（或不同团队）的几个人重复了同样的信息。</li>
</ul>

<h5 id="toc_2">强加的重复</h5>

<ul>
<li><p>信息的多种表示</p>
<p>我们也许在编写客户-服务器应用，在客户和服务器端使用了不同的语言，并且需要在两端都表示某种共有的结构。我们或许需要一个类，其属性是某个数据库表的 schema。</p>
<p>解决办法是编写简单的过滤器或代码生成器。可以在每次构建（build）软件时，使用简单的代码生成器，根据公共的元数据表示构建多种语言下的结构。可以用最初用于构建 schema 的元数据，自动生成类定义。</p></li>
<li><p>代码中的文档</p>
<p>代码为什么需要注释：糟糕的代码才需要许多注释。</p>
<p>DRY 法则告诉我们，要把低级的知识放在代码中，它属于那里；把注释保留给其他高级说明。否则，我们就是在重复知识，而每一次改变都意味着既要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟。</p></li>
<li><p>文档与代码</p>
<p>你撰写文档，然后编写代码。有些东西变了，你修订文档、更新代码。文档和代码都含有同一知识表示。</p>
<p>可以根据文档来生成测试。</p></li>
<li><p>语言问题</p>
<p>许多语言会在源码中强加可观的重复。如果语言使模块的接口与其实现分离，就常常会出现这样的情况。C/C++ 有头文件，在其中重复了被导出变量、函数和（C++）类的名称和类型信息。</p>
<p>再思考一下头文件和实现文件中的注释。绝对没有理由在这两种文件之间重复函数或类头注释（head comment）。应该用头文件记载接口问题，用实现文件记载代码的使用者无需了解的实际细节。</p></li>
</ul>

<h5 id="toc_3">无意的重复</h5>

<p>有时，重复来自设计中的错误。</p>

<p>举个例子：</p>

<pre><code class="language-cpp">class Line {
    public:
        Point start;
        Point end;
        double lenght;
};
</code></pre>

<p>第一眼看上去这个类似乎是合理的。线段显然有起点和终点，并总是有长度的。但这里有重复，长度是由起点和终点决定的：改变其中一个，长度就会变化。最好是让长度编程计算字段：</p>

<pre><code class="language-cpp">class Line {
    public:
        Point start;
        Point end;
        double lenght() { return start.distanceTo(end); }
};
</code></pre>

<h5 id="toc_4">无耐性的重复</h5>

<p>每个项目都有时间压力。</p>

<p>如果你觉得受到了诱惑，想一想古老的格言「欲速则不达」。你现在也许可以节省几秒钟（感觉不止），但以后可能损失几小时。（如果一个人不打算在公司长久待下去的话是会写出重复的代码的，所以 code review 要做好）</p>

<p>无耐性的重复是一种容易检测和处理的重复形式，但那需要你接受训练，并愿意为避免以后的痛苦而预先话一些时间。</p>

<h5 id="toc_5">开发者之间的重复</h5>

<p>或许最难检测和处理的重复发生在项目的不同开发者之间。处理这个问题的最佳方式是鼓励开发者进行主动地交流。</p>

<blockquote>
<p>Tip 12<br/>
Make It Easy to Reuse<br/>
让复用变得容易</p>
</blockquote>

<p>你所要做的就是营造一种环境，在其中找到并复用已有的东西，比自己编写更容易。</p>

<h3 id="toc_6">正交性</h3>

<p>如果你想要制作易于设计、构建、测试及扩展的系统，正交性是一个十分关键的概念。</p>

<h4 id="toc_7">什么是正交性</h4>

<p>「正交性」是从几何学中借来的术语。如果两条直线相交成直角，它们就是正交的。</p>

<p>在计算机技术中，该术语用于表示某种不相依赖性和解耦性。如果两个或更多事物中的一个发生变化，不会影响到其他事物，这些事物就是正交的。</p>

<h4 id="toc_8">正交的好处</h4>

<p>非正交系统的改变与控制更复杂是其固有的性质。当任何系统的各组件互相高度依赖时，就不在具有局部修正这样的事情。</p>

<blockquote>
<p>Tip 13<br/>
Eliminate Effects Between Unrelated Things<br/>
消除无关事物之间的影响</p>
</blockquote>

<p>我们想要设计自足（self-contained）的组件：独立、具有单一、良好定义的目的（内聚）。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你不改变组件的外部接口。</p>

<ul>
<li>提高生产率
<ul>
<li>改动得以局部化，所以开发实践和测试时间得以降低。编写多个相对较小的、自足的组件更为容易，你可以设计、编写简单的组间，对其进行单元测试。当你增加新代码时，无需不断改动已有的代码。</li>
<li>正交的途径还能够促进复用。如果组间具有明确而具体的、良好定义的责任，就可以把它们和新组件整合到一起。</li>
<li>如果你对正交的组件进行组合，生产效率会有相当微妙的提高（M x N &gt; M * (N - i), i 为 M、N 重复内容）</li>
</ul></li>
<li>降低风险
<ul>
<li>有问题的代码区域被隔离开来。</li>
<li>所得的系统更健壮。</li>
<li>政教系统很可能得到更好的测试。</li>
</ul></li>
</ul>

<h4 id="toc_9">项目团队</h4>

<p>怎样把团队划分为责任得到了良好定义的小组，并使重叠降至最低呢？没有简单的答案。我们的偏好是从使基础设施与应用分离开始。每个主要的基础设施组间（数据库、通信接口、中间件层等）有自己的子团队。如果应用功能的划分显而易见，那就照此划分。然后我们考察现有的人员，并对分组进行相应的调整。</p>

<p>在讨论每个所需改动时需要涉及多少人。人数越多，团队的正交性就越差。</p>

<h4 id="toc_10">设计</h4>

<p>对于正交设计，有一种简单的测试方法。一旦设计好组件，问问你自己：如果我显著地改变了某个特定功能背后的需求，有多少模块会受到影响？在正交系统中，大难应该是「一个」。</p>

<p>不要依赖你无法控制的事物属性。</p>

<h4 id="toc_11">工具箱与库</h4>

<p>在你引入第三方工具箱和库时，要注意保持系统的正交性。要明智地选择技术。它是否会迫使你对代码进行不必要的改动。如果对象持久模型（object persistence scheme）是透明的，那么它就是正交的。如果它要求你以一种特殊的方式创建或访问对象，那么它就不是正交的。</p>

<p>正交性的另一个有趣的变体是面向切片编程（Aspect-Oriented Programming, AOP）。AOP 能让你在一个地方表达本来会分散在源码各处的某种行为。例如，日志消息通常是在源码各处、通过显式地调用某个日志函数生成的。通过 AOP，你可以把日志功能正交地实现到要进行日志记录的代码中。（Python 中的装饰器就可以实现这个功能）</p>

<h4 id="toc_12">编码</h4>

<p>你可以将若干技术用于维持正交性：</p>

<ul>
<li>让你的代码保持「解耦」：编写不会没有必要地向其他模块暴露任何事情、也不依赖其他模块具体实现的模块。</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数：使用 Strategy（策略）模式</li>
</ul>

<p>养成不断地批判对待自己打的代码的习惯，寻找任何重新进行组织、以改善其结构和正交性的机会。这个过程叫重构（refactoring）。</p>

<h4 id="toc_13">测试</h4>

<p>正交地设计和实现的系统也更易于测试，因为系统的各组件间的交互是形式化和有限的，更多的系统测试可以在单个的模块进行。</p>

<h3 id="toc_14">可撤销性</h3>

<blockquote>
<p>如果某个想法是你唯一的想法，再没有什么比这更危险的事了。 —— Emil-Auguste Chartier</p>

<p>Tip 14<br/>
There Are No Final Decisions<br/>
不存在最终决策</p>
</blockquote>

<p>通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。</p>

<h3 id="toc_15">曳光弹</h3>

<p>为了在代码中获得「曳光弹」的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求。</p>

<blockquote>
<p>Tip 15<br/>
Use Tracer Bullets to Find the Target<br/>
用曳光弹找到目标</p>
</blockquote>

<p>曳光弹告诉你击中的是什么，那不一定总是目标，于是你调整准心，直到完全击中目标为止，这正是要点所在。</p>

<h3 id="toc_16">原型与便笺</h3>

<p>你可以为下列事物制作原型：</p>

<ul>
<li>架构</li>
<li>已有系统中的新功能</li>
<li>外部数据的结构或内容</li>
<li>第三方工具或组件</li>
<li>性能问题</li>
<li>用户界面设计</li>
</ul>

<p>原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。那才是原型制作的要点所在。</p>

<blockquote>
<p>Tip 16<br/>
Prototype to Learn<br/>
为了学习而制作原型</p>
</blockquote>

<h4 id="toc_17">怎样使用原型</h4>

<p>在构建原型时，你可以忽略哪些细节？</p>

<ul>
<li>正确性：你也许可以在适当的地方使用虚假的数据；</li>
<li>完整性：原型也许只能在非常有限的意义上工作；</li>
<li>健壮性：错误检查很有可能不完整。如果你偏离预定路径，原型就可能崩溃，这没有关系；</li>
<li>风格：原型代码可能没有多少注释或文档。</li>
</ul>

<p>因为原型应该遮盖细节，并聚焦于所考虑系统的某些具体方面，你可以用非常高级的语言实现原型。高级的脚本语言能让你推迟考虑许多细节，并且仍然能制作出可以工作的代码。</p>

<h4 id="toc_18">制作架构原型</h4>

<p>一些你可以在架构原型中寻求解答的具体问题：</p>

<ul>
<li>主要组间的责任是否得到了良好的定义？是否适当？</li>
<li>主要组间间的协作是否得到了良好的定义？</li>
<li>耦合是否得以最小化？</li>
<li>你能否确定重复的潜在来源？</li>
<li>接口定义和各项约束是否可接受？</li>
<li>每个模块在执行过程中是否能访问到其所需的数据？能够在需要时进行访问？</li>
</ul>

<h3 id="toc_19">领域语言</h3>

<blockquote>
<p>Tip 17<br/>
Program Close to the Problem domain<br/>
靠近问题领域编程</p>
</blockquote>

<p>无论适用于配置和控制应用程序的简单语言，还是用于指定规则或过程的更为复杂的语言，我们认为，你都应该考虑让你的项目更靠近问题领域。通过在更高的抽象层面上编码，你获得了专心解决领域问题的自由，并且可以忽略琐碎的实现细节。</p>

<h3 id="toc_20">估算</h3>

<blockquote>
<p>Tip 18<br/>
Estimate to Avoid Surprises<br/>
估算，以避免发生意外</p>
</blockquote>

<h4 id="toc_21">估算来自哪里</h4>

<ol>
<li>理解提问内容：任何估算练习的第一步都是建立对提问内容的理解。除了上面讨论的精确度以外，你还需要把我问题域的范围。这常常隐含在问题中，但你需要养成在开始猜想之前先思考范围的习惯。</li>
<li>建立系统的模型：根据你对所提问题的理解，建立粗略、就绪的思维模型骨架。</li>
<li>把模型分解为组件：你需要找出描述这些组件怎样交互的数学规则。你将会发现，在典型的情况下，每个组件都有一些参数，会对它给整个模型带来什么造成影响。在这一阶段，只要确定每个参数就行了。</li>
<li>给每个参数指定值：一旦你分解出各个参数，你就可以逐一给每个参数赋值。在这个步骤中你可能会引入一些错误。诀窍是找出哪些参数对结果的影响最大，并致力于让它们大致正确。</li>
<li>计算答案：在计算阶段，你可能会得到看起来很奇怪的答案。不哟啊太快放弃它们，如果你的运算是正确的，那你对问题或模型的理解就很可能是错的。这是非常宝贵的信息。</li>
<li>追踪你的估算能力</li>
</ol>

<h4 id="toc_22">估算项目进度</h4>

<p>在面对相当大的应用开发的各种复杂问题与反复无常的情况时，普通的估算规则可能会失效。为项目确定进度表的唯一途径常常是在相同的项目上获取经验。</p>

<ul>
<li>检查需求</li>
<li>分析风险</li>
<li>设计、实现、继承</li>
<li>向用户确认</li>
</ul>

<blockquote>
<p>Tip 19<br/>
Iterate the Schedule with the Code<br/>
通过代码对进度表进行迭代</p>
</blockquote>

<h3 id="toc_23">总结</h3>

<p>第二章其实更多的再讲团队和产品设计方面的问题，自己在这两方面并没有什么经验。不过 DRY 和正交性的概念还是比较重要的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员修炼之道》阅读笔记（一）]]></title>
    <link href="http://jiayuanzhang.com/notes-on-the-pragmatic-programmer-1.html"/>
    <updated>2017-08-13T13:50:11+08:00</updated>
    <id>http://jiayuanzhang.com/notes-on-the-pragmatic-programmer-1.html</id>
    <content type="html">
<![CDATA[<p>实习到现在差不多两个月了，博客也一直荒废了没写。这次更新就先来写写读书笔记好了。</p>

<p>这本书从书名来看其实很像那种鸡汤类的书，英文名「The Pragmatic Programmer」（注重实效的程序员）看上去就好了许多。<a href="https://book.douban.com/subject/1152111/">豆瓣评分</a> 8.6 分。大一的时候买的书，之前随意地写过几年的玩具代码，所以初读这本书的时候觉得很有道理，但是读完了之后发现什么也没有记住。用<a href="http://blog.youxu.info">徐宥</a>的话来说就是「读者如果没有类似的经历，看到这些珠玑，也只是觉得把玩颇为有趣而已，极少能有同感。」大一的时候读这是这种感觉。</p>

<p>出来实习之后，接触到实际生产中的代码，在代码量比较大的情况下（几十万行），之前书中所讲的一些问题都一一浮现了。为了写出优雅的代码，有必要把这本书再读一遍，可能以后还要反复读很多遍（不是所有的内容看一遍就能内化在心里的），所以每读一部分就记一点笔记，留作日后复习用。</p>

<p>给自己制定以下阅读的计划，因为这本书每一张的内容读起来都比较轻松，所以预计用两周的时间读完：</p>

<ol>
<li>每 1-2 天阅读一章（共 8 章）</li>
<li>每一章都写一篇笔记，读的时候可以做一些摘录，读完一章之后写一篇总结性的笔记；</li>
</ol>

<p>下面是「序言」和「第一章」的笔记。</p>

<hr/>

<h2 id="toc_0">序</h2>

<h3 id="toc_1">注重实效的程序员都有哪些特征</h3>

<ul>
<li>早期的采纳者/快速的改编者：给你一样新东西，你很快能把握它，并把它与你的知识的其余部分结合在一起（尝试新技术）；</li>
<li>好奇：你喜欢提问，你是收集小知识的林鼠（建立自己的知识 wiki）；</li>
<li>批判的思考者：你会首先抓住事实，而不是照搬别人所说的；</li>
<li>有现实感：你会设法理解你面临的每个问题的内在本质（事情有多困难，需要花多长时间完成？）</li>
<li>多才多艺：你尽力熟悉广泛的技术和环境；</li>
</ul>

<p>（审视一下自己，上面几点好像都没有做到，或者说有的做到了但是并不到位。）</p>

<blockquote>
<p>Tip 1<br/>
Care About Your Craft<br/>
关心你的技艺</p>
</blockquote>

<p>如何做到上面所说的？<strong>在你做某件事情的时候思考你在做什么</strong>。</p>

<blockquote>
<p>Tip 2<br/>
Think! About Your Work<br/>
思考！你的工作</p>
</blockquote>

<h3 id="toc_2">它是一个持续的过程</h3>

<p>每天为提炼你所拥有的技能而工作，为把新的工具增加到你的技能列表中二工作。草坪不是一天修成的。</p>

<h2 id="toc_3">第一章：注重实效的哲学</h2>

<h3 id="toc_4">我的源码让猫给吃了</h3>

<blockquote>
<p>在所有的弱点中，最大的弱点就是害怕暴露弱点。—— J.B.Bossuet</p>
</blockquote>

<p>如果你确实同意要为某个结果负责，你就应该切实负起责任。当你犯错误的时候，不要责备别人或别的东西，或是拼凑借口。你可以选择提供解决方案，而不是寻找借口。</p>

<blockquote>
<p>Tip 3<br/>
Provide Options, Don&#39;t Make Lame Excuses<br/>
提供各种选择，不要找蹩脚的借口</p>
</blockquote>

<p>在你走向任何人，告诉他们为何某件事做不到、为何耽搁、为何出现问题之前，先停下来，听一听你心里的声音。在你去告诉他们坏消息之前，是否还有其他你可以再试一试的办法？有时，你其实知道他们会说什么，所以还是不要给他们添麻烦。</p>

<p>（这一点深有感触，在实习的这一段时间里面，经常因为一些小事去麻烦 leader，比如说环境跑步起来，某个莫名其妙的报错等，这虽然有文档不全的原因在，不过自己也没想着去补全文档这种解决办法。）</p>

<h3 id="toc_5">软件的熵</h3>

<p>软件中的无序增长时，程序员们称之为「软件腐烂」（software rot）。</p>

<p>「破窗理论」：以一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里占领、定居或者纵火。又或想像一条人行道有些许纸屑，如果无人清理，不久后就会有更多垃圾，最终人们会视为理所当然地将垃圾顺手丢弃在地上。</p>

<blockquote>
<p>Tip 4<br/>
Don&#39;t Live with Broken Windows<br/>
不要容忍破窗户</p>
</blockquote>

<p>不要留着「破窗户」（低劣的设计、错误决策、或是糟糕的代码）不修，发现一个修一个。</p>

<p>如果没有足够的时间进行适当的修理，可以把出现问题的代码放到注释中，或者是用虚拟的数据来代替。<strong>采取某种行动防止进一步破坏，并说明情势处在你的控制之下</strong>。</p>

<p>如果你发现自己在有好些破窗户的项目里工作，会很容易产生这样的想法：「这些代码的其余部分也是垃圾，我只要照着做就行了。」</p>

<h3 id="toc_6">石头汤与煮青蛙</h3>

<blockquote>
<p>Tip 5<br/>
Be a Catalyst for Change<br/>
做变化的催化剂</p>
</blockquote>

<p>（有的时候想要做出一个新功能，可以先开发一个简单的版本，然后诱导别人往其中添加新功能。）</p>

<blockquote>
<p>Tip 6<br/>
Remember the Big Picture<br/>
记住大图景</p>
</blockquote>

<p>当你设法催生变化时，你能否确定你是在做石头汤还是青蛙汤？决策是主观的还是客观的？</p>

<h3 id="toc_7">足够好的软件</h3>

<blockquote>
<p>Tip 7<br/>
Make Quality a Requirements Issue<br/>
使质量称为需求问题</p>
</blockquote>

<p>不要因为过度修饰和过于精于求精而破坏完好的程序。继续前进，让你的代码凭借自己的质量站立一会儿，它也许不完美，但不用担心：它不可能完美。</p>

<h3 id="toc_8">你的知识资产</h3>

<blockquote>
<p>知识上的投资总能得到最好的回报。—— 本杰明·富兰克林</p>
</blockquote>

<p>管理知识资产与管理金融资产非常相似：</p>

<ul>
<li>严肃的投资者定期投资</li>
<li>多元化是长期成功的关键：你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特定技术的各种特性，但不要就此止步。</li>
<li>聪明的投资者在保守的投资和高风险、高回报的投资之间平衡他们的资产</li>
<li>投资者设法低买高卖，以获取最大回报：在新兴的技术流行之前学习它可能就和找到被低估的股票一样困难，但所得到的就和那样的股票带来的收益一样。</li>
<li>应周期性地重新评估和平衡资产</li>
</ul>

<blockquote>
<p>Tip 8<br/>
Invest Regularly in YOur Knowledge Portfolio<br/>
定期为你的知识资产投资</p>
</blockquote>

<ul>
<li><strong>每年至少学习一种新语言</strong>。</li>
<li><strong>每季度阅读一本技术书籍</strong>。一旦你养成习惯，就一个月读一本书。在你掌握了你正在使用的技术之后，扩宽范围，阅读一些与你的项目无关的书籍。</li>
<li><strong>也要阅读非技术书籍</strong>。</li>
<li><strong>上课</strong>。</li>
<li><strong>参加本地用户组织</strong>。不要只是去听讲，而要主动参与。</li>
<li><strong>试验不同的环境</strong>。</li>
<li><strong>跟上潮流</strong>。订阅商务杂志和其他期刊。</li>
<li><strong>上网</strong>。</li>
</ul>

<p>持续投入非常重要，一旦你熟悉了某种新语言或技术，继续前进，学习另外一种。设法把你学到的东西应用到你当前的项目当中，即使你的项目没有使用该技术，你或许也能借鉴一些想法。</p>

<p>所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先规划。让自己在空闲的片刻时间里总有东西可读。</p>

<p>最后一个药店是，批判地思考你读到的和听到的。你需要确保你的资产中的知识是准确的。</p>

<blockquote>
<p>Tip 9<br/>
Critically Analyze What You Read and Hear<br/>
批判地分析你读到的和听到的</p>
</blockquote>

<h3 id="toc_9">交流</h3>

<blockquote>
<p>Tip 10<br/>
It&#39;s Both What You Say and the Way You Say It<br/>
你说什么和你怎么说同样重要</p>
</blockquote>

<p>除非你生活在真空中，你猜不需要交流，交流越有效，你就越有影响力。</p>

<h2 id="toc_10">总结</h2>

<p>大概花了两个多小时的时间把第一章的内容看了一遍，顺便摘录了一些内容。这一章其实更多的是讲「道」层面上的内容，与技术内容关联不大，但又是至关重要的，做好了上面几点可以从「码农」蜕变成「程序员」，能有自己的思考，能够与他人交流，能够对自己进行投资，而不是一味地按照要求写代码。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Week 19：时间管理]]></title>
    <link href="http://jiayuanzhang.com/2017-week-19.html"/>
    <updated>2017-05-07T16:59:39+08:00</updated>
    <id>http://jiayuanzhang.com/2017-week-19.html</id>
    <content type="html">
<![CDATA[<p>之前有在博客上写 Weekly Review 的习惯，后来因为被朋友说博客真水然后都撤下来了，有些文章确实是类似于「流水账」的记事，但也有一些是围绕这周做的东西来讨论的。总的来说，写 Weekly Review 对自己帮助还是很大的，可以在一周中 Focus 一个特定的主题，而不是想到什么做什么，所以这个系列以后还会继续写下去，只是写的内容更加具体一天，可以围绕着这周的 Project，或者这周听的音乐，或者读的书之类的。以前的文章看情况要不要放上来。</p>

<p>这周算是正式把我的任务管理系统从 org-mode 转移到 Todoist 上来了。在不考虑时间成本和易用性上来说，org-mode 依然是目前我认为最完备的任务和时间管理系统，我用它来：</p>

<ol>
<li>任务管理：类似于 OmniFocus 的多层级任务管理，支持标签和优先级，可以自定义过滤视图</li>
<li>时间记录：按照项目的方式来记录时间，基本是在做哪件事之前把计时器打开，一个番茄时间后自动关闭，可以自定义生成各种时间报表</li>
<li>番茄工作法</li>
</ol>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-05-07-092455.jpg" alt=""/><br/>
<center style="font-style: italic; color: #8F8F8B; font-size:12px;">Spacemacs org mode</center></p>

<p>自定义生成的时间记录表：</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-05-07-092544.jpg" alt=""/></p>

<p>虽然 org-mode 的优点众多，但是始终是一个基于 Emacs 的 major mode，所以诸多限制在所难免：</p>

<ol>
<li>没有一个简单易用的移动端</li>
<li>没办法做到全局 capture，虽然借助 Alfred 的 Workflow 和 Elisp 脚本能够实现这一功能，但是使用起来体验并不是很好</li>
<li>编辑功能过重，很显然，做任务管理不需要多么高效的编辑操作，类似于 OmniFocus 使用鼠标 + 快捷键才是更高效的方法，在 Emacs 里经常编辑速度过快把整个文件搞乱了</li>
</ol>

<p>不用 OmniFocus 的原因是本来就是从 OmniFocus 转到 org-mode 上来的，OmniFocus 有一个很致命的缺点就是不支持多标签，并且 Perspective 提供的设置选项也很有限，根不能不能满足一些复杂的过滤要求。除此之外，OmniFocus 应该是最优秀的任务管理软件了。</p>

<p>Todoist 初次使用的时候感觉很难用，尤其是鼠标点击就进入编辑模式，这个设计真的不知道怎么想的，并且各平台的客户端一点也不 Native，基本就是 Web 版套了一个壳。macOS 客户端经常有一些莫名的 bug，反正软件的使用体验上来说和 OmniFocus 简直不能比。</p>

<p>经过一段时间的调教，现在基本还能满足日常使用了。我认为一个可靠的任务管理系统需要满足两点：</p>

<ol>
<li>能够随时把想法和任务记录进去</li>
<li>能够按照特定的要求过滤出任务</li>
</ol>

<p>其他的一些东西其实都是为了服务这两点的，比如说标签系统，其实就是在过滤任务的时候多加了一个维度。Todoist 的过滤系统比 OmniFocus 好很多，但是和 org-mode 这种可以完全自定义的过滤系统相比还是差点，不过也完全够用。</p>

<p>具体要写 Todoist 怎么用可能一篇文章也写不完（或许以后会写），另外 Todoist 还刚使用，有些东西还需要熟悉一下，下一篇文章会介绍一下目前我在用的一些过滤器。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这周在读什么 Issue#1]]></title>
    <link href="http://jiayuanzhang.com/weekly-reading-report-1.html"/>
    <updated>2017-03-24T12:10:29+08:00</updated>
    <id>http://jiayuanzhang.com/weekly-reading-report-1.html</id>
    <content type="html">
<![CDATA[<p>为什么要写这个？最主要的原因还是激励自己多多阅读，读好书和好文章，然后写 review。</p>

<p>读些什么？平常的阅读比较杂，除了书籍之外，还会读很多的博客文章，所以会写这周的 book review，主要是针对这周读完的书，读了一半放弃不打算再读的书也会写，没有读完的书不写；文章就简单写一些笔记性的 review。</p>

<p>*注：标注了 <code>[TECH]</code> 是和我专业相关的内容，可以跳过。</p>

<h2 id="toc_0">Books</h2>

<h3 id="toc_1"><a href="https://book.douban.com/subject/4251102/">《清华园日记》</a>，季羡林，外语教学与研究出版社，二零零九。</h3>

<p>这本书断断续续得读了有一个月的时间，因为是日记体的形式，所以什么时候都可以拿出来读一下。</p>

<blockquote>
<p>日记是写给自己看的，什么样的思想，什么样在人前难以说出口的话，都写了进去。万没想到今天会把日记公开。这些话是不是要删掉呢？我考虑了一下，决定不删。一仍其旧，一句话也没有删。<mark>我七十年前不是圣人，将来也不会成为圣人。我不想到孔庙里去陪着吃冷猪肉。我把自己活脱脱地暴露于光天化日之下。</mark></p>
</blockquote>

<p>这本日记是季羡林在清华园求学时所记，从大三一直写到大四。百年之前的大学生活和现在相比，并无什么太大的不同。季老也有过迷茫，对前途的忧虑，但是更多的是在勤勉地读书、写文章。</p>

<blockquote>
<p>苏东坡词「谁到人生无再少，门前流水尚能西」。难道这就是「再少」吗？</p>
</blockquote>

<p>阅读用时：7 小时 26 分，<a href="https://www.evernote.com/l/AYC42MIUq-5BXIHRNGdRcL1OxXt3DPzLT5k">摘录</a>。</p>

<h2 id="toc_2">Articles</h2>

<h3 id="toc_3">1. <a href="https://medium.freecodecamp.com/how-i-got-a-second-degree-and-earned-5-developer-certifications-in-just-one-year-while-working-and-2b902ee291ab#.gblxpzdk0">How I got a second degree and earned 5 developer certifications in just one year, while working and raising two kids</a></h3>

<p>全职教师、两个孩子、五张开发者证书、一个第二学位。如何在一年内实现这么多事？</p>

<blockquote>
<p>Ambitious goals are important.</p>
</blockquote>

<p>另外，你还不得不放弃一些东西。比如，剧是不能追了。</p>

<blockquote>
<p>It was important for me to give things up in order to accomplish my goals.</p>
</blockquote>

<p>学会使用 8/2 法则，逃出自己的 comfort zone。</p>

<blockquote>
<p>Really, when learning anything, you should ask yourself if it is part of the 20% of learning content that will give you 80% of value.</p>
</blockquote>

<p>这和很久前看的<a href="https://www.douban.com/group/topic/34856495/">一篇文章</a>很像。</p>

<h3 id="toc_4">2. <a href="https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c#.6o98rs4xs">Unconventional way of learning a new programming language</a></h3>

<p>Open source projects oriented programming.</p>

<p>如何学习一门新的语言，参加关于那个语言的开源项目。开源项目没有想象的那么难。</p>

<blockquote>
<p>I had a look at the issues and found a lot of “beginner” issues. I immediately started working on them and submitted a couple of pull requests. Fast forward to today, I am one of the main contributors for a couple of their open projects and also one of the 20 Open Source Community Leaders for DuckDuckGo.</p>
</blockquote>

<h3 id="toc_5">3. <a href="https://medium.freecodecamp.com/looking-back-to-what-started-it-all-731ef5424aec#.scacfw9pe">A Vision of Coding, Without Opening your Eyes</a></h3>

<blockquote>
<p>I’m a coder. I’m also blind. Blind as a bat, you might say. And I was born this way.</p>
</blockquote>

<p>这篇文章写自一个 blind coder，解释了三个（在我看来）有点 offensive 的问题：1）如何阅读；2）如何 coding；3）会做梦吗？</p>

<blockquote>
<p>I’ll try and sketch out an image for those of you who are curious about accessibility, and how blind people use computers to code, and to do the work of the 21st century.</p>
</blockquote>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[叛逃 Spotify]]></title>
    <link href="http://jiayuanzhang.com/go-to-spotify.html"/>
    <updated>2017-03-19T14:44:32+08:00</updated>
    <id>http://jiayuanzhang.com/go-to-spotify.html</id>
    <content type="html">
<![CDATA[<p>不久前我还<a href="digital-life-in-2016-music-part.html">写文</a>称赞过 Apple Music，现在光速打脸，叛逃 Spotify。</p>

<p>主要原因有几点：</p>

<ol>
<li>Apple Music 的「My Favorites Mix」一周才更新一次，不够听。</li>
<li>推荐的歌单都是听过的，专辑也是，重复推荐，并且由于是人工编辑的歌单，难免有不合自己口味的。</li>
<li>个性化推荐的内容太单一，经常出现歌慌，需要自己去找歌。</li>
<li>同步问题。</li>
</ol>

<p>Spotify 的 Premium 之前就买了，但是一直没有用。这几天用了一下，说一下使用体验：</p>

<ol>
<li>推荐算法很厉害，机器推荐的歌更个人一些，不会有人工歌单的主观因素在里面。</li>
<li>「Based on the songs in this playlist」这个功能很有用，可以用来扩充歌单。</li>
<li>Radio 功能比 Apple Music 强大。</li>
<li>多设备同步，这个功能太方便了，我只需要在电脑上断开蓝牙连接，然后就可以直接在手机上听了（配合蓝牙耳机）。</li>
</ol>

<p>一些不满意的地方：</p>

<ol>
<li>不能收藏专辑，有的专辑里面并不是每首歌都喜欢听，save 专辑会把整张专辑里面的歌添加到资料库里，这不得不让我又新建一个 Loved 的歌单，专门用来放喜欢的歌，这样和 Apple Music 就是差不多的操作逻辑。</li>
<li>没有提供加心功能，「+」仅仅是把歌曲添加到资料库，所以还得手动建一个歌单然后再添加，比较麻烦（可能我使用的方法不正确？）</li>
</ol>

<p>不过毕竟才用了几天，还没有深度体验过。Mac 上推荐配合 Alfred 的 Workflow 来使用，可以避免到 Spotify 应用里面进行操作。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 刷题笔记]]></title>
    <link href="http://jiayuanzhang.com/notes-on-leetcode.html"/>
    <updated>2017-03-10T10:04:04+08:00</updated>
    <id>http://jiayuanzhang.com/notes-on-leetcode.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">001 Two Sum [Easy]</a>
<ul>
<li>
<a href="#toc_1">题目</a>
</li>
<li>
<a href="#toc_2">时间复杂度</a>
</li>
<li>
<a href="#toc_3">思路</a>
</li>
<li>
<a href="#toc_4">代码</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">002 Add Two Numbers [Medium]</a>
<ul>
<li>
<a href="#toc_6">时间复杂度</a>
</li>
<li>
<a href="#toc_7">思路</a>
</li>
<li>
<a href="#toc_8">代码</a>
</li>
<li>
<a href="#toc_9">笔记</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">007 Reverse Integer [Easy]</a>
<ul>
<li>
<a href="#toc_11">题目</a>
</li>
<li>
<a href="#toc_12">思路</a>
</li>
<li>
<a href="#toc_13">代码</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">001 Two Sum [Easy]</h2>

<h3 id="toc_1">题目</h3>

<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>Example：</p>

<pre><code class="language-text">Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<h3 id="toc_2">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_3">思路</h3>

<p>比较暴力的做法就是用两个循环来穷举，这样的话时间复杂度会达到 \(O(n^2)\)。</p>

<p>另外一种思路就是使用一个 dict 来保存外循环中 target 与 num 的差值，这样在数组中只要发现这个值就可以直接返回了，而在 dic 查找的时间复杂度为 \(O(1)\)。</p>

<h3 id="toc_4">代码</h3>

<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            else:
                dic[target - num] = i
</code></pre>

<h2 id="toc_5">002 Add Two Numbers [Medium]</h2>

<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>Example:</p>

<pre><code class="language-text">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre>

<h3 id="toc_6">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_7">思路</h3>

<p>把两个数相加存在链表里，这两个数字的每一位都存在链表中，并且链表是反转的。思路很简单，就是遍历链表，把数取出来，然后加完后再添加到链表中。</p>

<p>代码写得很直白。</p>

<h3 id="toc_8">代码</h3>

<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        num1 = []
        num2 = []
        current = l1
        while current != None:
            num1.append(str(current.val))
            current = current.next
        current = l2
        while current != None:
            num2.append(str(current.val))
            current = current.next
        num1 = &#39;&#39;.join(num1)[::-1]
        num2 = &#39;&#39;.join(num2)[::-1]
        sum = int(num1) + int(num2)
        first = ListNode(str(sum)[0])
        for i in str(sum)[1:]:
            oldfirst = first
            first = ListNode(i)
            first.next = oldfirst
        return first
</code></pre>

<h3 id="toc_9">笔记</h3>

<p>翻了一下 discuss，发现我的解法实在是太 dirty 了。</p>

<p>下面这一段代码我认为还是非常优美的实现：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        def tolist(n):
            node = ListNode(n % 10)
            if n &gt; 9:
                node.next = tolist(n // 10)
            return node
        return tolist(toint(l1) + toint(l2))
</code></pre>

<p>非递归版本：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        n = toint(l1) + toint(l2)
        first = last = ListNode(n % 10)
        while n &gt; 9:
            n /= 10
            last.next = last = ListNode(n % 10)
        return first
</code></pre>

<p>解释一下思路。</p>

<p>首先 <code>toint(node)</code> 函数是将链表转化成 <code>int</code> 类型的数据，因为 Python 中 <code>int</code> 可以存非常大的数，所以不用考虑链表的长度。算法也很简单，因为链表是转置的，所以高位在链表后面，依次乘以 10 的 n 次方再相加就可以了。</p>

<p><code>tolist(n)</code> 函数式将计算好的数据转化成链表，再纸上拿一个一个例子画一个图就很好理解了。<code>node = ListNode(n % 10)</code> 每一次递归都创建一个节点来存放某一位的数据，<code>tolist(n // 10)</code> 每一次递归都截取一位数字。</p>

<p>非递归的方法类似。</p>

<h2 id="toc_10">007 Reverse Integer [Easy]</h2>

<h3 id="toc_11">题目</h3>

<p>Reverse digits of an integer.</p>

<p>The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.</p>

<p>Ex：</p>

<pre><code class="language-text">Example1: x = 123, return 321
Example2: x = -123, return -321
</code></pre>

<h3 id="toc_12">思路</h3>

<p>这道题很简单，但是要考虑转置之后会不会溢出，但是 Python 的 <code>int</code> 是不会溢出的，所以就需要手动判断一下，INT32 最大值是 \(2^{31}-1\)，用十六进制表示就是 <code>0x7FFFFFFF</code>。</p>

<h3 id="toc_13">代码</h3>

<pre><code class="language-python">class Solution(object):
    def reverse(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: int
        &quot;&quot;&quot;
        if x &lt; 0:
            result = -(int(str(x).lstrip(&#39;-&#39;)[::-1]))
        else:
            result = int(str(x)[::-1])
        
        if abs(result) &gt; 0x7FFFFFFF:
            return 0
        return result
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digital Life in 2016: 音乐篇]]></title>
    <link href="http://jiayuanzhang.com/digital-life-in-2016-music-part.html"/>
    <updated>2017-02-24T11:52:04+08:00</updated>
    <id>http://jiayuanzhang.com/digital-life-in-2016-music-part.html</id>
    <content type="html">
<![CDATA[<p>最近知乎上的一个朋友和我私信聊了一些关于效率工具以及 Workflow（此处指的是「工作流」）方面的一些问题。聊的内容比较碎片，所以还是打算写一篇文章来具体讨论一下。考虑到会涉及很多不同的主题，所以还是一个主题写一篇，这样也可以控制文章的长度。暂定按照以下主题来写：音乐篇、阅读篇、写作篇和时间管理篇。</p>

<p>音乐对我来说，应该算是日常生活中比较重要的一项内容了，除了一些需要特别 Focus 的工作（例如看数学）不会听音乐外，其他时间都会戴着耳机。2016 年彻底地转入到 Apple Music 中来，期间试用过一段时间的 Spotify，网易云音乐几乎没怎么打开过。这篇打算讨论一下所有（尽量）听音乐方面相关的问题。</p>

<h2 id="toc_0">用什么设备听</h2>

<p>我的大多数电子设备都是 Apple 系的，包括 rMBP、iPhone、iPad，所以听音乐也都是围绕着这些设备来。严格的来说，并不能算一个「音乐发烧友」，我对设备的要求并不是太高，甚至对音源也没有太高的要求，Apple Music 的音质已经完全能够满足了，无损音源内容几乎不听，其一是没有购买 CD 的习惯，所以没有合法的途径获取无损资源；其二是一直都是拿 iTunes 听音乐，无损还需要转格式编辑信息，过于麻烦。</p>

<p>主力播放器是 Macbook，几乎 80% 的时间都是在 Macbook 上听（写代码、阅读、写作等）。另外便是新购入的 iPhone 7，主要是外出坐车、跑步或是睡前听一下（之前是用 5s）。iPad 很少用来听音乐。</p>

<p>使用的耳机是 <a href="https://www.amazon.com/Westone-Pro30-Performance-Universal-Earphones/dp/B00FKY3IFA">Westone UM Pro 30</a>，使用体验很好，对比 Apple 自带的耳机有惊艳的提升，而且长时间佩戴也没有不适感（几乎没有戴着耳机的感觉）。想要具体了解得可以去搜相关的评测来看。</p>

<p>耳机是在 7 发售之前买的，传闻 7 要去掉耳机接口的时候其实我是不信的，结果还真去掉了。这导致了插 7 上需要多接一根转接线，略显累赘，所以现在在 iPhone 上听歌就直接拿自带的耳机了。</p>

<h2 id="toc_1">为什么不用网易云音乐</h2>

<p>我知道，我也很讨厌类似「我为什么不 xxx」的说法，「不用就不用，还要批判一番」，但是还是要写一写。</p>

<p>其实我很早就开始使用网易云音乐了，那个时候一些热门的歌曲下评论还只有几百条，不像现在，动辄上千上万条评论。也安利过身边好多人用，曾经是长期的会员用户，所以还是有一些资格来谈论一下这个音乐服务的。</p>

<p>很明显，网易云音乐最初就是模仿 Spotify 的，包括界面设计，几乎一模一样。除了借鉴 Spotify 之外，网易云音乐还加入了很多自己的「创新」，而正是这些所谓的创新，让我开始慢慢得不想用它。</p>

<ol>
<li>评论：其实我是赞成加入评论功能的，但是网易云的评论已经偏离了音乐评论的范围，变成了编故事、讲段子、骗赞评论的聚集地。认真评论音乐的几乎没有，我不知道如果想看段子为什么不上微博？这一点实际上让一个音乐软件变成了社交软件，不好意思，我只想好好听音乐。</li>
<li>歌曲：网易云上很多歌曲的信息混乱不堪，包括专辑信息、专辑封面、年份等，很多单曲甚至没有专辑信息，直接被编排到「热门歌曲串烧」这样的专辑里，我有强迫症，看着挺 low 的。并且很多的歌来源都不明确，大多数都是网友上传，甚至很多 Bilibili 鬼畜区的音乐也被上传上来，哪天听推荐就冷不丁得听到。</li>
<li>专辑封面不完整：网易云的一大特色就是模仿唱片机旋转，想看一下专辑封面是什么样还要点到专辑列表里面去看。在我看来，在电子设备上「拟物」是一种很没有效率的事，就像之前电子书的模拟翻页一样，「翻页」这个动作本来就是一个三维的过程，在手机上再怎么模拟也达不到现实中的效果，「瀑布式」的阅读方式才是正确的选择。所以我推崇「反拟物化」、「扁平化」和「极简化」的设计风格。</li>
<li>歌单：几乎所有的歌单都是由用户创建，和 Apple Music 与 Spotify 专门的音乐编辑创建的歌单相比，高下立判。</li>
</ol>

<p>在我看来，听音乐是一件很纯粹的事，而网易云给这件纯粹的事加了太多的东西。</p>

<h2 id="toc_2">Apple Music 之痛</h2>

<p>Apple Music 自从 2015 年 6 月发布以来，到现在已经有接近两年的时间了，从发布当天付费到现在，中间用了一段时间的国区，由于曲库原因，现在还换回了港区，每月 48 港币，虽然比国区每月 10 ￥（学生 5 ￥）贵了不少，不过依然很值，想想一张专辑的钱就可以听一个月。</p>

<p>虽说经过这么长时间的发展，Apple Music 依然可以说做得很烂，我在一年前的一篇文章（<a href="http://forrestchang.github.io/14824082548997.html">《Apple Music，古典音乐，阅读》</a>）中已经吐槽过了，除了网络问题有了明显改善之外，其他的并没有太大的改进。以至于现在每年的 WWDC 最期待的不是发布什么新产品，而是 Apple Music 有什么大的改进，加了些什么功能。</p>

<p>我在 V2EX 上也发过<a href="https://www.v2ex.com/t/336425">一篇帖子</a>吐槽过 Apple Music。</p>

<p>这些问题肯定和 iTunes 的历史因素有关，iTunes 本身就是作为一个音乐商店，在没有 Apple Music 之前，听音乐的流程就是从商店中购买数字音乐（或者从 CD 中导入），然后添加到 Library 中，之后对这些音乐做什么事都与商店中的音乐无关了。而到了 Apple Music，它依然延续着之前的流程，当把音乐添加到 Library 中后，你对音乐做出的评分、加心实际上都和云端的数据无关了，所有数据都存放在本地的 <code>iTunes Library.xml</code> 文件中，所以这才会导致一部分音乐明明加过心了，到了手机上一看却是没有加过心的，并且由于存放在本地的原因，云端的数据也不会更新，这也会影响到每天推荐给你的音乐。</p>

<p>Medium 上的一个设计师专门帮 Apple Music 重新设计了一下：<a href="https://medium.com/product-design-ux-ui/apple-music-redesign-part-1-526c4c4c4777#.lopgpvt41">Apple Music Redesign</a>，在我看来，比原版的 Apple Music 好太多。</p>

<p>很难想象，把 iPhone 做得只有 7 mm 厚的科技公司，竟然连 iTunes 中遗留的种种问题也解决不好。</p>

<h2 id="toc_3">听什么</h2>

<p>我并不打算讲太多「听什么」的内容，音乐本来就是一个很个人的事情，但是，音乐真的没有好坏吗？实际上，Apple Music 与网易云一个很大的不同点就是，前者有意得引导你听，而后者是根据你听歌的记录推荐相似的（尽管并不准）歌曲。</p>

<p>相比较网易云的每日推荐，Apple Music 只有一个最爱精选（My Favorites Mix），里面有很多你之前就已经喜欢的歌，每周更新一次。而更多的每天推荐是类似「朴树：音乐灵感」、「古典音乐：混音和改编歌曲」这样的人工手动编辑的歌单，而一般这样的歌单都会附带编辑的一些评语，让你能够大体得了解这张歌单内容，比如今天推荐给我的「古典音乐：混音和改编歌曲」：</p>

<blockquote>
<p>古典樂的經典旋律恆久不變，但同樣的旋律放在此歌單中卻可讓你帶來驚喜！耳熟能詳的柴可夫斯基、韋瓦第等大師作品，換上電子工程師 Max Richer、CFCF 及 DJ Spooky 的混音和改編，令幾百年前的作品添上時代感，即使充滿實驗性和玩味，趣味滿分。</p>
</blockquote>

<p>相比没有目的、仅仅根据自己的喜好乱听，这种引导的方式会慢慢影响你的音乐品味。</p>

<p>另一方面，它还会每天给你推荐不一样的专辑，比如我喜欢听 Imagine Dragons，它今天就给我基于此推荐了《An Awesome Wave》、《Skying》、《Megalithic Symphony》等专辑。</p>

<p>快餐音乐时代，很多歌曲单独从专辑中拿出来听也不会有什么问题，但是按照专辑来听，依然是严肃欣赏音乐的唯一方式。</p>

<h2 id="toc_4">怎么听</h2>

<p>用过两种方法。</p>

<p>1）类似于 Spotify，添加到 Library 的歌曲就算是你想以后继续听的，「加心」的行为只是用来作为推荐的参考。这种方式就不需要再本地再建一个智能播放列表专门用来过滤加心的歌曲了，因为 Library 中的所有的歌都是你想听的。</p>

<p>2）添加到 Library 中只是作为一个「稍后听」的过程，一般这种情况是按照专辑来添加到 Library 中，然后把这张专辑从头到尾（或者以你喜欢的方式）听一遍，把喜欢的歌加心，并给歌曲评分（可选），然后建立智能播放列表过滤出加心的歌，例如，我除了有一个 「Favorites」 歌单（自动更新 Library 中加心的歌曲），还有一个「古典精选」歌单，其中内容是类型为「Classical」并且已经加心了的歌曲。智能播放列表可以使用很复杂的过滤器。这种听歌方式也是现在我用的，这其实和之前在 iTunes Store 上购买音乐再听并没有什么区别，除了改成了订阅的方式并且附带了推荐功能。</p>

<p>不过听音乐这种事各有各的方法，这里也仅仅是提供参考。</p>

<h2 id="toc_5">一些辅助工具</h2>

<p>其实写到这里基本已经写完了。如果你不是一个强迫症、数据控、偏执狂或是一个完美主义者，最后这部分并没有什么太多帮助。</p>

<p>我使用 <a href="https://www.last.fm">last.fm</a> 来记录自己听了什么，Mac 上使用的是官方的 Last.fm Scrobbler 这个软件，不过它只能记录离线的歌曲，对于 Radio 就无能为力了，所以我辅助 <a href="http://bowtieapp.com/">Bowtie</a> 这个小软件来记录，为了防止重复记录，需要把 Last.fm Scrobbler 中的 Enable Scrobbling 选项关闭。</p>

<p>记录数据可以让你更好得知道平常的音乐喜好，以及某张专辑、某首歌、某个艺人听了多少次等等。并且 last.fm 提供通用的 API 来方便导出这些数据，说不定以后有什么用。</p>

<p>过去一周我的听歌记录可以在 <a href="https://www.last.fm/user/Tisoga/listening-report/week">这里</a> 看到。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[换了一个新地方写东西]]></title>
    <link href="http://jiayuanzhang.com/new-blog.html"/>
    <updated>2017-02-24T09:20:38+08:00</updated>
    <id>http://jiayuanzhang.com/new-blog.html</id>
    <content type="html">
<![CDATA[<p>现在这个博客只写技术相关的内容，其他的随笔都写在<a href="https://medium.com/@Tisoga">新博客</a>里，Medium 是被大陆屏蔽的，所以请自备梯子。另外一些比较私人的笔记——例如「Week Review」系列就不发表在互联网上了。</p>

<p>至于原因，单纯得觉得 Medium 上的衬线字体很好看。<del>如果需要魔改这个博客的话，还是挺麻烦的，自己目前的前端知识还处于未入门的水平，所以就不折腾了。</del>结果我还是魔改了，现在风格比较简洁了，照着 <a href="https://github.com/lepture/yue.css">yue.css</a> 改的。</p>

<p>既然重新换了一个主题，就不换地方写了……</p>

<p>主题的代码放在 <a href="https://github.com/forrestchang/Cuckoo">GitHub</a> 上，完全是新手的作品，所以还是不要 star 了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017 Week 1 Review]]></title>
    <link href="http://jiayuanzhang.com/2017-week-1.html"/>
    <updated>2017-01-01T22:06:15+08:00</updated>
    <id>http://jiayuanzhang.com/2017-week-1.html</id>
    <content type="html">
<![CDATA[<p>今天是元旦，因为在 Calendar 中把今天归到 2017 年的第一周里了，所以就按照上面所写的把这周当做第一周吧。</p>

<p>这周结束了在中软的课程设计实训，以前总嫌弃小渔村破，现在回来才知道还是小渔村好啊。课程设计实训的内容是用 Java 写一个点餐系统，一个小组只需要做一份就可以了，不过几乎所有人都不知道 Git 是个什么东西，小组合作还是用的 U 盘拷贝代码，所以代码质量可想而知了，本组的其他人都比较厉害，索性我就抱大腿划水了，什么也没有参与，代码也没有写一行。</p>

<p>不过虽说没有写课程设计的项目，但还是有写代码的。这周把两个月前参加 HACKxFDU 的项目拿出来用 Python 3 重写了一遍。项目的地址：<a href="https://github.com/forrestchang/Neutron">Neutron</a>，当初我们考虑做 Neutron 的时候是想把它做成一个通用的智能家居语音终端的，类似于 Amazon 的 Echo，只要提供第三方的 API，就能轻松集成到 Neutron 来，但是实际上碍于 Hackathon 的时间限制，只是完成了一个简单的 Demo，完全没有拓展性。本来这个项目参加完 Hackathon 之后就没有管了，不过最近看到 Facebook CEO 扎克伯格写了一个 Jarvis，觉得和之前做的东西很像（当然还是差远了，基本我们做的东西就是用别人的 API），所以又掏出来拿 Python 3.5 重写了一遍。现在在 <a href="https://github.com/forrestchang/neutron/tree/develop">develop</a> 分支基本上把框架搭建好了，最底层是和 API 交互的 layer 层，这一层需要为每个 API 写特定的代码，其上是抽象的 handler 层，提供通用的接口，抽象 layer 层的操作：例如语音控制模块、AI 模块等，这一层上还可能包裹一层特定的 wrapper，例如对特定的 message 做语义分析。通过配置文件来选择使用哪个 layer 以及配置 layer 的内容（key 等内容），开始的时候打算用 json 来做配置文件的，后来看了一下还有 yaml 这种更加简洁的配置文件，所以打算换成 yaml 的。目前这个项目还有很多内容要写的，比如特定的 layer，都需要更具不同的 API 写特定的代码，这一点上我参考的 <a href="https://github.com/syl20bnr/spacemacs">Spacemacs</a> 的方法。</p>

<p>这周在中软那边的宿舍里面把08版的《射雕英雄传》看完了，虽然槽点挺多的（特效、台词、演技），但是还是看得很欢乐，林依晨的黄蓉甚是喜欢。记得以前应该是看过朱茵版的黄蓉的，不过时间太久远了，已经记不太清了。小说倒没有读完，还是看剧比较快啊。看完后好长一段时间里面都觉得特别空虚，总感觉少了些什么。这种孤独感几乎在每次看完某部小说和电视剧后都会有（电影倒没有这种感觉，可能时间太短了），总觉得还沉浸在别人的故事里，可惜别人的故事已经结束，不得不回到现实中来。想起席慕蓉的一句话『在别人的故事里，留着自己的泪』 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 。</p>

<hr/>

<p>就借着这篇博客顺便说说 17 年的计划吧。</p>

<ol>
<li>学习一门新语言：14年学了 C、Scheme，15年学了 Java、Python，16年学了 Swift，再加上各种用过但是不熟的语言，也有好多个了。现在主力开发语言是 Python，17年打算学习 一下 JavaScript，这门 GitHub 上最火的语言，不会都不好意思说自己是程序员。也不用学到多么深，只求达到入门水平。</li>
<li>Python 水平达到 professional，用了接近两年的 Python，但是水平也没有长进多少，今年打算深入一下 Python，多写一些项目。</li>
<li>去周边国家玩一次，其实挺想去尼泊尔的，不知道今年有没有时间。不过即使不出国，也要多出去走走，一个人的旅行。</li>
</ol>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>席慕蓉的《戏子》，用在这里并不完全准确。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 52 Review]]></title>
    <link href="http://jiayuanzhang.com/2016-week-12.html"/>
    <updated>2016-12-26T09:38:40+08:00</updated>
    <id>http://jiayuanzhang.com/2016-week-12.html</id>
    <content type="html">
<![CDATA[<p>2016 年最后一周（实际上还有6天，不过那一周就算到 2017 年第一周吧）。</p>

<ul>
<li><strong>编程</strong>：这周在看《Python 网络数据采集》，以前虽然也用过爬虫，但是毕竟没有系统地学过，所以还是找了一本书来看。但是说实话，这本书写得并不是很好，不知道是写书时间的原因还是什么，挺多语法错误的，而且代码的风格很差（完全不符合 PEP8 标准）。内容也比较浅，基本上都是之前已经知道了的东西，所以收获也不是很多，（下一篇的博客可以来写一写怎么写一个高效的爬虫）。面试的事情作废了，1）看了一下他们做的产品，感觉不是自己想要做的东西；2）开出的薪资太低，up to 2k（其实主要是薪资太低了，每天要往返金石滩和大连市，太累了）。所以还是好好学习准备明年的暑期实习吧。另外 GSoC 也应该放上日程了，即使有申请不上的可能，还是要试一试的。</li>
<li><strong>阅读</strong>：开始读金庸的《射雕英雄传》，以前上学的时候一直被家里教导不要沉迷武侠小说，所以一直没有读过金庸和古龙（然而那些时间都用来看网文玄幻了……）。最近读来还是觉得很有意思，作为实训的时候消遣很不错（主要没有网）。</li>
<li><strong>生活</strong>：这周五就可以离开这鬼地方了，见识过外包公司的情况后决定以后肯定是不会进这种公司的。在公司里实训也一直没有写代码，本来打算用 Python 实现一下实训的题目的，但是老师说不允许，这也没什么办法，索性就划水吧。</li>
<li><strong>博客</strong>：可以看到，我博客又换样子了。用 Emacs 来写博客还是太麻烦了一些，而且 render 的速度实在是太感人，本地的 org 文件多了之后好几次 render 的时候卡住。现在这个博客是 Mweb 自带的 generator 生成的，就是主题不怎么好看，其他的都很方便。奈何自己的前端知识太渣，改了半天也没有改成自己想要的样子，所以还是凑合着先用吧。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐系统笔记]]></title>
    <link href="http://jiayuanzhang.com/notes-on-recommandation-system.html"/>
    <updated>2016-12-22T20:10:42+08:00</updated>
    <id>http://jiayuanzhang.com/notes-on-recommandation-system.html</id>
    <content type="html">
<![CDATA[<p>开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。</p>

<p>这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。</p>

<h2 id="toc_0">基于用户的协同过滤</h2>

<h3 id="toc_1">协同过滤（Collaborative filtering）</h3>

<p>一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。</p>

<h3 id="toc_2">测试数据集</h3>

<p>为了演示一些算法，我们需要从<a href="http://grouplens.org/datasets/movielens/">这个网站</a>上下载一份数据集。这里因为是作为演示使用，所以只需要下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>这一份简单的数据集就可以了。</p>

<h3 id="toc_3">相似度计算</h3>

<p>在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的<strong>相似度评价值</strong>。</p>

<h4 id="toc_4">欧几里德距离评价（Euclidean Distance Score）</h4>

<p>欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作\((p_1, p_2, p_3, p_4, ...)\)和\((q_1, q_2, q_3, q_4, ...)\)，则欧几里德距离的计算公式为：</p>

<p>\[<br/>
\sqrt{((p_1-q_1)^2+(p_2-q_2)^2+...+(p_n-q_n)^2)} = \sqrt{(\sum_{i=1}^n(p_i-q_i)^2)}<br/>
\]</p>

<p>创建 <code>recommendations.py</code>。</p>

<p>用代码表示：</p>

<pre><code class="language-python">from math import sqrt

# 返回一个有关 person1 与 person2 的基于距离的相似度评价
def sim_distance(prefs, person1, person2):
    # 得到 shared_items 的列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
        shared_items[item] = 1
    
    # 如果两者没有共同之处，则返回 0
    if len(shared_items) == 0:
        return 0
        
    # 计算所有差值的平方和
    sum_of_squares = sum([pow(prefs[person1][item]-prefs[person2][item], 2)for item in prefs[person1] if item in prefs[person2]])
    
    return 1 / (1 + sqrt(sum_of_squares))
</code></pre>

<p>欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。</p>

<p>好了，现在我们需要先将数据读取进来，在 <code>recommendations.py</code> 中添加如下代码:</p>

<pre><code class="language-python">def loadMovieLens(path=&#39;data&#39;):
    movies = {}
    for line in open(path + &#39;/movies.csv&#39;):
        (id, title) = line.split(&#39;,&#39;)[0:2]
        movies[id] = title

    prefs = {}
    for line in open(path+&#39;/ratings.csv&#39;):
        (user, movieid, rating, ts) = line.split(&#39;,&#39;)
        prefs.setdefault(user, {})
        prefs[user][movies[movieid]] = float(rating)
    return prefs
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; import recommendations
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 比较 10 号用户 和 20 号用户的相似度评价
&gt;&gt;&gt; recommendations.sim_distance(prefs, &#39;10&#39;, &#39;20&#39;)
0.23371479611805132
</code></pre>

<h4 id="toc_5">皮尔逊相关系数（Pearson Correlation Coefficient）</h4>

<p>皮尔逊相关系数是一种度量两个变量间相关程度的方法，它是一个介于 1 和 -1 之间的值，其中，1 表示变量完全正相关，0 表示无关， -1 则表示完全负相关（一个变量的值越大，则另一个变量的值反而会越小）。</p>

<p>计算公式：</p>

<p>\[<br/>
r = \frac{\sum{XY}-\frac{\sum X \sum Y}{N}}{\sqrt{(\sum X^2 - \frac{(\sum X)^2}{N})(\sum Y^2 - \frac{(\sum Y)^2}{N})}}<br/>
\]</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def sim_pearson(prefs, person1, person2):
      # 得到双方都曾评价过的物品列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            shared_items[item] = 1
      # 得到物品列表元素的个数
    n = len(shared_items)

      # 如果两者没有共同元素，则返回0
    if n == 0:
        return 0

      # 计算 person1 和 person2 的皮尔逊相关系数
    sumxy = sum([prefs[person1][item] * prefs[person2][item]
                for item in shared_items])
    sumx = sum([prefs[person1][item] for item in shared_items])
    sumy = sum([prefs[person2][item] for item in shared_items])
    sumx2 = sum([prefs[person1][item] ** 2 for item in shared_items])
    sumy2 = sum([prefs[person2][item] ** 2 for item in shared_items])

    zahler = sumxy - (sumx * sumy) / n
    nenner = sqrt((sumx2 - (sumx ** 2) / n) * (sumy2 - (sumy ** 2) / n))
    if nenner == 0:
        return 0
    r = zahler / nenner

    return r
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.sim_pearson(prefs, &#39;10&#39;, &#39;20&#39;)
0.4908806936738162
</code></pre>

<p>可以看到和上面使用欧几里德距离评价计算出来的相似度是不一样的。</p>

<h4 id="toc_6">关于该使用哪一种相似性度量方法</h4>

<p>除了这两种计算相似度的方法，实际上还有许多别的计算相似度的算法，例如<strong>Tanimoto 分值</strong>。使用哪一种方法，完全取决于具体的应用。</p>

<p>下面的代码中，将使用一个通用的相似性函数来计算相似度，只要它满足以下条件：拥有同样的函数签名，以一个浮点数作为返回值，其数值越大代表相似度越大。</p>

<h3 id="toc_7">寻找相似的用户</h3>

<p>既然我们已经有了对两个人进行比较的函数，下面我们就可以编写，根据指定人员对每个人进行打分，并找出最接近的匹配结果了。</p>

<pre><code class="language-python"># 从反映偏好的字典中返回最佳匹配者
# 返回结果的个数和相似度函数均为可选参数
def topMatches(prefs, person, n=5, similarity=sim_pearson):
    scores = [(similarity(prefs, person, other), other) for other in prefs if other != person]
    
    # 对列表进行排序，评价值最高者排在最前面
    scores.sort(reverse=True)
    return scores[:n]
</code></pre>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 与 40 号用户相似的 10 个用户
&gt;&gt;&gt; recommendations.topMatches(prefs, &#39;40&#39;, n=10)
[(1.0, &#39;63&#39;),
 (1.0, &#39;582&#39;),
 (1.0, &#39;326&#39;),
 (1.0, &#39;260&#39;),
 (1.0, &#39;220&#39;),
 (1.0, &#39;198&#39;),
 (1.0, &#39;153&#39;),
 (1.0, &#39;116&#39;),
 (0.9999999999999947, &#39;474&#39;),
 (0.9999999999999947, &#39;215&#39;)]
</code></pre>

<h3 id="toc_8">推荐物品</h3>

<p>有的时候我们可能不需要寻找相似的用户，例如在购物网站中，我们需要的是一份可能会想要购买的物品列表，一种方法是从相似的用户所购买的物品列表中选出没有购买的，但是这种方法不确定的因素太多，例如可能相似用户还未购买某些物品，而这些物品恰恰就是我们所需要的。</p>

<p>为了解决上面的问题，我们需要通过一个经过加权的评价值来为影片打分，评论者的评分结果因此而形成了先后的排名。为此，我们需要取得所有其他评论者的评价结果，借此得到相似度之后，再乘以他们为每部影片所给的评价值。</p>

<p>以以下数据集为例：</p>

<pre><code class="language-text">{&#39;Lisa Rose&#39;: {&#39;Lady in the Water&#39;: 2.5,
               &#39;Snakes on a Plane&#39;: 3.5,
               &#39;Just My Luck&#39;: 3.0,
               &#39;Superman Returns&#39;: 3.5,
               &#39;You, Me and Dupree&#39;: 2.5,
               &#39;The Night Listener&#39;: 3.0},
 &#39;Gene Seymour&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 1.5,
                  &#39;Superman Returns&#39;: 5.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Michael Phillips&#39;: {&#39;Lady in the Water&#39;: 2.5,
                      &#39;Snakes on a Plane&#39;: 3.0,
                      &#39;Superman Returns&#39;: 3.5,
                      &#39;The Night Listener&#39;: 4.0},
 &#39;Claudia Puig&#39;: {&#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 3.0,
                  &#39;The Night Listener&#39;: 4.5,
                  &#39;Superman Returns&#39;: 4.0,
                  &#39;You, Me and Dupree&#39;: 2.5},
 &#39;Mick LaSalle&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 4.0,
                  &#39;Just My Luck&#39;: 2.0,
                  &#39;Superman Returns&#39;: 3.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 2.0},
 &#39;Jack Matthews&#39;: {&#39;Lady in the Water&#39;: 3.0,
                   &#39;Snakes on a Plane&#39;: 4.0,
                   &#39;The Night Listener&#39;: 3.0,
                   &#39;Superman Returns&#39;: 5.0,
                   &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Toby&#39;: {&#39;Snakes on a Plane&#39;: 4.5,
          &#39;You, Me and Dupree&#39;: 1.0,
          &#39;Superman Returns&#39;: 4.0}}
</code></pre>

<p>假设我们需要给 Toby 提供影片推荐，我们可以根据上面的算法得出一张表：</p>

<table>
<thead>
<tr>
<th>评论者</th>
<th>相似度</th>
<th>Night</th>
<th>S.xNight</th>
<th>Lady</th>
<th>S.xLady</th>
<th>Luck</th>
<th>S.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Rose</td>
<td>0.99</td>
<td>3.0</td>
<td>2.97</td>
<td>2.5</td>
<td>2.48</td>
<td>3.0</td>
<td>2.97</td>
</tr>
<tr>
<td>Seymour</td>
<td>0.38</td>
<td>3.0</td>
<td>1.14</td>
<td>3.0</td>
<td>1.14</td>
<td>1.5</td>
<td>0.57</td>
</tr>
<tr>
<td>Puig</td>
<td>0.89</td>
<td>4.5</td>
<td>4.02</td>
<td></td>
<td></td>
<td>3.0</td>
<td>2.68</td>
</tr>
<tr>
<td>LaSalle</td>
<td>0.92</td>
<td>3.0</td>
<td>2.77</td>
<td>3.0</td>
<td>2.77</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Matthews</td>
<td>0.66</td>
<td>3.0</td>
<td>1.99</td>
<td>3.0</td>
<td>1.99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td></td>
<td>12.89</td>
<td></td>
<td>8.38</td>
<td></td>
<td>8.07</td>
</tr>
<tr>
<td>Sim.Sum</td>
<td></td>
<td></td>
<td>3.84</td>
<td></td>
<td>2.95</td>
<td></td>
<td>3.18</td>
</tr>
<tr>
<td>总计/Sim.Sum</td>
<td></td>
<td></td>
<td>3.35</td>
<td></td>
<td>2.83</td>
<td></td>
<td>2.53</td>
</tr>
</tbody>
</table>

<p>表中列出来每位评论者的相关度评价值，以及他们对三部影片的评分情况。以 S.x 打头的列给出了乘以评价值之后的相似度。如此一来，相比于与我们不相近的人，那些与我们相近的人将会对整体评价拥有更多的贡献。总计所有加权评价值的和。</p>

<p>我们也可以选择利用总计值来计算排名，但是这其中有一个问题，一部受更多人评论的影片会对结果产生很大影响。为了修正这一问题，我们需要除以表总名为 Sim.Sum 的那一行，它代表了<strong>所有对这部电影有过评论的评论者的相似度之和</strong>。对于影片《Lady in the Water》来说，Puig 并未做过评论，所以我们将这部影片的总计值除以所有其他人的相似度之和。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python"># 利用所有其他人评价值得加权平均，为某人提供建议
def getRecommendations(prefs, person, similarity=sim_pearson):
    totals = {}
    simSums = {}
    for other in prefs:
        # 不要和自己做比较
        if other == person:
            continue
        sim = similarity(prefs, person, other)
        
        # 忽略评价值为零或者小于零的情况
        if sim &lt;= 0:
            continue
            
        for item in prefs[other]:
            # 只对自己还未看过的影片进行评价
            if item not in prefs[person] or prefs[person][item] == 0:
                # 相似度*评价值
                totals.setdefault(item, 0)
                totals[item] += prefs[other][item] * sim
                # 相似度之和
                simSums.setdefault(item, 0)
                simSums[item] += sim
        
        # 建立一个归一化的列表
        rankings = [(total / simSums[item], item) for item, total in totals.items()]
        
        # 返回经过排序的列表
        rankings.sort(reverse=True)
        return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; relaod(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.getRecommendations(prefs, &#39;10&#39;)[:20]
[(5.000000000000001,
  &#39;The Slipper and the Rose: The Story of Cinderella (1976)&#39;),
 (5.000000000000001, &#39;Hands on a Hard Body (1996)&#39;),
 (5.000000000000001, &#39;For the Birds (2000)&#39;),
 (5.000000000000001, &#39;Diva (1981)&#39;),
 (5.0, &#39;Zorba the Greek (Alexis Zorbas) (1964)&#39;),
 (5.0, &#39;Zerophilia (2005)&#39;),
 (5.0, &#39;Zelary (2003)&#39;),
 (5.0, &#39;Z Channel: A Magnificent Obsession (2004)&#39;),
 (5.0, &#39;Yossi (Ha-Sippur Shel Yossi) (2012)&#39;),
 (5.0, &#39;World of Tomorrow (2015)&#39;),
 (5.0, &#39;Woody Allen: A Documentary (2012)&#39;),
 (5.0, &#39;Woman on Top (2000)&#39;),
 (5.0, &#39;Without a Clue (1988)&#39;),
 (5.0, &#39;Withnail &amp; I (1987)&#39;),
 (5.0, &#39;Wild Zero (2000)&#39;),
 (5.0, &#39;War Room (2015)&#39;),
 (5.0, &#39;Walker (1987)&#39;),
 (5.0, &#39;Voices from the List (2004)&#39;),
 (5.0, &#39;Videodrome (1983)&#39;),
 (5.0, &#39;Victoria (2015)&#39;)]
</code></pre>

<h3 id="toc_9">匹配商品</h3>

<p>现在我们已经可以为指定人员寻找品味相近的用户，以及如何向其推荐商品。假如我们想要了解哪些物品是相近的，那又该如何呢？</p>

<p>在我们浏览 Amazon 的时候，经常会看到页面底部会推荐与当前浏览的物品相似的商品。这种情况，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，这和我们之前用来计算人与人之间的相似度是一样的，只需要把人和物品相互调换就行了。</p>

<p>我们来编写这个翻转字典的函数：</p>

<pre><code class="language-python">def transformPrefs(prefs):
    result = {}
    for person in prefs:
        for item in prefs[person]:
            result.setdefault[item, {}]
            # 将物品和人对调
            result[item][person] = prefs[person][item]
    return result
</code></pre>

<p>有了这个方法之后，我们就可以复用之前所写的方法了。</p>

<p>在 ipython 环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; load(recommendations)
&gt;&gt;&gt; movies = recommendations.transformPrefs()
&gt;&gt;&gt; recommendations.topMatches(movies, &#39;For the Birds (2000)&#39;)
[(1.000000000000016, &#39;&quot;Silence of the Lambs&#39;),
 (1.0, &#39;World War Z (2013)&#39;),
 (1.0, &#39;Wallace &amp; Gromit in The Curse of the Were-Rabbit (2005)&#39;),
 (1.0, &#39;Tron: Legacy (2010)&#39;),
 (1.0, &#39;Transcendence (2014)&#39;)]
</code></pre>

<p>我们还可以为影片推荐评论者：</p>

<pre><code class="language-python">&gt;&gt;&gt; recommendations.getRecommendations(movies, &#39;For the Birds (2000)&#39;)[:20]
[(5.0, &#39;668&#39;),
 (5.0, &#39;618&#39;),
 (5.0, &#39;543&#39;),
 (5.0, &#39;541&#39;),
 (5.0, &#39;536&#39;),
 (5.0, &#39;52&#39;),
 (5.0, &#39;464&#39;),
 (5.0, &#39;46&#39;),
 (5.0, &#39;409&#39;),
 (5.0, &#39;357&#39;),
 (5.0, &#39;308&#39;),
 (5.0, &#39;296&#39;),
 (5.0, &#39;29&#39;),
 (5.0, &#39;28&#39;),
 (5.0, &#39;197&#39;),
 (5.0, &#39;196&#39;),
 (5.0, &#39;190&#39;),
 (5.0, &#39;131&#39;),
 (5.0, &#39;113&#39;),
 (4.999999999999999, &#39;465&#39;)]
</code></pre>

<h2 id="toc_10">基于物品的协同过滤</h2>

<p>当前所完成的推荐系统，要求我们使用每一位用户的全部评分来构建数据集，这种方法对于小规模的数据集是没有问题的，但是对于像 Amazon 这样有着上百万用户和商品的大型网站而言，讲一个用户同其他所有用户进行比较，然后再对每位用户评过分的商品进行比较，时间花费上是巨大的。</p>

<p>目前为止我们所使用的技术被称为<strong>基于用户的协同过滤</strong>（user-based collaborative filtering）。除此以外，还有一种可供选择的方法被称为<strong>基于物品的协同过滤</strong>（item-based collaborative filtering）。在拥有大量数据集的情况下，基于物品的协同过滤能够得出更好的结论，而且它允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们所要的结果。</p>

<p>基于物品的协同过滤总体思路就是为每件物品预先计算好最为相近的其他物品。然后，当我们想为某位用户提供推荐的时候，就可以查看他曾经评过分的物品，并从中选出排名靠前者，再构造一个加权列表，其中包含了与这些选中物品最相近的其他物品。此处最显著的区别在于，尽管第一步要求我们检查所有的数据，但是物品间的比较不会像用户间比较那么频繁变化。</p>

<h3 id="toc_11">构造物品比较数据集</h3>

<p>为了对物品进行比较，我们要做的第一件事就是编写一个函数，构造一个包含相近物品的完整数据集。构建完数据集之后，我们就可以在需要的时候重复使用它。</p>

<p>将下面代码添加到 <code>recommendations.py</code> 中：</p>

<pre><code class="language-python">def calculateSimilarItems(prefs, n=10):
    # 建立字典，以给出与这些物品最为相近的其他物品
    result = {}
    
    # 以物品为中心最偏好矩阵进行倒置处理
    itemPrefs = transformPrefs(prefs)
    c = 0
    for item in itemPrefs:
        # 针对大数据集更新状态变量
        c += 1
        if c % 100 == 0:
            print &quot;%d / %d&quot; % (c, len(itemPrefs))
        scores = tomMatchs(itemPrefs, item, n=n, similarity=sim_pearson)
        result[item] = scores
    return result
</code></pre>

<p>该函数首先利用了此前定义过得 <code>transformPrefs</code> 函数，对反映评价的字典进行倒置处理，从而得到一个有关物品及其用户评价情况的列表，然后程序又循环遍历每项物品，并将转换了的字典传入 <code>tomMatches</code> 函数中，求得最为相近的物品及其相似度评价值，最后，它建立并返回了一个包含物品及其最相近物品列表的字典。</p>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; itemsim = recommendations.calculateSimilarItems(prefs)
100 / 8963
200 / 8963
300 / 8963
400 / 8963
500 / 8963
600 / 8963
700 / 8963
800 / 8963
900 / 8963
1000 / 8963
1100 / 8963
1200 / 8963
1300 / 8963
1400 / 8963
1500 / 8963
1600 / 8963
1700 / 8963
1800 / 8963
1900 / 8963
...
</code></pre>

<p>首次运行需要等待一段时间进行计算。</p>

<p>只有频繁执行该函数，才能令物品的相似度不至于过期。通常我们需要在用户基数和评分数量不是很大的时候执行这一函数，但是随着用户数量的不断增长，物品间的相似度评价通常会变得越来越稳定。</p>

<h3 id="toc_12">获得推荐</h3>

<p>现在，我们可以利用反映物品相似度的字典来给出推荐了，我们可以去到用户评价过得所有物品，并找出其相近的物品，根据相似度对其进行加权。</p>

<p>下表给出了利用基于物品的方法寻找推荐的过程，所用到的数据可以在上面<strong>推荐物品</strong>一节中找到。</p>

<p>为 Toby 提供基于物品的推荐：</p>

<table>
<thead>
<tr>
<th>影片</th>
<th>评分</th>
<th>Night</th>
<th>R.xNight</th>
<th>Lady</th>
<th>R.xLady</th>
<th>Luck</th>
<th>R.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Snakes</td>
<td>4.5</td>
<td>0.182</td>
<td>0.818</td>
<td>0.222</td>
<td>0.999</td>
<td>0.105</td>
<td>0.474</td>
</tr>
<tr>
<td>Superman</td>
<td>4.0</td>
<td>0.103</td>
<td>0.412</td>
<td>0.091</td>
<td>0.363</td>
<td>0.065</td>
<td>0.258</td>
</tr>
<tr>
<td>Dupree</td>
<td>1.0</td>
<td>0.148</td>
<td>0.148</td>
<td>0.4</td>
<td>0.4</td>
<td>0.182</td>
<td>0.182</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>0.433</td>
<td>1.378</td>
<td>0.713</td>
<td>1.762</td>
<td>0.352</td>
<td>0.914</td>
</tr>
<tr>
<td>归一化结果</td>
<td></td>
<td></td>
<td>3.183</td>
<td></td>
<td>2.473</td>
<td></td>
<td>2.598</td>
</tr>
</tbody>
</table>

<p>此处每一行都列出了一部我们曾经观看过的影片，以及对该片的个人评价。对于每一部我们还未曾看过的影片，相应有一列会指出它与已观看影片的相似程度。以 R.x 打头的列给出了我们队影片的评价值乘以相似度之后的结果。</p>

<p>总计一行给出了每部影片相似度评价值的总和以及 R.x 列的总和，为了预测我们对每一部影片的评分情况，只要将 R.x 列的总计值除以相似度一列的总计值即可。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def getRecommendedItems(prefs, itemMatch, user):
    userRatings = prefs[user]
    scores = {}
    totlaSim = {}
    
    # 循环遍历由当前用户评分的物品
    for (item, rating) in userRatings.items():
        
        # 循环遍历与当前物品相近的物品
        for (similarity, item2) in itemMatch[item]:
        
            # 如果该用户已经对当前物品做过评价，则将其忽略
            if item2 in userRatings:
                continue
            
            # 评价值与相似度加权之和
            scores.setdefault(item2, 0)
            scores[item2] += similarity * rating
            
            # 全部相似度之和
            totalSim.setdefault(item2, 0)
            totalSim[item2] += similarity
            
    # 将每个合计值除以加权和，求出平均值
    rankings = [(score / totalSim[item], item) for item, score in scores.items()]
    
    # 按最高值到最低值的顺序，返回评分结果
    rankings.sort(reverse=True)
    return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; recommendations.getRecommendedItems(prefs, itemsim, &#39;20&#39;)[:10]
[(5.0, &#39;Zoot Suit (1981)&#39;),
 (5.0, &#39;Zoolander (2001)&#39;),
 (5.0, &#39;Zack and Miri Make a Porno (2008)&#39;),
 (5.0, &quot;You&#39;ve Got Mail (1998)&quot;),
 (5.0, &#39;X-Men: The Last Stand (2006)&#39;),
 (5.0, &#39;X-Men: Apocalypse (2016)&#39;),
 (5.0, &#39;X-Men (2000)&#39;),
 (5.0, &quot;Von Ryan&#39;s Express (1965)&quot;),
 (4.75, &#39;Willow (1988)&#39;),
 (4.75, &quot;White Men Can&#39;t Jump (1992)&quot;)]
</code></pre>

<h2 id="toc_13">基于用户进行过滤还是基于物品进行过滤</h2>

<p>在数据集大小上，基于物品进行过滤的方式要比基于用户进行过滤更快；在数据的稀疏程度上，稀疏的数据集使用基于物品的过滤方法更优，而对于秘密集的数据集而言，两者的效果几乎一样。</p>

<p>基于用户的过滤方法更加易于实现，而且无需额外步骤，因此它通常更适用于规模较小的变化非常频繁的数据集。在一些应用中，告诉用户还有哪些人与自己有着相近偏好是有一定价值的——也许对于一个购物网站而言，我们并不想这么做，但是对于一个音乐分享类或者电影评分类网站而言，这种潜在的需求却是存在的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 51 Review]]></title>
    <link href="http://jiayuanzhang.com/2016-week-51.html"/>
    <updated>2016-12-22T20:39:14+08:00</updated>
    <id>http://jiayuanzhang.com/2016-week-51.html</id>
    <content type="html">
<![CDATA[<p>看了一下日历，上一周是 2016 年的倒数第二周了（写这篇文章的时候已经是 52 周了），换了新博客之后就一直没有再写过 Week Review，这其中虽然有一些外部的因素，但大抵上还是不想写。</p>

<p>上周学校组织来中软做课程设计，所以这些天一直待在中软的培训中心里，课程设计的题目是一个点餐的 Web 应用，用 Java 开发，因为并不打算从事 Java，所以也并没有怎么听，大部分时间都是在自己看书和写自己的 Project。不过要吐槽一下这边的环境，宿舍除了床什么也没有，所以晚上回去什么都干不了，只能坐在床上看看电影，最不能忍的是网都没有……学校送来培训中心的这种做法我是很不认同的，好好的大学为什么要搞成职业教育呢？</p>

<p>最近找到了大连的一家做 Python Web 的 start up，联系了一下准备过去面试，不过软件园离学校太远了，估计面过了也不会去吧。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 46 Review]]></title>
    <link href="http://jiayuanzhang.com/2016-week-46.html"/>
    <updated>2016-12-22T20:02:41+08:00</updated>
    <id>http://jiayuanzhang.com/2016-week-46.html</id>
    <content type="html">
<![CDATA[<p>编程学习方面，不完全看完了《利用 Python 进行数据分析》，感觉光看没有进行练习的话很难一次记住那么多用法，所以这本书最好还是最 NumPy、Pandas 这几个库用过一段时间之后再看。之后开始看《集体智慧编程》，目前才看了两章，内容写得还是挺好的，不过很多代码不是很规范（比如命名、缩进什么的），还有就是可能书已经比较老了，很多例子中使用的 API 已经挂掉了，所以不得不自己找数据集下来测试。不知道别人看书是怎样的，反正我看书不把书中每个例子测试一下就感觉书好像没看过，所以看书的速度还是挺慢的，昨天和今天花了两天的时间把第2章的东西总结了一下，写了篇博客。</p>

<p>朋友说我现在才开始学习机器学习并且想要以此为以后的职业简直在玩火（并且还不打算读研究生的情况下），说得也是，毕竟现在已经大三了，按照道理，应该刷刷题准备下学期的实习面试的。不过既然跳进这个火坑里了，就不能半途而废，至少先学习几个月看看情况再变更计划。如果实在不行，到时候再去做 Web 开发还是可以的。</p>

<p>前几天在登录 iPad 上的 Evernote 的时候，突然提示我登录的设备超过了两台，需要开通会员（之前开通过一年的会员，后来没有续费），总觉得为了这个再开通会员有点不值得，并且之前 Evernote 在 Mac 上使用就有很多诟病，所以打算换 OneNote 了。更新了一下 Mac 上 OneNote，发现竟然支持手写了，果断用用用。不过 OneNote 最开始的字体问题到现在还没有解决……</p>

<p>下周五就可以玩上 Pokemon Moon 了，激动不已，虽然破解党们早已二周目通关……</p>

<p>另外，发现番茄工作法挺好用的，现在也没有什么课了，每天就直接到图书馆里来，打开番茄钟，然后无脑干活就好了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 45 Review]]></title>
    <link href="http://jiayuanzhang.com/2016-week-45.html"/>
    <updated>2016-12-22T20:01:39+08:00</updated>
    <id>http://jiayuanzhang.com/2016-week-45.html</id>
    <content type="html">
<![CDATA[<p>已经第 45 周了啊，再过 10 周 2016 年就要过去了。今天大连下起了雪，似乎冬天就这么不知不觉得来了，记得上一次下大雪的时候去了一次海边，可惜 Photos 在一次事故中数据全部丢失了。作为一个南方人当初决定来北方的时候其实是对雪有一种很强烈的期待的，不过来了大连之后发现其实这里也不怎么下雪，偶尔下一次的雪也不是很大，这在一定程度上有点令人失望。</p>

<p>上周在读《挪威的森林》这本书，第一次读的时候大概是在初中的时候，当时没看懂里面写的是什么，纯属当做一本小黄书来读的。这次读的时候依旧有好多东西没明白。有一天听着 Thirteen Senses 的专辑猛地读到了 50%，感觉特别压抑，说不出来的压抑，所以就暂时放下了，顺便把翻拍的电影看了一遍，说实话，电影拍得不是很好，剧情的跳跃度有些大了，让没读过小说的人看得莫名其妙。</p>

<p>学习方面感觉上周特别颓废，什么事情都不相干，每天就窝在宿舍里，果然宿舍是一个让人堕落的地方，甚至连门都不想出去了，吃饭全部叫外卖。还好今天周一强迫自己来了图书馆，希望能做些东西吧。</p>

<p>这学期的课程基本结束了，免修了两门课，除了上机可能会去一下，其他时间都是空余的了，有大块的时间可以用来做自己想要做额事情了。</p>

<p>看了一眼窗外，雪似乎已经停了，耳机里放着坂本龙一的「A Flower Is Not A Flower」。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 44 Review]]></title>
    <link href="http://jiayuanzhang.com/2016-week-44.html"/>
    <updated>2016-12-22T20:00:41+08:00</updated>
    <id>http://jiayuanzhang.com/2016-week-44.html</id>
    <content type="html">
<![CDATA[<ul>
<li><strong>Coding</strong> - 本周主要在看《利用 Python 进行数据分析》，大概看了有一半的样子，下周应该能够结束掉。接下来的打算可能是先不看书，而是把<a href="https://www.quora.com/What-should-I-learn-in-data-science-in-100-hours">What should I learn in data science in 100 hours?</a>这个问题下面的回答内容实践一遍。</li>
<li><strong>Japanese</strong> - 日语已经落下好久了，大概还有1个月的时间考试，虽然只是报了一个三级试试水，但是不去考试总感觉白费报名费了，当初以为交了钱就会好好学，然而想多了。另外，日语现在并不是刚需的语言，之前决定学习是为了玩游戏，现在基本想玩的游戏都出了中文，《怪物猎人》玩了几个小时，发现不适合我这种手残。所以到底要不要继续学习日语还有待商榷……</li>
<li><strong>English</strong> - 英语自从到了大学以来就没有刻意地学过，除了准备托福的那段时间背了一些单词，然后其他都是直接用，导致了现在听说读写水平参差不齐，听力和阅读还算可以（至少能听懂和读懂技术相关的内容），口语基本就是没有说过，写作也没怎么练过，写一些基本的句子也要查语法（靠语感来写作结果就是一堆语法错……）。相比较日语来说，英语还算一个刚需的技能，尤其是写作和口语部分，还需要加强训练。接下来的一段时间内也会把英语学习提到日程上来，暂时的计划还没有想好，先加到 TODO 中。</li>
<li><strong>Reading</strong> - 发现这学期都没有读过几本书，上学期还能保持基本每周都读一本书，现在 Kindle 都吃灰了。下周先把《挪威的森林》这本书看完吧……</li>
<li><strong>Game</strong> - 等《精灵宝可梦 日月》发售，还有20天的样子，没有预定，直接买现货或者买下载版吧。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 Python 科学计算环境]]></title>
    <link href="http://jiayuanzhang.com/build-python-scienfic-computing-environment.html"/>
    <updated>2016-12-22T20:05:27+08:00</updated>
    <id>http://jiayuanzhang.com/build-python-scienfic-computing-environment.html</id>
    <content type="html">
<![CDATA[<p>最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。</p>

<h2 id="toc_0">安装虚拟环境</h2>

<p>不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在<a href="http://forrestchang.github.io/2016/07/17/virtualenv-notes/">virtualenv 相关笔记</a>这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用<code>alias</code>），这样就避免每次一打开就输入一长串命令了。</p>

<p>因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。</p>

<p>然后使用以下命令一键安装所需要的库：</p>

<pre><code class="language-shell">sudo pip install numpy pandas matplotlib jupyter scikit-learn
</code></pre>

<p>安装不上的请检查是不是需要翻墙。</p>

<h2 id="toc_1">IPython</h2>

<p>熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。</p>

<h3 id="toc_2">开启 IPython Notebook</h3>

<p>使用以下命令来打开 IPython Notebook：</p>

<pre><code class="language-shell">(ENV2.7)$ jupyter notebook
</code></pre>

<p>这样 server 就启动了，浏览器会自动打开一个目录树。</p>

<p>Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。</p>

<p>然后我们新建一个 IPython Notebook 用作演示：</p>

<p><img src="media/14824083276745/14776647413275.jpg" alt="14776647413275"/></p>

<p><code>In [1]</code> 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 <code>matplotlib</code> 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。</p>

<h3 id="toc_3">内省</h3>

<p>在变量的前面或后面加上一个 <code>?</code> 就可以将有关该对象的一些通用信息显示出来。</p>

<p><img src="media/14824083276745/14776649884990.jpg" alt="14776649884990"/></p>

<p>基本上什么都能看。</p>

<h3 id="toc_4"><code>%run</code> 命令</h3>

<p>使用 <code>%run</code> 可以运行本地的 Python 脚本，并可以在 IPython 中访问脚本中定义的所有变量。</p>

<p>如果想要脚本能够访问 IPython 中的命名空间，可以使用 <code>%run -i</code> 命令。</p>

<h3 id="toc_5">测试代码的执行时间</h3>

<p>使用 <code>%time</code> 和 <code>%timeit</code> 可以用来测试代码的执行时间。</p>

<p><img src="media/14824083276745/14776653395450.jpg" alt="14776653395450"/></p>

<h2 id="toc_6">Example</h2>

<p>下面使用一个具体的例子来演示 IPython Notebook 的使用。</p>

<p>使用到的数据可以在<a href="https://www.ssa.gov/oact/babynames/limits.html">Beyond the Top 1000 Names</a>下载到，这是一份包含1880-2015年每年出生婴儿姓名出现次数的数据表。</p>

<p>由于该数据按年份被分割成了好多文件，所以第一步我们需要把所有数据组装到一个 DataFrame 中去。</p>

<p><img src="media/14824083276745/14776659007521.jpg" alt="14776659007521"/></p>

<p>不知道这些 Python 代码没关系，因为这里只是用来演示 IPython Notebook。</p>

<p>然后我们按照性别和年度统计总出生数：</p>

<p><img src="media/14824083276745/14776660937109.jpg" alt="14776660937109"/></p>

<p>然后绘制出表格：</p>

<p><img src="media/14824083276745/14776661445090.jpg" alt="14776661445090"/></p>
]]>
    </content>
  </entry>
  
</feed>
