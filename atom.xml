<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hack Notes]]></title>
  <link href="http://forrestchang.com/atom.xml" rel="self"/>
  <link href="http://forrestchang.com/"/>
  <updated>2017-03-11T13:04:31+08:00</updated>
  <id>http://forrestchang.com/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[Digital Life in 2016: 音乐篇]]></title>
    <link href="http://forrestchang.com/digital-life-in-2016-music-part.html"/>
    <updated>2017-02-24T11:52:04+08:00</updated>
    <id>http://forrestchang.com/digital-life-in-2016-music-part.html</id>
    <content type="html">
<![CDATA[<p>最近知乎上的一个朋友和我私信聊了一些关于效率工具以及 Workflow（此处指的是「工作流」）方面的一些问题。聊的内容比较碎片，所以还是打算写一篇文章来具体讨论一下。考虑到会涉及很多不同的主题，所以还是一个主题写一篇，这样也可以控制文章的长度。暂定按照以下主题来写：音乐篇、阅读篇、写作篇和时间管理篇。</p>

<p>音乐对我来说，应该算是日常生活中比较重要的一项内容了，除了一些需要特别 Focus 的工作（例如看数学）不会听音乐外，其他时间都会戴着耳机。2016 年彻底地转入到 Apple Music 中来，期间试用过一段时间的 Spotify，网易云音乐几乎没怎么打开过。这篇打算讨论一下所有（尽量）听音乐方面相关的问题。</p>

<h2 id="toc_0">用什么设备听</h2>

<p>我的大多数电子设备都是 Apple 系的，包括 rMBP、iPhone、iPad，所以听音乐也都是围绕着这些设备来。严格的来说，并不能算一个「音乐发烧友」，我对设备的要求并不是太高，甚至对音源也没有太高的要求，Apple Music 的音质已经完全能够满足了，无损音源内容几乎不听，其一是没有购买 CD 的习惯，所以没有合法的途径获取无损资源；其二是一直都是拿 iTunes 听音乐，无损还需要转格式编辑信息，过于麻烦。</p>

<p>主力播放器是 Macbook，几乎 80% 的时间都是在 Macbook 上听（写代码、阅读、写作等）。另外便是新购入的 iPhone 7，主要是外出坐车、跑步或是睡前听一下（之前是用 5s）。iPad 很少用来听音乐。</p>

<p>使用的耳机是 <a href="https://www.amazon.com/Westone-Pro30-Performance-Universal-Earphones/dp/B00FKY3IFA">Westone UM Pro 30</a>，使用体验很好，对比 Apple 自带的耳机有惊艳的提升，而且长时间佩戴也没有不适感（几乎没有戴着耳机的感觉）。想要具体了解得可以去搜相关的评测来看。</p>

<p>耳机是在 7 发售之前买的，传闻 7 要去掉耳机接口的时候其实我是不信的，结果还真去掉了。这导致了插 7 上需要多接一根转接线，略显累赘，所以现在在 iPhone 上听歌就直接拿自带的耳机了。</p>

<h2 id="toc_1">为什么不用网易云音乐</h2>

<p>我知道，我也很讨厌类似「我为什么不 xxx」的说法，「不用就不用，还要批判一番」，但是还是要写一写。</p>

<p>其实我很早就开始使用网易云音乐了，那个时候一些热门的歌曲下评论还只有几百条，不像现在，动辄上千上万条评论。也安利过身边好多人用，曾经是长期的会员用户，所以还是有一些资格来谈论一下这个音乐服务的。</p>

<p>很明显，网易云音乐最初就是模仿 Spotify 的，包括界面设计，几乎一模一样。除了借鉴 Spotify 之外，网易云音乐还加入了很多自己的「创新」，而正是这些所谓的创新，让我开始慢慢得不想用它。</p>

<ol>
<li>评论：其实我是赞成加入评论功能的，但是网易云的评论已经偏离了音乐评论的范围，变成了编故事、讲段子、骗赞评论的聚集地。认真评论音乐的几乎没有，我不知道如果想看段子为什么不上微博？这一点实际上让一个音乐软件变成了社交软件，不好意思，我只想好好听音乐。</li>
<li>歌曲：网易云上很多歌曲的信息混乱不堪，包括专辑信息、专辑封面、年份等，很多单曲甚至没有专辑信息，直接被编排到「热门歌曲串烧」这样的专辑里，我有强迫症，看着挺 low 的。并且很多的歌来源都不明确，大多数都是网友上传，甚至很多 Bilibili 鬼畜区的音乐也被上传上来，哪天听推荐就冷不丁得听到。</li>
<li>专辑封面不完整：网易云的一大特色就是模仿唱片机旋转，想看一下专辑封面是什么样还要点到专辑列表里面去看。在我看来，在电子设备上「拟物」是一种很没有效率的事，就像之前电子书的模拟翻页一样，「翻页」这个动作本来就是一个三维的过程，在手机上再怎么模拟也达不到现实中的效果，「瀑布式」的阅读方式才是正确的选择。所以我推崇「反拟物化」、「扁平化」和「极简化」的设计风格。</li>
<li>歌单：几乎所有的歌单都是由用户创建，和 Apple Music 与 Spotify 专门的音乐编辑创建的歌单相比，高下立判。</li>
</ol>

<p>在我看来，听音乐是一件很纯粹的事，而网易云给这件纯粹的事加了太多的东西。</p>

<h2 id="toc_2">Apple Music 之痛</h2>

<p>Apple Music 自从 2015 年 6 月发布以来，到现在已经有接近两年的时间了，从发布当天付费到现在，中间用了一段时间的国区，由于曲库原因，现在还换回了港区，每月 48 港币，虽然比国区每月 10 ￥（学生 5 ￥）贵了不少，不过依然很值，想想一张专辑的钱就可以听一个月。</p>

<p>虽说经过这么长时间的发展，Apple Music 依然可以说做得很烂，我在一年前的一篇文章（<a href="http://forrestchang.github.io/14824082548997.html">《Apple Music，古典音乐，阅读》</a>）中已经吐槽过了，除了网络问题有了明显改善之外，其他的并没有太大的改进。以至于现在每年的 WWDC 最期待的不是发布什么新产品，而是 Apple Music 有什么大的改进，加了些什么功能。</p>

<p>我在 V2EX 上也发过<a href="https://www.v2ex.com/t/336425">一篇帖子</a>吐槽过 Apple Music。</p>

<p>这些问题肯定和 iTunes 的历史因素有关，iTunes 本身就是作为一个音乐商店，在没有 Apple Music 之前，听音乐的流程就是从商店中购买数字音乐（或者从 CD 中导入），然后添加到 Library 中，之后对这些音乐做什么事都与商店中的音乐无关了。而到了 Apple Music，它依然延续着之前的流程，当把音乐添加到 Library 中后，你对音乐做出的评分、加心实际上都和云端的数据无关了，所有数据都存放在本地的 <code>iTunes Library.xml</code> 文件中，所以这才会导致一部分音乐明明加过心了，到了手机上一看却是没有加过心的，并且由于存放在本地的原因，云端的数据也不会更新，这也会影响到每天推荐给你的音乐。</p>

<p>Medium 上的一个设计师专门帮 Apple Music 重新设计了一下：<a href="https://medium.com/product-design-ux-ui/apple-music-redesign-part-1-526c4c4c4777#.lopgpvt41">Apple Music Redesign</a>，在我看来，比原版的 Apple Music 好太多。</p>

<p>很难想象，把 iPhone 做得只有 7 mm 厚的科技公司，竟然连 iTunes 中遗留的种种问题也解决不好。</p>

<h2 id="toc_3">听什么</h2>

<p>我并不打算讲太多「听什么」的内容，音乐本来就是一个很个人的事情，但是，音乐真的没有好坏吗？实际上，Apple Music 与网易云一个很大的不同点就是，前者有意得引导你听，而后者是根据你听歌的记录推荐相似的（尽管并不准）歌曲。</p>

<p>相比较网易云的每日推荐，Apple Music 只有一个最爱精选（My Favorites Mix），里面有很多你之前就已经喜欢的歌，每周更新一次。而更多的每天推荐是类似「朴树：音乐灵感」、「古典音乐：混音和改编歌曲」这样的人工手动编辑的歌单，而一般这样的歌单都会附带编辑的一些评语，让你能够大体得了解这张歌单内容，比如今天推荐给我的「古典音乐：混音和改编歌曲」：</p>

<blockquote>
<p>古典樂的經典旋律恆久不變，但同樣的旋律放在此歌單中卻可讓你帶來驚喜！耳熟能詳的柴可夫斯基、韋瓦第等大師作品，換上電子工程師 Max Richer、CFCF 及 DJ Spooky 的混音和改編，令幾百年前的作品添上時代感，即使充滿實驗性和玩味，趣味滿分。</p>
</blockquote>

<p>相比没有目的、仅仅根据自己的喜好乱听，这种引导的方式会慢慢影响你的音乐品味。</p>

<p>另一方面，它还会每天给你推荐不一样的专辑，比如我喜欢听 Imagine Dragons，它今天就给我基于此推荐了《An Awesome Wave》、《Skying》、《Megalithic Symphony》等专辑。</p>

<p>快餐音乐时代，很多歌曲单独从专辑中拿出来听也不会有什么问题，但是按照专辑来听，依然是严肃欣赏音乐的唯一方式。</p>

<h2 id="toc_4">怎么听</h2>

<p>用过两种方法。</p>

<p>1）类似于 Spotify，添加到 Library 的歌曲就算是你想以后继续听的，「加心」的行为只是用来作为推荐的参考。这种方式就不需要再本地再建一个智能播放列表专门用来过滤加心的歌曲了，因为 Library 中的所有的歌都是你想听的。</p>

<p>2）添加到 Library 中只是作为一个「稍后听」的过程，一般这种情况是按照专辑来添加到 Library 中，然后把这张专辑从头到尾（或者以你喜欢的方式）听一遍，把喜欢的歌加心，并给歌曲评分（可选），然后建立智能播放列表过滤出加心的歌，例如，我除了有一个 「Favorites」 歌单（自动更新 Library 中加心的歌曲），还有一个「古典精选」歌单，其中内容是类型为「Classical」并且已经加心了的歌曲。智能播放列表可以使用很复杂的过滤器。这种听歌方式也是现在我用的，这其实和之前在 iTunes Store 上购买音乐再听并没有什么区别，除了改成了订阅的方式并且附带了推荐功能。</p>

<p>不过听音乐这种事各有各的方法，这里也仅仅是提供参考。</p>

<h2 id="toc_5">一些辅助工具</h2>

<p>其实写到这里基本已经写完了。如果你不是一个强迫症、数据控、偏执狂或是一个完美主义者，最后这部分并没有什么太多帮助。</p>

<p>我使用 <a href="https://www.last.fm">last.fm</a> 来记录自己听了什么，Mac 上使用的是官方的 Last.fm Scrobbler 这个软件，不过它只能记录离线的歌曲，对于 Radio 就无能为力了，所以我辅助 <a href="http://bowtieapp.com/">Bowtie</a> 这个小软件来记录，为了防止重复记录，需要把 Last.fm Scrobbler 中的 Enable Scrobbling 选项关闭。</p>

<p>记录数据可以让你更好得知道平常的音乐喜好，以及某张专辑、某首歌、某个艺人听了多少次等等。并且 last.fm 提供通用的 API 来方便导出这些数据，说不定以后有什么用。</p>

<p>过去一周我的听歌记录可以在 <a href="https://www.last.fm/user/Tisoga/listening-report/week">这里</a> 看到。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[换了一个新地方写东西]]></title>
    <link href="http://forrestchang.com/14878992387553.html"/>
    <updated>2017-02-24T09:20:38+08:00</updated>
    <id>http://forrestchang.com/14878992387553.html</id>
    <content type="html">
<![CDATA[<p>现在这个博客只写技术相关的内容，其他的随笔都写在<a href="https://medium.com/@Tisoga">新博客</a>里，Medium 是被大陆屏蔽的，所以请自备梯子。另外一些比较私人的笔记——例如「Week Review」系列就不发表在互联网上了。</p>

<p>至于原因，单纯得觉得 Medium 上的衬线字体很好看。<del>如果需要魔改这个博客的话，还是挺麻烦的，自己目前的前端知识还处于未入门的水平，所以就不折腾了。</del>结果我还是魔改了，现在风格比较简洁了，照着 <a href="https://github.com/lepture/yue.css">yue.css</a> 改的。</p>

<p>既然重新换了一个主题，就不换地方写了……</p>

<p>主题的代码放在 <a href="https://github.com/forrestchang/Cuckoo">GitHub</a> 上，完全是新手的作品，所以还是不要 star 了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 风格指南笔记]]></title>
    <link href="http://forrestchang.com/14871569977647.html"/>
    <updated>2017-02-15T19:09:57+08:00</updated>
    <id>http://forrestchang.com/14871569977647.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">函数与方法装饰器</a>
</li>
<li>
<a href="#toc_1">线程</a>
</li>
<li>
<a href="#toc_2">威力过大的特性</a>
</li>
<li>
<a href="#toc_3">注释</a>
<ul>
<li>
<a href="#toc_4">模块</a>
</li>
<li>
<a href="#toc_5">函数和方法</a>
</li>
<li>
<a href="#toc_6">类</a>
</li>
<li>
<a href="#toc_7">块注释和行注释</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">类</a>
</li>
<li>
<a href="#toc_9">TODO 注释</a>
</li>
<li>
<a href="#toc_10">导入格式</a>
</li>
<li>
<a href="#toc_11">访问控制</a>
</li>
<li>
<a href="#toc_12">命名</a>
</li>
</ul>


<h2 id="toc_0">函数与方法装饰器</h2>

<ul>
<li>优点：优雅的在函数上指定一些转换，该转换可能减少一些重复代码，保持已有函数不变（enforce invariants）</li>
<li>缺点：装饰器可以在函数的参数或返回值上执行任何操作，这可能导致让人惊异的隐藏行为。而且，装饰器在导入时执行。从装饰器代码的失败中恢复更加不可能。</li>
<li>结论：如果好处很显然，就明智而谨慎的使用装饰器。装饰器应该遵守和函数一样的导入和命名规则。装饰器的 Python 文档应该清晰的说明函数是一个装饰器。请为装饰器编写单元测试。<strong>避免装饰器自身对外界的依赖（即不要依赖于文件、socket、数据库连接等）</strong>。</li>
</ul>

<h2 id="toc_1">线程</h2>

<p>优先使用 Queue 模块的 <code>Queue</code> 数据类型作为线程间的数据通信方式。另外，使用 threading 模块及其锁原语（locking primitives）。了解条件变量的合适使用方式，这样你就可以使用 <code>threading.Condition</code> 来取代低级级别的锁了。</p>

<h2 id="toc_2">威力过大的特性</h2>

<ul>
<li>Tip：避免使用这些特性</li>
<li>优点：强大的语言特性，能让你的代码更紧凑</li>
<li>缺点：使用这些很 cool 的特性十分诱人，但不是绝对必要。使用奇技淫巧的代码将更加难以阅读和调试。开始可能还好，但当你回顾代码，它们可能比那些稍长一点但是更直接的代码更加难以理解。</li>
<li>结论：在你的代码中避免使用这些特性。</li>
</ul>

<h2 id="toc_3">注释</h2>

<p>Python 有一种独一无二的注释方式：使用文档字符串。文档字符串是包、模块、类或函数的第一个语句。这些字符串可以通过对象的 <code>__doc__</code> 成员被自动提取，并且被 <code>pydoc</code> 所用。</p>

<p>组织方式：</p>

<ul>
<li>第一行以句号、问号或惊叹号结尾的概述（或者改文档字符串只有单纯的一行）</li>
<li>接着是一个空行</li>
<li>接着是文档字符串的剩余部分，它应当与文档字符串的第一行的第一个引号对齐</li>
</ul>

<h3 id="toc_4">模块</h3>

<p>每个文件应该包含一个许可样板。根据项目使用的许可（例如：Apache 2.0、BSD、LGPL、GPL）选择合适的样板。</p>

<h3 id="toc_5">函数和方法</h3>

<p>一个函数必须要有文档字符串，除非它满足以下条件：</p>

<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>

<p>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，<strong>不应该描述「怎么做」，除非是一些复杂的算法</strong>。文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。<strong>对于复杂的代码，在代码旁边加注释胡比使用文档字符串更有意义</strong>。</p>

<p>关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面入下文所示，每节应该以一个标题行开始。标题行以冒号结尾，除标题行外，节的其他内容应被缩进 2 个空格。</p>

<ul>
<li>Args：列出每个每个参数的名字，并在名字后面使用一个冒号和空格，分隔对该参数的描述。如果描述太长超过了单行 80 个字符，使用 2 或者 4 个空格的悬挂缩进。<strong>描述应该包括所需的类型和含义</strong>。如果一个函数接受<code>可变长参数列表</code>或者<code>任意关键字参数</code>，应该详细列出这两者。</li>
<li>Returns（或者 Yields，用于生成器）：描述返回值的类型和语义，如果函数返回 None，这一部分可以省略。</li>
<li>Raises：列出与接口有关的所有异常。</li>
</ul>

<p>例子：</p>

<pre><code class="language-python">def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
    &quot;&quot;&quot;Fetches rows from a Bigtable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by big_table.  Silly things may happen if
    other_silly_variable is not None.

    Args:
        big_table: An open Bigtable Table instance.
        keys: A sequence of strings representing the key of each table row
            to fetch.
        other_silly_variable: Another optional variable, that has a much
            longer name than the other args, and which does nothing.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),
         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),
         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}

        If a key from the keys argument is missing from the dictionary,
        then that row was not found in the table.

    Raises:
        IOError: An error occurred accessing the bigtable.Table object.
    &quot;&quot;&quot;
    pass
</code></pre>

<h3 id="toc_6">类</h3>

<p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公有属性，那么文档中应该有一个属性段，并且应该遵守和函数参数相同的格式。</p>

<pre><code class="language-python">class SampleClass(object):
    &quot;&quot;&quot;Summary of class here.

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    &quot;&quot;&quot;

    def __init__(self, likes_spam=False):
        &quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;
        self.likes_spam = likes_spam
        self.eggs = 0

    def public_method(self):
        &quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;
</code></pre>

<h3 id="toc_7">块注释和行注释</h3>

<p><strong>最需要些注释的是代码中那些技巧性的部分</strong>。对于复杂的操作，应该在其操作开始前写上若干行注释，对于不是一幕了然的代码，应该在其行尾添加注释。</p>

<p>为了提高可读性，注释至少应该离开代码 2 个空格。</p>

<p><strong>绝对不要描述代码</strong>，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么。</p>

<h2 id="toc_8">类</h2>

<p>如果一个类不继承自其它类，就显式的从 object 继承，嵌套类也一样。</p>

<h2 id="toc_9">TODO 注释</h2>

<p>TODO 注释应该在所有开头处包含「TODO」字符串，紧跟着的是用括号括起来的你的名字，email 地址或者其他标识符。接着必须有一行注释，解释要做什么。</p>

<p>Example：</p>

<pre><code class="language-python"># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.
# TODO(Zeke) Change this to use relations.
</code></pre>

<p>如果你的 TODO 是「将来做某事」的形式，那么请确保你包含了一个指定的日期或者一个特定的时间。</p>

<h2 id="toc_10">导入格式</h2>

<p>每个导入应该独占一行。导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前，导入应该按照从最通用到最不通用的顺序分组：</p>

<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序制定导入</li>
</ol>

<p>每种分组中，应该根据每个模块的完整包路径按字典顺序排序，忽略大小写。</p>

<h2 id="toc_11">访问控制</h2>

<p>字啊 Python 中，对于琐碎又不太重要的访问函数，你应该直接使用公有变量来取代它们，这样可以避免额外的函数调用开销。当添加更多的功能时，你可以用属性（property）来保持语法的一致性。</p>

<p>另一方面，如果访问更复杂，或者变量的访问开销很显著，那么你应该使用像 <code>get_foo()</code> 和 <code>set_foo()</code> 这样的函数调用。如果之前的代码行为允许通过属性（property）访问，那么久不要井新的访问函数与属性绑定。这样，任何试图通过老方法访问变量的代码就没法运行，使用者也就会意识到复杂性发生了变化。</p>

<h2 id="toc_12">命名</h2>

<p>Python 之父 Guido 推荐的规范：</p>

<p><img src="media/14871569977647/14872190162425.jpg" alt=""/></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017 Week 1 Review]]></title>
    <link href="http://forrestchang.com/14832795759469.html"/>
    <updated>2017-01-01T22:06:15+08:00</updated>
    <id>http://forrestchang.com/14832795759469.html</id>
    <content type="html">
<![CDATA[<p>今天是元旦，因为在 Calendar 中把今天归到 2017 年的第一周里了，所以就按照上面所写的把这周当做第一周吧。</p>

<p>这周结束了在中软的课程设计实训，以前总嫌弃小渔村破，现在回来才知道还是小渔村好啊。课程设计实训的内容是用 Java 写一个点餐系统，一个小组只需要做一份就可以了，不过几乎所有人都不知道 Git 是个什么东西，小组合作还是用的 U 盘拷贝代码，所以代码质量可想而知了，本组的其他人都比较厉害，索性我就抱大腿划水了，什么也没有参与，代码也没有写一行。</p>

<p>不过虽说没有写课程设计的项目，但还是有写代码的。这周把两个月前参加 HACKxFDU 的项目拿出来用 Python 3 重写了一遍。项目的地址：<a href="https://github.com/forrestchang/Neutron">Neutron</a>，当初我们考虑做 Neutron 的时候是想把它做成一个通用的智能家居语音终端的，类似于 Amazon 的 Echo，只要提供第三方的 API，就能轻松集成到 Neutron 来，但是实际上碍于 Hackathon 的时间限制，只是完成了一个简单的 Demo，完全没有拓展性。本来这个项目参加完 Hackathon 之后就没有管了，不过最近看到 Facebook CEO 扎克伯格写了一个 Jarvis，觉得和之前做的东西很像（当然还是差远了，基本我们做的东西就是用别人的 API），所以又掏出来拿 Python 3.5 重写了一遍。现在在 <a href="https://github.com/forrestchang/neutron/tree/develop">develop</a> 分支基本上把框架搭建好了，最底层是和 API 交互的 layer 层，这一层需要为每个 API 写特定的代码，其上是抽象的 handler 层，提供通用的接口，抽象 layer 层的操作：例如语音控制模块、AI 模块等，这一层上还可能包裹一层特定的 wrapper，例如对特定的 message 做语义分析。通过配置文件来选择使用哪个 layer 以及配置 layer 的内容（key 等内容），开始的时候打算用 json 来做配置文件的，后来看了一下还有 yaml 这种更加简洁的配置文件，所以打算换成 yaml 的。目前这个项目还有很多内容要写的，比如特定的 layer，都需要更具不同的 API 写特定的代码，这一点上我参考的 <a href="https://github.com/syl20bnr/spacemacs">Spacemacs</a> 的方法。</p>

<p>这周在中软那边的宿舍里面把08版的《射雕英雄传》看完了，虽然槽点挺多的（特效、台词、演技），但是还是看得很欢乐，林依晨的黄蓉甚是喜欢。记得以前应该是看过朱茵版的黄蓉的，不过时间太久远了，已经记不太清了。小说倒没有读完，还是看剧比较快啊。看完后好长一段时间里面都觉得特别空虚，总感觉少了些什么。这种孤独感几乎在每次看完某部小说和电视剧后都会有（电影倒没有这种感觉，可能时间太短了），总觉得还沉浸在别人的故事里，可惜别人的故事已经结束，不得不回到现实中来。想起席慕蓉的一句话『在别人的故事里，留着自己的泪』 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 。</p>

<hr/>

<p>就借着这篇博客顺便说说 17 年的计划吧。</p>

<ol>
<li>学习一门新语言：14年学了 C、Scheme，15年学了 Java、Python，16年学了 Swift，再加上各种用过但是不熟的语言，也有好多个了。现在主力开发语言是 Python，17年打算学习 一下 JavaScript，这门 GitHub 上最火的语言，不会都不好意思说自己是程序员。也不用学到多么深，只求达到入门水平。</li>
<li>Python 水平达到 professional，用了接近两年的 Python，但是水平也没有长进多少，今年打算深入一下 Python，多写一些项目。</li>
<li>去周边国家玩一次，其实挺想去尼泊尔的，不知道今年有没有时间。不过即使不出国，也要多出去走走，一个人的旅行。</li>
</ol>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>席慕蓉的《戏子》，用在这里并不完全准确。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 52 Review]]></title>
    <link href="http://forrestchang.com/14827163208652.html"/>
    <updated>2016-12-26T09:38:40+08:00</updated>
    <id>http://forrestchang.com/14827163208652.html</id>
    <content type="html">
<![CDATA[<p>2016 年最后一周（实际上还有6天，不过那一周就算到 2017 年第一周吧）。</p>

<ul>
<li><strong>编程</strong>：这周在看《Python 网络数据采集》，以前虽然也用过爬虫，但是毕竟没有系统地学过，所以还是找了一本书来看。但是说实话，这本书写得并不是很好，不知道是写书时间的原因还是什么，挺多语法错误的，而且代码的风格很差（完全不符合 PEP8 标准）。内容也比较浅，基本上都是之前已经知道了的东西，所以收获也不是很多，（下一篇的博客可以来写一写怎么写一个高效的爬虫）。面试的事情作废了，1）看了一下他们做的产品，感觉不是自己想要做的东西；2）开出的薪资太低，up to 2k（其实主要是薪资太低了，每天要往返金石滩和大连市，太累了）。所以还是好好学习准备明年的暑期实习吧。另外 GSoC 也应该放上日程了，即使有申请不上的可能，还是要试一试的。</li>
<li><strong>阅读</strong>：开始读金庸的《射雕英雄传》，以前上学的时候一直被家里教导不要沉迷武侠小说，所以一直没有读过金庸和古龙（然而那些时间都用来看网文玄幻了……）。最近读来还是觉得很有意思，作为实训的时候消遣很不错（主要没有网）。</li>
<li><strong>生活</strong>：这周五就可以离开这鬼地方了，见识过外包公司的情况后决定以后肯定是不会进这种公司的。在公司里实训也一直没有写代码，本来打算用 Python 实现一下实训的题目的，但是老师说不允许，这也没什么办法，索性就划水吧。</li>
<li><strong>博客</strong>：可以看到，我博客又换样子了。用 Emacs 来写博客还是太麻烦了一些，而且 render 的速度实在是太感人，本地的 org 文件多了之后好几次 render 的时候卡住。现在这个博客是 Mweb 自带的 generator 生成的，就是主题不怎么好看，其他的都很方便。奈何自己的前端知识太渣，改了半天也没有改成自己想要的样子，所以还是凑合着先用吧。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐系统笔记]]></title>
    <link href="http://forrestchang.com/14824086421976.html"/>
    <updated>2016-12-22T20:10:42+08:00</updated>
    <id>http://forrestchang.com/14824086421976.html</id>
    <content type="html">
<![CDATA[<p>开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。</p>

<p>这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。</p>

<h2 id="toc_0">基于用户的协同过滤</h2>

<h3 id="toc_1">协同过滤（Collaborative filtering）</h3>

<p>一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。</p>

<h3 id="toc_2">测试数据集</h3>

<p>为了演示一些算法，我们需要从<a href="http://grouplens.org/datasets/movielens/">这个网站</a>上下载一份数据集。这里因为是作为演示使用，所以只需要下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>这一份简单的数据集就可以了。</p>

<h3 id="toc_3">相似度计算</h3>

<p>在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的<strong>相似度评价值</strong>。</p>

<h4 id="toc_4">欧几里德距离评价（Euclidean Distance Score）</h4>

<p>欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作\((p_1, p_2, p_3, p_4, ...)\)和\((q_1, q_2, q_3, q_4, ...)\)，则欧几里德距离的计算公式为：</p>

<p>\[<br/>
\sqrt{((p_1-q_1)^2+(p_2-q_2)^2+...+(p_n-q_n)^2)} = \sqrt{(\sum_{i=1}^n(p_i-q_i)^2)}<br/>
\]</p>

<p>创建 <code>recommendations.py</code>。</p>

<p>用代码表示：</p>

<pre><code class="language-python">from math import sqrt

# 返回一个有关 person1 与 person2 的基于距离的相似度评价
def sim_distance(prefs, person1, person2):
    # 得到 shared_items 的列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
        shared_items[item] = 1
    
    # 如果两者没有共同之处，则返回 0
    if len(shared_items) == 0:
        return 0
        
    # 计算所有差值的平方和
    sum_of_squares = sum([pow(prefs[person1][item]-prefs[person2][item], 2)for item in prefs[person1] if item in prefs[person2]])
    
    return 1 / (1 + sqrt(sum_of_squares))
</code></pre>

<p>欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。</p>

<p>好了，现在我们需要先将数据读取进来，在 <code>recommendations.py</code> 中添加如下代码:</p>

<pre><code class="language-python">def loadMovieLens(path=&#39;data&#39;):
    movies = {}
    for line in open(path + &#39;/movies.csv&#39;):
        (id, title) = line.split(&#39;,&#39;)[0:2]
        movies[id] = title

    prefs = {}
    for line in open(path+&#39;/ratings.csv&#39;):
        (user, movieid, rating, ts) = line.split(&#39;,&#39;)
        prefs.setdefault(user, {})
        prefs[user][movies[movieid]] = float(rating)
    return prefs
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; import recommendations
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 比较 10 号用户 和 20 号用户的相似度评价
&gt;&gt;&gt; recommendations.sim_distance(prefs, &#39;10&#39;, &#39;20&#39;)
0.23371479611805132
</code></pre>

<h4 id="toc_5">皮尔逊相关系数（Pearson Correlation Coefficient）</h4>

<p>皮尔逊相关系数是一种度量两个变量间相关程度的方法，它是一个介于 1 和 -1 之间的值，其中，1 表示变量完全正相关，0 表示无关， -1 则表示完全负相关（一个变量的值越大，则另一个变量的值反而会越小）。</p>

<p>计算公式：</p>

<p>\[<br/>
r = \frac{\sum{XY}-\frac{\sum X \sum Y}{N}}{\sqrt{(\sum X^2 - \frac{(\sum X)^2}{N})(\sum Y^2 - \frac{(\sum Y)^2}{N})}}<br/>
\]</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def sim_pearson(prefs, person1, person2):
      # 得到双方都曾评价过的物品列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            shared_items[item] = 1
      # 得到物品列表元素的个数
    n = len(shared_items)

      # 如果两者没有共同元素，则返回0
    if n == 0:
        return 0

      # 计算 person1 和 person2 的皮尔逊相关系数
    sumxy = sum([prefs[person1][item] * prefs[person2][item]
                for item in shared_items])
    sumx = sum([prefs[person1][item] for item in shared_items])
    sumy = sum([prefs[person2][item] for item in shared_items])
    sumx2 = sum([prefs[person1][item] ** 2 for item in shared_items])
    sumy2 = sum([prefs[person2][item] ** 2 for item in shared_items])

    zahler = sumxy - (sumx * sumy) / n
    nenner = sqrt((sumx2 - (sumx ** 2) / n) * (sumy2 - (sumy ** 2) / n))
    if nenner == 0:
        return 0
    r = zahler / nenner

    return r
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.sim_pearson(prefs, &#39;10&#39;, &#39;20&#39;)
0.4908806936738162
</code></pre>

<p>可以看到和上面使用欧几里德距离评价计算出来的相似度是不一样的。</p>

<h4 id="toc_6">关于该使用哪一种相似性度量方法</h4>

<p>除了这两种计算相似度的方法，实际上还有许多别的计算相似度的算法，例如<strong>Tanimoto 分值</strong>。使用哪一种方法，完全取决于具体的应用。</p>

<p>下面的代码中，将使用一个通用的相似性函数来计算相似度，只要它满足以下条件：拥有同样的函数签名，以一个浮点数作为返回值，其数值越大代表相似度越大。</p>

<h3 id="toc_7">寻找相似的用户</h3>

<p>既然我们已经有了对两个人进行比较的函数，下面我们就可以编写，根据指定人员对每个人进行打分，并找出最接近的匹配结果了。</p>

<pre><code class="language-python"># 从反映偏好的字典中返回最佳匹配者
# 返回结果的个数和相似度函数均为可选参数
def topMatches(prefs, person, n=5, similarity=sim_pearson):
    scores = [(similarity(prefs, person, other), other) for other in prefs if other != person]
    
    # 对列表进行排序，评价值最高者排在最前面
    scores.sort(reverse=True)
    return scores[:n]
</code></pre>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 与 40 号用户相似的 10 个用户
&gt;&gt;&gt; recommendations.topMatches(prefs, &#39;40&#39;, n=10)
[(1.0, &#39;63&#39;),
 (1.0, &#39;582&#39;),
 (1.0, &#39;326&#39;),
 (1.0, &#39;260&#39;),
 (1.0, &#39;220&#39;),
 (1.0, &#39;198&#39;),
 (1.0, &#39;153&#39;),
 (1.0, &#39;116&#39;),
 (0.9999999999999947, &#39;474&#39;),
 (0.9999999999999947, &#39;215&#39;)]
</code></pre>

<h3 id="toc_8">推荐物品</h3>

<p>有的时候我们可能不需要寻找相似的用户，例如在购物网站中，我们需要的是一份可能会想要购买的物品列表，一种方法是从相似的用户所购买的物品列表中选出没有购买的，但是这种方法不确定的因素太多，例如可能相似用户还未购买某些物品，而这些物品恰恰就是我们所需要的。</p>

<p>为了解决上面的问题，我们需要通过一个经过加权的评价值来为影片打分，评论者的评分结果因此而形成了先后的排名。为此，我们需要取得所有其他评论者的评价结果，借此得到相似度之后，再乘以他们为每部影片所给的评价值。</p>

<p>以以下数据集为例：</p>

<pre><code>{&#39;Lisa Rose&#39;: {&#39;Lady in the Water&#39;: 2.5,
               &#39;Snakes on a Plane&#39;: 3.5,
               &#39;Just My Luck&#39;: 3.0,
               &#39;Superman Returns&#39;: 3.5,
               &#39;You, Me and Dupree&#39;: 2.5,
               &#39;The Night Listener&#39;: 3.0},
 &#39;Gene Seymour&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 1.5,
                  &#39;Superman Returns&#39;: 5.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Michael Phillips&#39;: {&#39;Lady in the Water&#39;: 2.5,
                      &#39;Snakes on a Plane&#39;: 3.0,
                      &#39;Superman Returns&#39;: 3.5,
                      &#39;The Night Listener&#39;: 4.0},
 &#39;Claudia Puig&#39;: {&#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 3.0,
                  &#39;The Night Listener&#39;: 4.5,
                  &#39;Superman Returns&#39;: 4.0,
                  &#39;You, Me and Dupree&#39;: 2.5},
 &#39;Mick LaSalle&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 4.0,
                  &#39;Just My Luck&#39;: 2.0,
                  &#39;Superman Returns&#39;: 3.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 2.0},
 &#39;Jack Matthews&#39;: {&#39;Lady in the Water&#39;: 3.0,
                   &#39;Snakes on a Plane&#39;: 4.0,
                   &#39;The Night Listener&#39;: 3.0,
                   &#39;Superman Returns&#39;: 5.0,
                   &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Toby&#39;: {&#39;Snakes on a Plane&#39;: 4.5,
          &#39;You, Me and Dupree&#39;: 1.0,
          &#39;Superman Returns&#39;: 4.0}}
</code></pre>

<p>假设我们需要给 Toby 提供影片推荐，我们可以根据上面的算法得出一张表：</p>

<table>
<thead>
<tr>
<th>评论者</th>
<th>相似度</th>
<th>Night</th>
<th>S.xNight</th>
<th>Lady</th>
<th>S.xLady</th>
<th>Luck</th>
<th>S.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Rose</td>
<td>0.99</td>
<td>3.0</td>
<td>2.97</td>
<td>2.5</td>
<td>2.48</td>
<td>3.0</td>
<td>2.97</td>
</tr>
<tr>
<td>Seymour</td>
<td>0.38</td>
<td>3.0</td>
<td>1.14</td>
<td>3.0</td>
<td>1.14</td>
<td>1.5</td>
<td>0.57</td>
</tr>
<tr>
<td>Puig</td>
<td>0.89</td>
<td>4.5</td>
<td>4.02</td>
<td></td>
<td></td>
<td>3.0</td>
<td>2.68</td>
</tr>
<tr>
<td>LaSalle</td>
<td>0.92</td>
<td>3.0</td>
<td>2.77</td>
<td>3.0</td>
<td>2.77</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Matthews</td>
<td>0.66</td>
<td>3.0</td>
<td>1.99</td>
<td>3.0</td>
<td>1.99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td></td>
<td>12.89</td>
<td></td>
<td>8.38</td>
<td></td>
<td>8.07</td>
</tr>
<tr>
<td>Sim.Sum</td>
<td></td>
<td></td>
<td>3.84</td>
<td></td>
<td>2.95</td>
<td></td>
<td>3.18</td>
</tr>
<tr>
<td>总计/Sim.Sum</td>
<td></td>
<td></td>
<td>3.35</td>
<td></td>
<td>2.83</td>
<td></td>
<td>2.53</td>
</tr>
</tbody>
</table>

<p>表中列出来每位评论者的相关度评价值，以及他们对三部影片的评分情况。以 S.x 打头的列给出了乘以评价值之后的相似度。如此一来，相比于与我们不相近的人，那些与我们相近的人将会对整体评价拥有更多的贡献。总计所有加权评价值的和。</p>

<p>我们也可以选择利用总计值来计算排名，但是这其中有一个问题，一部受更多人评论的影片会对结果产生很大影响。为了修正这一问题，我们需要除以表总名为 Sim.Sum 的那一行，它代表了<strong>所有对这部电影有过评论的评论者的相似度之和</strong>。对于影片《Lady in the Water》来说，Puig 并未做过评论，所以我们将这部影片的总计值除以所有其他人的相似度之和。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python"># 利用所有其他人评价值得加权平均，为某人提供建议
def getRecommendations(prefs, person, similarity=sim_pearson):
    totals = {}
    simSums = {}
    for other in prefs:
        # 不要和自己做比较
        if other == person:
            continue
        sim = similarity(prefs, person, other)
        
        # 忽略评价值为零或者小于零的情况
        if sim &lt;= 0:
            continue
            
        for item in prefs[other]:
            # 只对自己还未看过的影片进行评价
            if item not in prefs[person] or prefs[person][item] == 0:
                # 相似度*评价值
                totals.setdefault(item, 0)
                totals[item] += prefs[other][item] * sim
                # 相似度之和
                simSums.setdefault(item, 0)
                simSums[item] += sim
        
        # 建立一个归一化的列表
        rankings = [(total / simSums[item], item) for item, total in totals.items()]
        
        # 返回经过排序的列表
        rankings.sort(reverse=True)
        return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; relaod(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.getRecommendations(prefs, &#39;10&#39;)[:20]
[(5.000000000000001,
  &#39;The Slipper and the Rose: The Story of Cinderella (1976)&#39;),
 (5.000000000000001, &#39;Hands on a Hard Body (1996)&#39;),
 (5.000000000000001, &#39;For the Birds (2000)&#39;),
 (5.000000000000001, &#39;Diva (1981)&#39;),
 (5.0, &#39;Zorba the Greek (Alexis Zorbas) (1964)&#39;),
 (5.0, &#39;Zerophilia (2005)&#39;),
 (5.0, &#39;Zelary (2003)&#39;),
 (5.0, &#39;Z Channel: A Magnificent Obsession (2004)&#39;),
 (5.0, &#39;Yossi (Ha-Sippur Shel Yossi) (2012)&#39;),
 (5.0, &#39;World of Tomorrow (2015)&#39;),
 (5.0, &#39;Woody Allen: A Documentary (2012)&#39;),
 (5.0, &#39;Woman on Top (2000)&#39;),
 (5.0, &#39;Without a Clue (1988)&#39;),
 (5.0, &#39;Withnail &amp; I (1987)&#39;),
 (5.0, &#39;Wild Zero (2000)&#39;),
 (5.0, &#39;War Room (2015)&#39;),
 (5.0, &#39;Walker (1987)&#39;),
 (5.0, &#39;Voices from the List (2004)&#39;),
 (5.0, &#39;Videodrome (1983)&#39;),
 (5.0, &#39;Victoria (2015)&#39;)]
</code></pre>

<h3 id="toc_9">匹配商品</h3>

<p>现在我们已经可以为指定人员寻找品味相近的用户，以及如何向其推荐商品。假如我们想要了解哪些物品是相近的，那又该如何呢？</p>

<p>在我们浏览 Amazon 的时候，经常会看到页面底部会推荐与当前浏览的物品相似的商品。这种情况，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，这和我们之前用来计算人与人之间的相似度是一样的，只需要把人和物品相互调换就行了。</p>

<p>我们来编写这个翻转字典的函数：</p>

<pre><code class="language-python">def transformPrefs(prefs):
    result = {}
    for person in prefs:
        for item in prefs[person]:
            result.setdefault[item, {}]
            # 将物品和人对调
            result[item][person] = prefs[person][item]
    return result
</code></pre>

<p>有了这个方法之后，我们就可以复用之前所写的方法了。</p>

<p>在 ipython 环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; load(recommendations)
&gt;&gt;&gt; movies = recommendations.transformPrefs()
&gt;&gt;&gt; recommendations.topMatches(movies, &#39;For the Birds (2000)&#39;)
[(1.000000000000016, &#39;&quot;Silence of the Lambs&#39;),
 (1.0, &#39;World War Z (2013)&#39;),
 (1.0, &#39;Wallace &amp; Gromit in The Curse of the Were-Rabbit (2005)&#39;),
 (1.0, &#39;Tron: Legacy (2010)&#39;),
 (1.0, &#39;Transcendence (2014)&#39;)]
</code></pre>

<p>我们还可以为影片推荐评论者：</p>

<pre><code class="language-python">&gt;&gt;&gt; recommendations.getRecommendations(movies, &#39;For the Birds (2000)&#39;)[:20]
[(5.0, &#39;668&#39;),
 (5.0, &#39;618&#39;),
 (5.0, &#39;543&#39;),
 (5.0, &#39;541&#39;),
 (5.0, &#39;536&#39;),
 (5.0, &#39;52&#39;),
 (5.0, &#39;464&#39;),
 (5.0, &#39;46&#39;),
 (5.0, &#39;409&#39;),
 (5.0, &#39;357&#39;),
 (5.0, &#39;308&#39;),
 (5.0, &#39;296&#39;),
 (5.0, &#39;29&#39;),
 (5.0, &#39;28&#39;),
 (5.0, &#39;197&#39;),
 (5.0, &#39;196&#39;),
 (5.0, &#39;190&#39;),
 (5.0, &#39;131&#39;),
 (5.0, &#39;113&#39;),
 (4.999999999999999, &#39;465&#39;)]
</code></pre>

<h2 id="toc_10">基于物品的协同过滤</h2>

<p>当前所完成的推荐系统，要求我们使用每一位用户的全部评分来构建数据集，这种方法对于小规模的数据集是没有问题的，但是对于像 Amazon 这样有着上百万用户和商品的大型网站而言，讲一个用户同其他所有用户进行比较，然后再对每位用户评过分的商品进行比较，时间花费上是巨大的。</p>

<p>目前为止我们所使用的技术被称为<strong>基于用户的协同过滤</strong>（user-based collaborative filtering）。除此以外，还有一种可供选择的方法被称为<strong>基于物品的协同过滤</strong>（item-based collaborative filtering）。在拥有大量数据集的情况下，基于物品的协同过滤能够得出更好的结论，而且它允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们所要的结果。</p>

<p>基于物品的协同过滤总体思路就是为每件物品预先计算好最为相近的其他物品。然后，当我们想为某位用户提供推荐的时候，就可以查看他曾经评过分的物品，并从中选出排名靠前者，再构造一个加权列表，其中包含了与这些选中物品最相近的其他物品。此处最显著的区别在于，尽管第一步要求我们检查所有的数据，但是物品间的比较不会像用户间比较那么频繁变化。</p>

<h3 id="toc_11">构造物品比较数据集</h3>

<p>为了对物品进行比较，我们要做的第一件事就是编写一个函数，构造一个包含相近物品的完整数据集。构建完数据集之后，我们就可以在需要的时候重复使用它。</p>

<p>将下面代码添加到 <code>recommendations.py</code> 中：</p>

<pre><code class="language-python">def calculateSimilarItems(prefs, n=10):
    # 建立字典，以给出与这些物品最为相近的其他物品
    result = {}
    
    # 以物品为中心最偏好矩阵进行倒置处理
    itemPrefs = transformPrefs(prefs)
    c = 0
    for item in itemPrefs:
        # 针对大数据集更新状态变量
        c += 1
        if c % 100 == 0:
            print &quot;%d / %d&quot; % (c, len(itemPrefs))
        scores = tomMatchs(itemPrefs, item, n=n, similarity=sim_pearson)
        result[item] = scores
    return result
</code></pre>

<p>该函数首先利用了此前定义过得 <code>transformPrefs</code> 函数，对反映评价的字典进行倒置处理，从而得到一个有关物品及其用户评价情况的列表，然后程序又循环遍历每项物品，并将转换了的字典传入 <code>tomMatches</code> 函数中，求得最为相近的物品及其相似度评价值，最后，它建立并返回了一个包含物品及其最相近物品列表的字典。</p>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; itemsim = recommendations.calculateSimilarItems(prefs)
100 / 8963
200 / 8963
300 / 8963
400 / 8963
500 / 8963
600 / 8963
700 / 8963
800 / 8963
900 / 8963
1000 / 8963
1100 / 8963
1200 / 8963
1300 / 8963
1400 / 8963
1500 / 8963
1600 / 8963
1700 / 8963
1800 / 8963
1900 / 8963
...
</code></pre>

<p>首次运行需要等待一段时间进行计算。</p>

<p>只有频繁执行该函数，才能令物品的相似度不至于过期。通常我们需要在用户基数和评分数量不是很大的时候执行这一函数，但是随着用户数量的不断增长，物品间的相似度评价通常会变得越来越稳定。</p>

<h3 id="toc_12">获得推荐</h3>

<p>现在，我们可以利用反映物品相似度的字典来给出推荐了，我们可以去到用户评价过得所有物品，并找出其相近的物品，根据相似度对其进行加权。</p>

<p>下表给出了利用基于物品的方法寻找推荐的过程，所用到的数据可以在上面<strong>推荐物品</strong>一节中找到。</p>

<p>为 Toby 提供基于物品的推荐：</p>

<table>
<thead>
<tr>
<th>影片</th>
<th>评分</th>
<th>Night</th>
<th>R.xNight</th>
<th>Lady</th>
<th>R.xLady</th>
<th>Luck</th>
<th>R.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Snakes</td>
<td>4.5</td>
<td>0.182</td>
<td>0.818</td>
<td>0.222</td>
<td>0.999</td>
<td>0.105</td>
<td>0.474</td>
</tr>
<tr>
<td>Superman</td>
<td>4.0</td>
<td>0.103</td>
<td>0.412</td>
<td>0.091</td>
<td>0.363</td>
<td>0.065</td>
<td>0.258</td>
</tr>
<tr>
<td>Dupree</td>
<td>1.0</td>
<td>0.148</td>
<td>0.148</td>
<td>0.4</td>
<td>0.4</td>
<td>0.182</td>
<td>0.182</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>0.433</td>
<td>1.378</td>
<td>0.713</td>
<td>1.762</td>
<td>0.352</td>
<td>0.914</td>
</tr>
<tr>
<td>归一化结果</td>
<td></td>
<td></td>
<td>3.183</td>
<td></td>
<td>2.473</td>
<td></td>
<td>2.598</td>
</tr>
</tbody>
</table>

<p>此处每一行都列出了一部我们曾经观看过的影片，以及对该片的个人评价。对于每一部我们还未曾看过的影片，相应有一列会指出它与已观看影片的相似程度。以 R.x 打头的列给出了我们队影片的评价值乘以相似度之后的结果。</p>

<p>总计一行给出了每部影片相似度评价值的总和以及 R.x 列的总和，为了预测我们对每一部影片的评分情况，只要将 R.x 列的总计值除以相似度一列的总计值即可。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def getRecommendedItems(prefs, itemMatch, user):
    userRatings = prefs[user]
    scores = {}
    totlaSim = {}
    
    # 循环遍历由当前用户评分的物品
    for (item, rating) in userRatings.items():
        
        # 循环遍历与当前物品相近的物品
        for (similarity, item2) in itemMatch[item]:
        
            # 如果该用户已经对当前物品做过评价，则将其忽略
            if item2 in userRatings:
                continue
            
            # 评价值与相似度加权之和
            scores.setdefault(item2, 0)
            scores[item2] += similarity * rating
            
            # 全部相似度之和
            totalSim.setdefault(item2, 0)
            totalSim[item2] += similarity
            
    # 将每个合计值除以加权和，求出平均值
    rankings = [(score / totalSim[item], item) for item, score in scores.items()]
    
    # 按最高值到最低值的顺序，返回评分结果
    rankings.sort(reverse=True)
    return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; recommendations.getRecommendedItems(prefs, itemsim, &#39;20&#39;)[:10]
[(5.0, &#39;Zoot Suit (1981)&#39;),
 (5.0, &#39;Zoolander (2001)&#39;),
 (5.0, &#39;Zack and Miri Make a Porno (2008)&#39;),
 (5.0, &quot;You&#39;ve Got Mail (1998)&quot;),
 (5.0, &#39;X-Men: The Last Stand (2006)&#39;),
 (5.0, &#39;X-Men: Apocalypse (2016)&#39;),
 (5.0, &#39;X-Men (2000)&#39;),
 (5.0, &quot;Von Ryan&#39;s Express (1965)&quot;),
 (4.75, &#39;Willow (1988)&#39;),
 (4.75, &quot;White Men Can&#39;t Jump (1992)&quot;)]
</code></pre>

<h2 id="toc_13">基于用户进行过滤还是基于物品进行过滤</h2>

<p>在数据集大小上，基于物品进行过滤的方式要比基于用户进行过滤更快；在数据的稀疏程度上，稀疏的数据集使用基于物品的过滤方法更优，而对于秘密集的数据集而言，两者的效果几乎一样。</p>

<p>基于用户的过滤方法更加易于实现，而且无需额外步骤，因此它通常更适用于规模较小的变化非常频繁的数据集。在一些应用中，告诉用户还有哪些人与自己有着相近偏好是有一定价值的——也许对于一个购物网站而言，我们并不想这么做，但是对于一个音乐分享类或者电影评分类网站而言，这种潜在的需求却是存在的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 51 Review]]></title>
    <link href="http://forrestchang.com/14824103542982.html"/>
    <updated>2016-12-22T20:39:14+08:00</updated>
    <id>http://forrestchang.com/14824103542982.html</id>
    <content type="html">
<![CDATA[<p>看了一下日历，上一周是 2016 年的倒数第二周了（写这篇文章的时候已经是 52 周了），换了新博客之后就一直没有再写过 Week Review，这其中虽然有一些外部的因素，但大抵上还是不想写。</p>

<p>上周学校组织来中软做课程设计，所以这些天一直待在中软的培训中心里，课程设计的题目是一个点餐的 Web 应用，用 Java 开发，因为并不打算从事 Java，所以也并没有怎么听，大部分时间都是在自己看书和写自己的 Project。不过要吐槽一下这边的环境，宿舍除了床什么也没有，所以晚上回去什么都干不了，只能坐在床上看看电影，最不能忍的是网都没有……学校送来培训中心的这种做法我是很不认同的，好好的大学为什么要搞成职业教育呢？</p>

<p>最近找到了大连的一家做 Python Web 的 start up，联系了一下准备过去面试，不过软件园离学校太远了，估计面过了也不会去吧。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 46 Review]]></title>
    <link href="http://forrestchang.com/14824081615573.html"/>
    <updated>2016-12-22T20:02:41+08:00</updated>
    <id>http://forrestchang.com/14824081615573.html</id>
    <content type="html">
<![CDATA[<p>编程学习方面，不完全看完了《利用 Python 进行数据分析》，感觉光看没有进行练习的话很难一次记住那么多用法，所以这本书最好还是最 NumPy、Pandas 这几个库用过一段时间之后再看。之后开始看《集体智慧编程》，目前才看了两章，内容写得还是挺好的，不过很多代码不是很规范（比如命名、缩进什么的），还有就是可能书已经比较老了，很多例子中使用的 API 已经挂掉了，所以不得不自己找数据集下来测试。不知道别人看书是怎样的，反正我看书不把书中每个例子测试一下就感觉书好像没看过，所以看书的速度还是挺慢的，昨天和今天花了两天的时间把第2章的东西总结了一下，写了篇博客。</p>

<p>朋友说我现在才开始学习机器学习并且想要以此为以后的职业简直在玩火（并且还不打算读研究生的情况下），说得也是，毕竟现在已经大三了，按照道理，应该刷刷题准备下学期的实习面试的。不过既然跳进这个火坑里了，就不能半途而废，至少先学习几个月看看情况再变更计划。如果实在不行，到时候再去做 Web 开发还是可以的。</p>

<p>前几天在登录 iPad 上的 Evernote 的时候，突然提示我登录的设备超过了两台，需要开通会员（之前开通过一年的会员，后来没有续费），总觉得为了这个再开通会员有点不值得，并且之前 Evernote 在 Mac 上使用就有很多诟病，所以打算换 OneNote 了。更新了一下 Mac 上 OneNote，发现竟然支持手写了，果断用用用。不过 OneNote 最开始的字体问题到现在还没有解决……</p>

<p>下周五就可以玩上 Pokemon Moon 了，激动不已，虽然破解党们早已二周目通关……</p>

<p>另外，发现番茄工作法挺好用的，现在也没有什么课了，每天就直接到图书馆里来，打开番茄钟，然后无脑干活就好了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 45 Review]]></title>
    <link href="http://forrestchang.com/14824080993859.html"/>
    <updated>2016-12-22T20:01:39+08:00</updated>
    <id>http://forrestchang.com/14824080993859.html</id>
    <content type="html">
<![CDATA[<p>已经第 45 周了啊，再过 10 周 2016 年就要过去了。今天大连下起了雪，似乎冬天就这么不知不觉得来了，记得上一次下大雪的时候去了一次海边，可惜 Photos 在一次事故中数据全部丢失了。作为一个南方人当初决定来北方的时候其实是对雪有一种很强烈的期待的，不过来了大连之后发现其实这里也不怎么下雪，偶尔下一次的雪也不是很大，这在一定程度上有点令人失望。</p>

<p>上周在读《挪威的森林》这本书，第一次读的时候大概是在初中的时候，当时没看懂里面写的是什么，纯属当做一本小黄书来读的。这次读的时候依旧有好多东西没明白。有一天听着 Thirteen Senses 的专辑猛地读到了 50%，感觉特别压抑，说不出来的压抑，所以就暂时放下了，顺便把翻拍的电影看了一遍，说实话，电影拍得不是很好，剧情的跳跃度有些大了，让没读过小说的人看得莫名其妙。</p>

<p>学习方面感觉上周特别颓废，什么事情都不相干，每天就窝在宿舍里，果然宿舍是一个让人堕落的地方，甚至连门都不想出去了，吃饭全部叫外卖。还好今天周一强迫自己来了图书馆，希望能做些东西吧。</p>

<p>这学期的课程基本结束了，免修了两门课，除了上机可能会去一下，其他时间都是空余的了，有大块的时间可以用来做自己想要做额事情了。</p>

<p>看了一眼窗外，雪似乎已经停了，耳机里放着坂本龙一的「A Flower Is Not A Flower」。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 44 Review]]></title>
    <link href="http://forrestchang.com/14824080414983.html"/>
    <updated>2016-12-22T20:00:41+08:00</updated>
    <id>http://forrestchang.com/14824080414983.html</id>
    <content type="html">
<![CDATA[<ul>
<li><strong>Coding</strong> - 本周主要在看《利用 Python 进行数据分析》，大概看了有一半的样子，下周应该能够结束掉。接下来的打算可能是先不看书，而是把<a href="https://www.quora.com/What-should-I-learn-in-data-science-in-100-hours">What should I learn in data science in 100 hours?</a>这个问题下面的回答内容实践一遍。</li>
<li><strong>Japanese</strong> - 日语已经落下好久了，大概还有1个月的时间考试，虽然只是报了一个三级试试水，但是不去考试总感觉白费报名费了，当初以为交了钱就会好好学，然而想多了。另外，日语现在并不是刚需的语言，之前决定学习是为了玩游戏，现在基本想玩的游戏都出了中文，《怪物猎人》玩了几个小时，发现不适合我这种手残。所以到底要不要继续学习日语还有待商榷……</li>
<li><strong>English</strong> - 英语自从到了大学以来就没有刻意地学过，除了准备托福的那段时间背了一些单词，然后其他都是直接用，导致了现在听说读写水平参差不齐，听力和阅读还算可以（至少能听懂和读懂技术相关的内容），口语基本就是没有说过，写作也没怎么练过，写一些基本的句子也要查语法（靠语感来写作结果就是一堆语法错……）。相比较日语来说，英语还算一个刚需的技能，尤其是写作和口语部分，还需要加强训练。接下来的一段时间内也会把英语学习提到日程上来，暂时的计划还没有想好，先加到 TODO 中。</li>
<li><strong>Reading</strong> - 发现这学期都没有读过几本书，上学期还能保持基本每周都读一本书，现在 Kindle 都吃灰了。下周先把《挪威的森林》这本书看完吧……</li>
<li><strong>Game</strong> - 等《精灵宝可梦 日月》发售，还有20天的样子，没有预定，直接买现货或者买下载版吧。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 Python 科学计算环境]]></title>
    <link href="http://forrestchang.com/14824083276745.html"/>
    <updated>2016-12-22T20:05:27+08:00</updated>
    <id>http://forrestchang.com/14824083276745.html</id>
    <content type="html">
<![CDATA[<p>最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。</p>

<h2 id="toc_0">安装虚拟环境</h2>

<p>不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在<a href="http://forrestchang.github.io/2016/07/17/virtualenv-notes/">virtualenv 相关笔记</a>这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用<code>alias</code>），这样就避免每次一打开就输入一长串命令了。</p>

<p>因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。</p>

<p>然后使用以下命令一键安装所需要的库：</p>

<pre><code class="language-shell">sudo pip install numpy pandas matplotlib jupyter scikit-learn
</code></pre>

<p>安装不上的请检查是不是需要翻墙。</p>

<h2 id="toc_1">IPython</h2>

<p>熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。</p>

<h3 id="toc_2">开启 IPython Notebook</h3>

<p>使用以下命令来打开 IPython Notebook：</p>

<pre><code class="language-shell">(ENV2.7)$ jupyter notebook
</code></pre>

<p>这样 server 就启动了，浏览器会自动打开一个目录树。</p>

<p>Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。</p>

<p>然后我们新建一个 IPython Notebook 用作演示：</p>

<p><img src="media/14824083276745/14776647413275.jpg" alt="14776647413275"/></p>

<p><code>In [1]</code> 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 <code>matplotlib</code> 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。</p>

<h3 id="toc_3">内省</h3>

<p>在变量的前面或后面加上一个 <code>?</code> 就可以将有关该对象的一些通用信息显示出来。</p>

<p><img src="media/14824083276745/14776649884990.jpg" alt="14776649884990"/></p>

<p>基本上什么都能看。</p>

<h3 id="toc_4"><code>%run</code> 命令</h3>

<p>使用 <code>%run</code> 可以运行本地的 Python 脚本，并可以在 IPython 中访问脚本中定义的所有变量。</p>

<p>如果想要脚本能够访问 IPython 中的命名空间，可以使用 <code>%run -i</code> 命令。</p>

<h3 id="toc_5">测试代码的执行时间</h3>

<p>使用 <code>%time</code> 和 <code>%timeit</code> 可以用来测试代码的执行时间。</p>

<p><img src="media/14824083276745/14776653395450.jpg" alt="14776653395450"/></p>

<h2 id="toc_6">Example</h2>

<p>下面使用一个具体的例子来演示 IPython Notebook 的使用。</p>

<p>使用到的数据可以在<a href="https://www.ssa.gov/oact/babynames/limits.html">Beyond the Top 1000 Names</a>下载到，这是一份包含1880-2015年每年出生婴儿姓名出现次数的数据表。</p>

<p>由于该数据按年份被分割成了好多文件，所以第一步我们需要把所有数据组装到一个 DataFrame 中去。</p>

<p><img src="media/14824083276745/14776659007521.jpg" alt="14776659007521"/></p>

<p>不知道这些 Python 代码没关系，因为这里只是用来演示 IPython Notebook。</p>

<p>然后我们按照性别和年度统计总出生数：</p>

<p><img src="media/14824083276745/14776660937109.jpg" alt="14776660937109"/></p>

<p>然后绘制出表格：</p>

<p><img src="media/14824083276745/14776661445090.jpg" alt="14776661445090"/></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 42-43 Review]]></title>
    <link href="http://forrestchang.com/14824079755630.html"/>
    <updated>2016-12-22T19:59:35+08:00</updated>
    <id>http://forrestchang.com/14824079755630.html</id>
    <content type="html">
<![CDATA[<p>连续两周没写周总结了，41周的周总结因为涉及到一些私事所以还是删掉了（当然感兴趣的还是可以在我的 repo 里面找到之前的 commit）。</p>

<p>过去两周还是发生了很多事情的，一件一件来说吧。</p>

<p>10.15-10.17 去上海参加了 HACKxFDU，这也是第一次参加 Hackathon，最后抱了大腿队友水到了一个微软的万物互联奖，不过奖品就两套物联网套件，根本不够四个人分(╯°□°）╯。在上海大概玩了一个礼拜，去了趟迪士尼（人多，体验差，项目无聊）就回学校了。然后上一周基本上没做什么事情，一是要准备大创项目的中期检查答辩，二是要复习软件工程的考试。</p>

<p>最近做出比较重要的一个决定就是确定了以后将要从业的方向，以前基本上都是按照兴趣来学，什么都做过一些，但都不是很深入，也没有想好以后工作想要干嘛。最近不知道怎么突然对数据挖掘和机器学习产生兴趣了，正好之前做的一个大创项目也是和这个有关的（虽然项目内容都是在划水），所以还算对这方面有点经验。</p>

<p>但是要解决的问题还是有很多的，比如说如何找到工作的问题，搜索了一下，机器学习/数据挖掘的岗位都需要有研究生学历，作为一个辣鸡学校的本科生，能不能找到工作就是一个问题。跟一个朋友说了一下想法，他说我在玩火……当然，实际上这方面倒不是太担心，如果有普通研究生能力的话找到一个工作还是不难的。</p>

<p>另外一个就是需要系统得学习这一套东西了，包括微积分、线性代数、概率论、统计学、机器学习，大部分内容是数学，现在有点后悔大一大二的时候没有好好学数学了，高数那些课基本就是划水过去的，欠下来的债还要还的。</p>

<p>现在基本的计划就是：</p>

<ol>
<li>看《利用 Python 进行数据分析》，把 Python 的几个科学计算库用熟练；</li>
<li>复习一下数学的知识，看《程序员的数学》系列的三本书，有基础的话应该挺快就能看完；</li>
<li>看李航的《统计学习方法》；</li>
<li>看《集体智慧编程》；</li>
<li>看周志华的《机器学习》；</li>
</ol>

<p>上面就是初步的入门计划，应该看完了对数据挖掘/机器学习有一个基本的了解了，可以顺便去 Kaggle 上打打比赛，虽然不一定能够能拿到好名次，积累一些经验总是好的。另外 Ng 的课和台大的《机器学习基石》也可以看一下。</p>

<p>其他一些资源：</p>

<ul>
<li><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers">Top-down learning path: Machine Learning for Software Engineers</a></li>
<li><a href="https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009">机器学习工程师（中/英）</a></li>
<li><a href="https://cn.udacity.com/course/data-analyst-nanodegree--nd002">数据分析师（中/英）</a></li>
</ul>

<p>这周和下周的计划就是把《利用 Python 进行数据分析》这本书看完。</p>

<p>ps：买了《文明6》，感觉时间还是挺紧的(╯▽╰)</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 40 Review]]></title>
    <link href="http://forrestchang.com/14824078620114.html"/>
    <updated>2016-12-22T19:57:42+08:00</updated>
    <id>http://forrestchang.com/14824078620114.html</id>
    <content type="html">
<![CDATA[<p>这周恰逢国庆假期，休息了两天（感觉今天貌似也在休息），明天学校断电断网（大农村条件艰苦），所以应该要出去一天，暂时的行程还没有安排。</p>

<h2 id="toc_0">编程</h2>

<h3 id="toc_1">总结</h3>

<p>首先收到了 <a href="http://fdu.hackx.org/#/">HACKxFDU</a> 的通过邮件，所以 14 号会去上海打一波酱油，以目前的水平如果不抱大腿感觉完全没有拿奖的可能性。主要的目的应该不是去参赛，可能会去找找下学期实习的目标，顺便认识一些大牛(≧▽≦)/</p>

<p>上周说要看完《Flask Web Development》，但是实际上并没有看完，大概看了一半的样子，期间还看了一些 Flask 的源码，打算边看书边看源码，然后之后再重新造一遍轮子。</p>

<h3 id="toc_2">计划</h3>

<p>之前就一直觉得自己的 Python 水平好像一直止步不前（传说中的半吊子水平），要做什么东西都是先 Google 一下用什么库，有些标准库中的内容也很不熟悉。昨天被学长问道最近在学什么，我说在看 Flask，然后就被鄙视了，然后通过对话才意识到 Library Reference 还没有完整的刷过，Python 的基础还是比较薄弱的。现在是个人就会 Python，不过刷过 Library Reference 的人应该还是不多的。</p>

<p>所以接下去的计划应该是：</p>

<ol>
<li>继续看 Flask（被鄙视也要看啊，开了头不能半途而废……），把源码看懂然后自己山寨一个，尝试着写一些基于 Flask 的 Project；</li>
<li>刷 Python Library Reference，用 ipython notebook 来做笔记，先刷一遍，不会的东西先跳过；</li>
<li>刷一下算法，这个是为了下学期的面试准备的，CLRS 没有看完，但是感觉想要看完会花掉不少的时间，看不看到时候再说，先把 LeetCode 刷一遍，然后《编程之美》、《编程珠玑》、《剑指 offer》这几本书刷一遍。</li>
</ol>

<p>这学期估计做完上面的事情时间就用得差不多了，下学期开始的时候就要为参加 GSoC 做一些准备了。</p>

<p>下周要做的事情：</p>

<ol>
<li>继续刷《Flask Web Development》，争取看完</li>
<li>看完 Python Library Reference 2、3、4节</li>
</ol>

<h2 id="toc_3">日语</h2>

<h3 id="toc_4">总结</h3>

<p>这周貌似完全没有学习日语！所以上周列的计划也没有完成，尴尬！时间分配上面还是有一点问题了，每天有计划今天计算机的东西要看哪些，但是日语的东西貌似一点也没有计划，想到了就看一点，所以没有想到的时候就完全不看了-_-|||</p>

<h3 id="toc_5">计划</h3>

<p>现在有点后悔抱名 N3 的考试了，以来 N3 没什么卵用，而来貌似自己好像并没有太多时间学习日语，还不如好好学习一下然后直接考 N2 或者 N1，但是如果不去考试的话就浪费了 350 大洋！</p>

<p>五十音基本上是会了，所以还是直接看《大家的日语》这本书，一天学习一课的样子，学习到第 5 课。</p>

<h2 id="toc_6">游戏</h2>

<p>最近发售的大作有点多啊，首先是 PC 上的《文明6》，然后 11 月份还有《精灵宝可梦 太阳·月亮》，其实主要是想玩日月……</p>

<h3 id="toc_7">Pokemon ORAS</h3>

<p>这周好像 OR 也没有玩多久，主要就是战斗宅邸推塔，今天超级单打打到 45 层失误跪了，目前的队伍还不是很稳，还要重新组一个队伍。另一方面打了几把排位，语言的关系对有些技能不是很熟悉，所以吃了好几次亏，而且没玩过 xy 导致 gen6 的精灵基本不认识。</p>

<p>入了对战坑之后发现这游戏根本不是小孩子玩的，虽说是「子供向」的游戏，但是对战方面实在是太硬核了，要了解的东西太多，玩了 70h+ 几乎才了解一些皮毛。不过日月出来了之后应该会好些，不会总是看到技能就要查图鉴是干嘛的了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 39 Review]]></title>
    <link href="http://forrestchang.com/14824077552377.html"/>
    <updated>2016-12-22T19:55:55+08:00</updated>
    <id>http://forrestchang.com/14824077552377.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">编程</h2>

<p>总的来说，好像这一周并没有做出什么东西来。本来是在看《Web Scraping with Python》这本书的，可以看到后面发现错误挺多的，都有一些最基本的语法错误，所以索性就直接不看了。然后知乎专栏的爬虫也一直没有开始写。</p>

<p>从前几周就开始使用 VS Code 了，比想象中的好用很多，上一次使用还是刚出的时候，很多东西都不完善，现在 1.0 版本有了很大的改进，作为主力编辑器应该是没有什么问题了。Atom 的启动速度还是那么慢，什么时候改进一些什么时候再说吧。Emacs 已经好久没有用了，应该没有什么特殊情况不会去用了吧，写 Lisp 和 Haskell VS Code 或许也能够胜任。</p>

<p>最近最烦心的一件事情就是不知道以后要从事什么方向的程序员了。目前自己的技术栈并不是很丰富，杂七杂八的东西研究了很多，赚钱的技能没学多少……所以还是有必要挑一个搬砖的技能好好磨练一下了。目前初步的计划是 Python Web 开发，然后顺带把 C 语言再看看然后去读 Python 的源码，再看一些经典的书（UNIX 系列）。</p>

<h3 id="toc_1">下周的计划</h3>

<p>把《Flask Web Development: Developing Web Applications with Python》这本书看完，然后把书中的博客例子做出来。</p>

<p>顺便写代码累了的时候可以刷刷《程序员修炼之道》这本书，以前看过其中的一部分，还是比较有意思的。</p>

<h2 id="toc_2">日语</h2>

<p>12月份就要考试了，然而我还没怎么开始学习。大概在 YouTube 上看了几节五十音的视频，其实五十音之前也都学过，平假名基本上还是熟悉的，就是片假名记不住-_-|||</p>

<h3 id="toc_3">下周的计划</h3>

<p>熟练掌握五十音，包括平假名和片假名的书写、发音。先把 YouTube 上那一个系列的视频看完吧，然后直接拿单词卡片来背，Anki 中也有单词本可以用来复习。</p>

<h2 id="toc_4">游戏</h2>

<p>这周没怎么玩游戏，守望先锋已经一周多没有玩了。</p>

<p>平时的时候玩 「Pokemon Omega Ruby」比较多，也就是孵孵蛋，打打对战塔，刚入对战坑，好多东西还不懂，还需要学习一个。</p>

<p>开始入门狼人杀，这周的几次聚会玩狼人杀很嗨，在某宝上买了一套卡牌，准备研究研究。</p>

<h2 id="toc_5">阅读</h2>

<p>看了一点《胡适留学日记》，拖到现在还没有看完，Kindle 好像来学校之后就有点吃灰了。</p>

<h3 id="toc_6">下周的计划</h3>

<p>看完《胡适留学日记》。</p>

<h2 id="toc_7">电影</h2>

<p>这周看了三部韩国的电影，分别是《隧道》、《釜山行》、《恐怖直播》，发现韩国的电影好好看！韩国的电影感觉黑色幽默和讽刺多一些，日本的电影中二气息比较多一些，国产的电影嘛……</p>

<p>相比较最近比较火的《釜山行》，个人还是感觉《隧道》比较好看一些。亚洲地区的丧尸片估计《釜山行》应该是最佳了，但是和欧美的一些丧尸片比起来，还是有差距的，其中的一些套路也都是别人玩过了的。《隧道》这部电影让我感觉和《活埋》很像，但是一个生还了，一个 gg 了……</p>

<h2 id="toc_8">杂项</h2>

<p>这周好像聚会比较多(≧▽≦)，已经吃了好几顿饭+去了一次 KTV，生活过得比较颓废。</p>

<p>是时候应该沉迷学习了(╯﹏╰）</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016/08/08 阅读笔记]]></title>
    <link href="http://forrestchang.com/14706584948925.html"/>
    <updated>2016-08-08T20:14:54+08:00</updated>
    <id>http://forrestchang.com/14706584948925.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0"><a href="https://www.quora.com/How-can-I-study-for-10+-hours-a-day-without-getting-depressed-and-how-can-I-make-myself-get-used-to-it">Quora: How can I study for 10+ hours a day without getting depressed and how can I make myself get used it?</a></h2>

<p><em>Such a stupid question.</em></p>

<ol>
<li>Don&#39;t study more than 7.5 hours a day. You can&#39;t learn when you are exhausted.</li>
<li>Take a day off per week. Do something you like on that day.</li>
<li>Make a plan.What knowledge is most critical in each of the subjects? First, concentrate only on that.</li>
<li>Study from low to high resolution.</li>
<li>Nap. A lot.</li>
<li>Study one topic for 2.5 hours. Then switch to another. Continue.</li>
<li>Read. Then put down the book. Then summarize what you have read. Don&#39;t look at what you were reading when you summarize.</li>
</ol>

<hr/>

<ol>
<li>Avoid time specific plans unless you&#39;re a monk or living in an extremely isolated environment.</li>
<li>Create a simple mechanism for notes and plans. You don&#39;t need any complex thing. The aim here is to work efficiently so these tools should be tools, not the whole story.</li>
<li>Create tasks as atomic as possible. Task should not be long. Best practice is that the task can be done after 1-2 hours of efficient work. If the task is big, you divide it into subtasks. In other words, avoid context switching as much as possible.</li>
<li>Get rid of all external distraction.</li>
<li>Use Pomodoro Technique.</li>
<li>If you have a long-run work and you can&#39;t complete it at the end of the day, take a note for tomorrow&#39;s yourself in order to remember the basic of teh task. And tomorrow, you start the day by glancing over the connected tasks.</li>
</ol>

<hr/>

<p>If studying makes you depressed, it&#39;s because your mind considers it a chore that you&#39;re forced to do. Doing any such chore for long periods of time is awful and depressing. On the other hand, doing somehting you love is fun, even when it&#39;s physically or mentally exhausting. So what you need to do is make the experience more valuable and enjoyable.</p>

<ol>
<li>Knowing WHY you&#39;re learning something.</li>
<li>Really understanding what you&#39;re learning.</li>
</ol>

<hr/>

<ol>
<li>Learn and practise proven efficient and effective study tools like SQ5R and Cornell Notes.

<ul>
<li>SQ5R reading/satudying strategy: [Survey, Question, Read, Record, Recite, Review, Reflect], </li>
</ul></li>
</ol>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualenv 相关笔记]]></title>
    <link href="http://forrestchang.com/14824097975366.html"/>
    <updated>2016-12-22T20:29:57+08:00</updated>
    <id>http://forrestchang.com/14824097975366.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">安装</h2>

<p>直接使用 pip 来进行安装：</p>

<pre><code>$ sudo pip install virtualenv
</code></pre>

<h2 id="toc_1">用途</h2>

<p>主要用来创建隔离的 Python 开发环境，比如说一个项目需要用到 2.7 的库，另一个项目需要用到 3.0 的库，我们就可以使用  virtualenv 来分别给这两个项目创建虚拟的 Python 环境，这样可以有效的避免冲突。</p>

<p>virtualenv 会创建一个拥有独立安装目录的 Python 环境，该隔离环境不会与其他 virtualenv 环境共享模块（可以选择是否访问全局安装目录）。</p>

<h2 id="toc_2">使用</h2>

<h3 id="toc_3">创建虚拟环境</h3>

<p>最基本的使用：</p>

<pre><code>$ virtualenv ENV
</code></pre>

<p>其中 <code>ENV</code> 是用来存放虚拟环境的目录。</p>

<pre><code>$tree -L 1 ENV
ENV
├── bin
├── include
├── lib
└── pip-selfcheck.json
</code></pre>

<p>其中 <code>lib</code> 和 <code>include</code> 目录是用来存放新的虚拟 Python 环境的依赖库，Package 被安装到 <code>lib/pythonX.X/site-packages/</code> 中，<code>bin</code> 目录中是新的 Python 解释器。<code>pip</code> 和 <code>setuptools</code> 默认被安装的。</p>

<h3 id="toc_4">active script</h3>

<p>进入虚拟环境：</p>

<pre><code>$ source ENV/bin/active
</code></pre>

<p>（如果 <code>source</code> 命令不存在可以使用 <code>.</code> 命令。）</p>

<p>退出虚拟环境：</p>

<pre><code>$ deactivate
</code></pre>

<h3 id="toc_5">Removing an Environment</h3>

<pre><code>(ENV)$ deactivate
$ rm -r /path/to/ENV
</code></pre>

<h3 id="toc_6"><code>--system-site-packages</code> 选项</h3>

<p>使用 <code>virtualenv --system-site-packages ENV</code> 将会继承全局 packages。并不是很常用的功能。</p>

<h3 id="toc_7">指定 Python 版本</h3>

<p>使用 <code>-p PYTHON_EXE</code> 选项在创建虚拟环境的时候制定 Python 版本。</p>

<p>Python 2.7:</p>

<pre><code>$ virtualenv -p /usr/bin/python2.7 ENV2.7
</code></pre>

<p>Python 3.5:</p>

<pre><code>$ virtualenv -p /usr/local/bin/python3.5 ENV3.5
</code></pre>

<h3 id="toc_8">生成可打包环境</h3>

<p>某些情况下，我们可能需要在别的地方使用这个已经配置好的虚拟环境，可以使用 <code>virtualenv --relocatable</code> 将 ENV 修改为可迁移的。</p>

<pre><code>(ENV)$ virutalenv --relocatable ./
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Tutorial Reading Notes]]></title>
    <link href="http://forrestchang.com/14824095038232.html"/>
    <updated>2016-12-22T20:25:03+08:00</updated>
    <id>http://forrestchang.com/14824095038232.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Data Structures</h2>

<h3 id="toc_1">More on Lists</h3>

<ul>
<li><code>list.append(x)</code>: Equivalent to <code>a[len(a):] = [x]</code></li>
<li><code>list.extend(L)</code>: Extend the list by appending all the items in the given list. Equivalent to <code>a[len(a):] = L</code></li>
<li><code>list.insert(i, x)</code>: The first argument is the index of the element before which to insert. <code>a.insert(len(a), x)</code> == <code>a.append(x)</code>.</li>
<li><code>list.remove(x)</code>: Remove the first item form the list whose value is x.</li>
<li><code>list.pop([i])</code>: Remove the item at the given position in the list, and return it. If no index is specified, <code>a.pop()</code> removes and returns the last item in the list.（parameters with square brackets are optional）</li>
<li><code>list.clear()</code>: Remove all item from the list. Equivalent to <code>del a[:]</code></li>
<li><code>list.index(x)</code>: Return the index in the list of the first item whose value is x.</li>
<li><code>list.count(x)</code>: Return the number of times x appears in the list.</li>
<li><code>list.sort(key=None, reverse=False)</code>: Sort the items of the list in place.</li>
<li><code>list.reverse()</code>: Reverse the elements of the list in place.</li>
<li><code>list.copy()</code>: Return a shallow copy of the list. Equivalent to <code>a[:]</code>.</li>
</ul>

<h4 id="toc_2">Using Lists as Stacks</h4>

<p>Use <code>append</code> and <code>pop</code>.</p>

<h4 id="toc_3">Using Lists as Queues</h4>

<p>Lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from beginning of a list is slow.</p>

<p>Better to use <code>collections.deque</code>.</p>

<h4 id="toc_4">List Comprehensions</h4>

<ul>
<li><code>x = [item for item in series]</code></li>
<li><code>x = [do_something(item) for item in series if expression]</code></li>
</ul>

<h4 id="toc_5">Nested List Comprehensions</h4>

<p>The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension.</p>

<p>Example: <code>[[row[i] for row in matrix] for i in range(4)]</code>.</p>

<h4 id="toc_6">The <code>del</code> statement</h4>

<p>Remove an item from a list given its index. (Do not return a value) It can also remove slices from a list.</p>

<p><code>del</code> can also be used to delete entire variables: <code>del a</code>.</p>

<h3 id="toc_7">Tuples and Sequences</h3>

<p>Tuples are <code>immutable</code>, and usually contain a heterogeneous sequence of elements that are accessed via unpacking or indexing. List are <code>mutable</code>, and their element are usually homogeneous and are accessed by iterating over the list.</p>

<ul>
<li>Empty tuples are constructed by and empty pair of parentheses: <code>empty = ()</code></li>
<li>A tuple with one item is constructed by following a value with a comma:     <code>sigleton = &#39;hello&#39;,</code></li>
</ul>

<p>The statement <code>t = 1, 2, &#39;hello&#39;</code> is an example of <code>tuple packing</code>: the values are packed together in a tuple. The reverse operation is also possible: <code>x, y, z = t</code>.</p>

<h3 id="toc_8">Sets</h3>

<p><code>{}</code> or <code>set()</code> function can be used to create sets. Note: to create an empty set you have to use <code>set()</code>, not <code>{}</code>; the latter creates an empty dictionary.</p>

<p>Example: </p>

<pre><code class="language-python">a = set(&#39;abracadabra&#39;)
b = set(&#39;alacazam&#39;)
</code></pre>

<ul>
<li><code>a - b</code>: letters in a but not in b</li>
<li><code>a | b</code>: letters in either a or b</li>
<li><code>a &amp; b</code>: letters in both a and b</li>
<li><code>a ^ b</code>: letters in a or b but not both</li>
</ul>

<p>Similaryly to list comprehensions, set comprehensions are also supported.</p>

<h3 id="toc_9">Dictionaries</h3>

<p>Dictionaries are indexed by keys, which can be any immutable type; strings and numbers can slways be keys. Tuples can be used as keys if they contain only one kind of item. You can&#39;t use use lists as keys, since lists can be modified in place using index assignments, slice assignments, or method like append() and extend().</p>

<p>It is best to think of a dictionary as an unordered set of <code>key: value</code> pairs.</p>

<ul>
<li><code>del</code> can delete a <code>key: value</code></li>
<li><code>list(d.keys())</code> on a dictionary returns a list of all the keys used in the dictionary, in arbitrary order (if you want it sorted, use <code>sortted(d.keys())</code> instead).</li>
<li>To check whether a single key is in the dictionary, use the <code>in</code> keyword. (<code>in</code> or <code>not in</code>)</li>
<li>Dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: <code>{x: x**2 for x in range(10)}</code></li>
<li>When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments: <code>dic(sape=1, guido=2, jack=3)</code> =&gt; <code>{&#39;sape&#39;: 1, &#39;jack&#39;: 3, &#39;guido&#39;: 2}</code></li>
</ul>

<h3 id="toc_10">Looping Techniques</h3>

<p>When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the items() method.</p>

<pre><code class="language-python">knights = {&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;}
for k, v in knights.items():
    print(k, v)
</code></pre>

<p>When looping through a sequence, the position index and correspoding value can be retrieved at the same time using the <code>enumerate()</code> function.</p>

<pre><code class="language-python">for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
    print(i, v)
</code></pre>

<p>To loop over two or more sequences at the same time, the entries can be paired with the <code>zip()</code> function.</p>

<pre><code class="language-python">numbers = [1, 2, 3]
names = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
for number, name in zip(numbers, names):
    print(&#39;Number: {0}, Name: {1}&#39;.format(number, name))
</code></pre>

<p>To loop over a sequence in sorted order, use the <code>sorted()</code> function which return a new sorted list while leaving the source unaltered. <code>for item in soted(list)</code></p>

<p>It is sometimes tempting to change a list while you are looping over it; however, it is often simple and safer to create a new list instead.</p>

<h3 id="toc_11">More on Conditions</h3>

<ul>
<li><code>in</code> and <code>not in</code>: check whether a value occurs (or not) in a sequence.</li>
<li><code>is</code> and <code>is not</code>: compare whether two objects are really the same object; this only matters for mutable objcts like lists.</li>
<li>Comparisons can be chained. <code>a &lt; b == c</code></li>
<li><code>and</code> and <code>or</code> are <code>short-circuit</code> operators</li>
</ul>

<h3 id="toc_12">Comparing Sequences and Other Types</h3>

<p>The comparison uses lexicographical ordering.</p>

<h2 id="toc_13">Modules</h2>

<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix <code>.py</code> appended. Within a module, the module&#39;s name (as a string) is available as the value of the global variable <code>__name__</code>.</p>

<h3 id="toc_14">More on Modules</h3>

<p>Note that in general the practice of importing <code>*</code> from a module is frowned upon, since it often causes poorly readable code. (It ok to use in interactive sessions.)</p>

<p>It&#39;s one module you want to test interactively, use <code>importlib.reload()</code>.</p>

<pre><code class="language-python">import importlib
importlib.reload(modulename)
</code></pre>

<h4 id="toc_15">Executing modules as scripts</h4>

<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    code
</code></pre>

<p>This is often used either to provide a convenient user interface to a module, or for testing purposes (running the module as a script executes a test suite).</p>

<h4 id="toc_16">The Module Search Path</h4>

<p>When a module named <em>spam</em> is imported, the interpreter first searches for a built-in module with that name. If not found, it then searches for a file named <code>spam.py</code> in a list of directories given by the variable <code>sys.path</code>, it is initialized from these locations:</p>

<ul>
<li>The directory containing the input script (or the current directory when no file is specified).</li>
<li><code>PYTHONPATH</code> (a list of directory names, with the same syntax as the shell variable <em>PATH</em>).</li>
<li>The installation-dependent default.</li>
</ul>

<p>After initialization, Python programs can modify <code>sys.path</code>. The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory.</p>

<h4 id="toc_17">&quot;Compiled&quot; Python files</h4>

<p>Python caches the compiled version of each module in the <code>__pycache__</code> directory. It generally contains the Python version number. This naming convention allows compiled modules from dirrerent release and different version of Python to coexist. (Example: <code>__pycache__/fib.python-27.pyc</code>)</p>

<p>Python check the modification date of the source against the compiled version to see if it&#39;s out of date and needs to be recompiled.</p>

<h3 id="toc_18">Standard Modules</h3>

<pre><code class="language-python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&#39;&gt;&gt;&gt; &#39;
&gt;&gt;&gt; sys.ps2
&#39;... &#39;
&gt;&gt;&gt; sys.ps1 = &#39;C&gt; &#39;
C&gt; print(&#39;Yuck!&#39;)
Yuck!
</code></pre>

<p>The variable <code>sys.path</code> is a list of strings that determines the interpreter&#39;s search path for modules. You can modify it using standard list operations.</p>

<h3 id="toc_19">The <code>dir()</code> Function</h3>

<p>The built-in function <code>dir()</code> is used to find out which names a module defines.</p>

<p>Without arguments, <code>dir()</code> lists the names you have defined currently.</p>

<p>It list all types of names: variable, modules, functions, etc.</p>

<h2 id="toc_20">Input and Output</h2>

<h3 id="toc_21">Methods of File Objects</h3>

<p>It is good practice to use the <code>with</code> keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exceptiohn is raissed on the way. It is also much shorter thatn writing equivalent <code>try-finally</code> blocks:</p>

<pre><code class="language-python">with open(&#39;workfile&#39;, &#39;r&#39;) as f:
    read_data = f.read()
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016/07/02 阅读笔记]]></title>
    <link href="http://forrestchang.com/14674443542637.html"/>
    <updated>2016-07-02T15:25:54+08:00</updated>
    <id>http://forrestchang.com/14674443542637.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0"><a href="https://m.signalvnoise.com/how-i-became-and-stayed-a-successful-programmer-48f209362f68#.davwu8c5x">How I became (and stayed) a successful programmer</a></h2>

<p>How do I take a new skill like programming, grow it, shape it, and tune it over time so I can achieve longevity in the industry?</p>

<h3 id="toc_1">1. I surround myself with programmers who are way better than me</h3>

<p>The best way to improve (at anything) is to learn from people better than you.</p>

<p>I remind myself to talk less and to listen more.</p>

<h3 id="toc_2">2. I occasionally leave my comfort zone</h3>

<p>Leaving comfort zone helps me think differently by challenging a bunch of established ideas I already have.</p>

<p>Maybe you don&#39;t want to do this constantly because it can be hard to get into a rhythm with your normal area of work. But in moderation it can really open your mind to new ways of thinking.</p>

<p>Find a programming task that takes you out of your comfort zone and make it your next project. Then watch it pay off in spades.</p>

<h3 id="toc_3">3. I value being independent</h3>

<p>What&#39;t most inportant is how you choose to find the answers to your questions.</p>

<p>This means I&#39;ll try to do most things myself first, and only when I really get stuck, I&#39;ll ask for help.</p>

<p>Benefits:</p>

<ul>
<li>You learn how to be resourceful.</li>
<li>You earn respect by being courteous of other people&#39;s time and work.</li>
<li>You start developing your creativity.</li>
</ul>

<h2 id="toc_4"><a href="https://medium.freecodecamp.com/please-dont-quit-every-expert-was-once-a-beginner-6d8f8933a338#.d0nbkocf7">Please don&#39;t quit -- every expert was once a beginner</a></h2>

<h3 id="toc_5">Great developments never come from within your comfort zone</h3>

<p>It&#39;s always hard to push yourself to the next level, because it requires greater effort than the usual. It requires more energy, which may tire you physically and mentally.But don&#39;t think about that. Think about the result. The achievement.</p>

<p>Every time you take a step toward expertise, no matter how small, it is still a step.</p>

<h3 id="toc_6">Learn in diffuse mode</h3>

<p>Since it may be hard to get a concept the first time you read about it, you can do something that will make it better for you and help you get it quickly.</p>

<p>Read the full text with total focus (first time, even if you don&#39;t understand), okay? Now, read it again. After the second time, google the concept and try to read about it in different articles. That will help you see it from different angles, which will help you better understand it.</p>

<p>Next time is to read the text a third time. Your understanding of the concept is much better now than it was the first time you read it, even though in all likelihood you&#39;re still early on in your quest to truly understand that concept.</p>

<p>This medhod is called <strong>Diffuse mode</strong>. You can apply this type of learning toward applies to videos and tutorials, as well.</p>

<p><strong>Every expert was once a beginner.</strong></p>

<blockquote>
<p>&quot;You never fail until you stop trying.&quot; - <strong>Albert Einstein</strong></p>
</blockquote>

<p>You should know that reaching a high level takes time.</p>

<blockquote>
<p>&quot;I&#39;m convinced that about half of what separates the successful Entrepreneurs from the non-successful ones is pure perseverance.&quot; - <strong>Steve Jobs</strong></p>
</blockquote>

<p>Some tips:</p>

<ul>
<li>Don&#39;t work alone.</li>
<li>Don&#39;t wait for inspiration. <strong>Discipline is reliable.</strong></li>
<li>Real work usually isn&#39;t fun.</li>
<li>Practice, practice, and practice.</li>
<li>Tutorials fish on your behalf, so you don&#39;t need to learn how to fish yourself. <strong>You need to read books.</strong></li>
<li>Always try to understand a new concept using different resources.</li>
<li>Don&#39;t just read. Build. Try, try, and keep trying.</li>
<li>Frustration, boredom, tiredness, exhaustion -- these are all normal. </li>
<li>Ask.</li>
</ul>

<blockquote>
<p>&quot;Long-term consistency trumps short-term intensity.&quot; - <strong>Bruce Lee</strong></p>
</blockquote>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 21 阅读笔记]]></title>
    <link href="http://forrestchang.com/14636395892916.html"/>
    <updated>2016-05-19T14:33:09+08:00</updated>
    <id>http://forrestchang.com/14636395892916.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0"><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></h2>

<blockquote>
<p>The great software developers, indeed, the best people in every field, are quite simply never on the market.j</p>

<p>The average great software developer will apply for, total,maybe, four jobs in their entire career.</p>

<p>—— <a href="http://www.joelonsoftware.com/articles/FindingGreatDevelopers.html">Joel Spolsky</a></p>

<ol>
<li>最好的人也许不投简历，就决定去哪里了。所以要在他们做决定之前找到他们。</li>
<li>比较差的会投很多次简历，找不到工作的时间约多，投的简历越多，给整个 pool 带来很多噪音，top 10% 的简历也许根本不算全部人的 top 10%。</li>
</ol>

<p>—— 邹欣</p>
</blockquote>

<p>Joel Spolsky 写了一本书，专门讲了公司招聘的心得和体会，<a href="http://www.amazon.com/Smart-Gets-Things-Done-Technical/dp/1590598385/">《Smart and Gets Things Done》</a>。</p>

<p>现在绝大多数应届生简历而言，也许最具信息量的部分不是「精通 xxx，熟悉 yyy，掌握 zzz」，不是「在 uuu 实习过」，也不是这个项目那个作业，反倒是越来越被认为不重要的一项：毕业学校。原因是简历上的其他条目的信息量太小了。</p>

<p>很多时候，是否好好看完一本好书，对一个人的提升往往能达到质的区别。就算不好好看完一本书，马马虎虎看完，只要书是真的函数，也肯定会有很大提高。</p>

<p>好书和坏书的差别，从本质上，就是学习效率和大方向的差别。读烂书浪费时间，但读好书却节省时间。</p>

<p>「书单计划」的优点：</p>

<ol>
<li>清晰、明确。完全可度量。</li>
<li>防伪：读没读过，随便一问便知。而正因为应聘者也知道这事不像实习经验可以忽悠，所以也不敢乱往简历上捅词。</li>
<li>不在乎是否「泄题」：书单是完全公开的，无所谓，本来就是要你去读的。</li>
<li>管你用心不用心读，只要读了，读完了，就有区别。（笔者注：根据经验，没有用心读完可能真的没有什么卵用）</li>
<li>不存在「怎么做」的障碍：所有人都知道怎么读书——一页一页读。</li>
<li>不需要招聘者投入精力：书单在此，就这么简单。</li>
<li>评估的负担很大程度上转移到了应聘者身上：是不是认真看完了，有没有心得体会。</li>
</ol>

<p>「书单计划」的背后是另一个悲剧的现实，如果不是因为这个现实，这个计划也完全没有必要，那就是，中国 IT 大学教育当中要求学的书，和企业真正需要你读的书相比，不是完全不够用，就是写得不够好，或者更悲剧的就是根本用不上，所以在这个大背景下出来的牛人都是自己淘书自己学的。</p>

<blockquote>
<p>第一份工作的月薪 = 大学四年买过的技术书籍价格的总和</p>

<p>—— 熊力</p>
</blockquote>

<p><strong>GitHub</strong></p>

<p>有经验的面试者只要稍稍扫两眼一个人的 GitHub 历史，跳出几个 check-in 历史看一看，便完全能够迅速判断这个人是否满足他的要求。不再需要费劲心机地去想题目，去观察，去揣测，去花费大量的时间的同时还只能采样到几个极为有限的点。</p>

<p>书单 + GitHub，就相当于一个两年左右的面试。</p>

<p>没有哪个行业像 IT 行业这样特殊：没有什么东西不能够（应该）在互联网上学到的。</p>

<hr/>

<p>一些书单</p>

<ol>
<li>《编码的奥秘》</li>
<li>《深入理解计算机系统》</li>
<li>《Windows 核心编程》</li>
<li>《程序员的自我修养》</li>
<li>《代码大全》</li>
<li>《程序员修炼之道》</li>
<li>《编程珠玑》</li>
<li>《编程之美》</li>
<li>《The C Programming Language》</li>
<li>《The C++ Programming Language》</li>
<li>《Programming: Principles and Practice Using C++》</li>
<li>《Accelerated C++》</li>
<li>《计算机程序的构造和解释》</li>
<li>《Clean Code》</li>
<li>《Implementation Patterns》</li>
<li>《Design Patterns》</li>
<li>《Agile Software Development, Principles, Patterns, and Practices》</li>
<li>《Refactoring》</li>
<li>《C++ 编程思想》</li>
<li>《Effective C++》</li>
<li>《深度探索 C++ 对象模型》</li>
<li>《C++ 语言的设计和演化》</li>
<li>《C 专家编程》</li>
<li>《C 陷阱与缺陷》</li>
<li>《C 语言接口与实现》</li>
<li>《Lua 程序设计》</li>
<li>《Linkers and Loaders》</li>
<li>《COM 本质论》</li>
<li>《深入理解 Windows 操作系统》</li>
<li>《Unix 编程艺术》</li>
<li>《代码优化：有效使用内存》</li>
<li>《深入理解 Linux 内核》</li>
<li>《TCP/IP 详解》</li>
<li>《软件随想录》</li>
<li>《黑客与画家》</li>
<li>《编程人生》</li>
<li>《人月神话》</li>
<li>《算法导论》</li>
<li>《快速软件开发——有效控制与完成进度计划》</li>
<li>《IT 项目管理那些事》</li>
<li>《最后期限》</li>
<li>《走出软件作坊》</li>
<li>《你的灯亮着吗》</li>
<li>《Algorithms》(by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani)</li>
<li>《Data Structures and Algorithms》</li>
<li>《The Design of the UNIX Operating System》</li>
<li>《Compilers》(龙书)</li>
<li>《Computer Architecture: A Quantitative Approach》</li>
<li>《Flow》</li>
<li>《Outliers》（Why hard work and luck are both important）</li>
</ol>

<h2 id="toc_1"><a href="http://mindhacks.cn/2008/09/17/learning-habits-part3/">一直以来伴随我的一些学习习惯（三）：阅读方法</a></h2>

<ol>
<li>乘着对一件事有热情的时候，一股脑把万事那个最难的阶段熬过去。</li>
<li>根据主题来查阅资料，而不是根据资料来查阅主题。按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完再看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。因为即便是经典的书，你也不能指望它对其中每一个主题的介绍都是尽善尽美的，有些书对某个主题（知识点）的介绍比较到位，有些书则对另一些知识点介绍得比较到位。而有时候一篇紧凑的 paper 比一本书上讲得还要好。我硬盘里面的书按照主题分类，每个主题下面都有一堆书，当我需要学习某个主题的知识时，我会把里面涉及这个主题的书都翻开来，索引到相关章节，然后挑讲得好的看。</li>
<li>好资料，坏资料。好资料的特点：从问题出发；重点介绍方法背后的理念，注重直观解释，而不是方法的技术细节；按照方法被发明的时间流程来介绍（先是遇到什么问题，然后怎样分析，推理，最后发现目前所使用的方法）。坏资料的特点是好资料的反面：上来就讲方法细节，仿佛某方法是从天上掉下来的。根本不讲为什么要用这个方法，人们最初是因为面对什么问题才想到这个方法的，其间又是怎样才想出这个方法的，方法背后的直观思想又是什么。</li>
<li>学习一个东西之前，首先在大脑中积累充分的「疑惑感」。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到借到之后的印象就越深刻。</li>
<li>有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读，二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的，那么1. 现象是什么？2. 解释是什么？3. 之城这个解释的理由是什么？ 4. 例子是什么。</li>
<li>为什么看不懂？1. 你看得不够使劲。对于这类情况，仔仔细细地再多读两遍，多试着去理解两遍，往往会恍然大悟。2. 其中涉及到了你不懂得概念，这是技术性的不理解，这种情况就需要 Cross Reference。如果一句话中用到了你不懂得概念，那就去查。奇怪的是很多人看不懂也不分析一下为什么不懂，就直接放弃了。正如解决问题一样，问题卡住解决不了了，第一时间要做的就是分析为什么解决不了，而不是直接求救。3. 作者讲述的顺序不对，你接着往下看，也许看到后面就明白前面的了。</li>
<li>如何搜寻到好书。1. 同作者的著作。2. Amazon 相关推荐和主题相关的书列。3. 一本好的著作（或一份好的资料——不管是书还是网页）在参考资料里面重点提到的其他著作。4. 有时对于一个主题，可以搜索到好心人总结的参考资源导引，那是最好不过的。</li>
</ol>

<h2 id="toc_2"><a href="http://matt.might.net/articles/what-cs-majors-should-know/">What every computer science major should know</a></h2>

<ul>
<li>What should every student know to get a good job?</li>
<li>Waht should every student know to maintain lifelong employment?</li>
<li>What should every student know to enter graduate school?</li>
<li>What should every student know to benefit society?</li>
</ul>

<p><strong>Portfolio versus resume</strong></p>

<p>Every computer science major should build a portfolio.</p>

<p>A portfolio could be as simple as a personal blog, with a post for each project or accomplishment. A better portfolio would include per-project pages, and publicly browsable code (hosted perhaps on github or Google code).</p>

<p>Contributions to open source shold be linked and documented.</p>

<p>A code portflolio allows employers to direcctly judge ablility. GPAs and resumes do not.</p>

<p><strong>Technical communication</strong></p>

<p>I would recommend that students master a presentation tool like PowerPoint or (my favorite) Keynote.</p>

<p>For producing beautiful mathematival documentation, \(LaTex\) has not equal. All written assignments in techical courses should be submitted in LaTex.</p>

<p><strong>An engineering core</strong></p>

<p><strong>The Unix philosophy</strong></p>

<p>The Unix philosophy is one that emphassizes linguistic abstraction and composition in order to effect computation.</p>

<p><strong>Systems administration</strong></p>

<p><strong>Programming Language</strong></p>

<p><strong>Discrete mathematics</strong></p>

<p><strong>Data structures and algorithms</strong></p>

<p><strong>Theory</strong></p>

<p><strong>Architecture</strong></p>

<p><strong>Operating System</strong></p>

<p><strong>Networking</strong></p>

<p><strong>Security</strong></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift学习笔记：控制流]]></title>
    <link href="http://forrestchang.com/14635617646524.html"/>
    <updated>2016-05-18T16:56:04+08:00</updated>
    <id>http://forrestchang.com/14635617646524.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Repeat-While</h2>

<p><code>repeat-while</code> 在 <code>while</code> 判断循环条件之前，先执行一次循环的代码块，和其他语言中的 <code>do-while</code> 是类似的。</p>

<pre><code class="language-swift">repeat {
    statements
} while condition
</code></pre>

<h2 id="toc_1">Switch</h2>

<p><code>switch</code> 语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用 <code>switch</code> 语句替换 <code>if</code> 语句。</p>

<p><code>switch</code> 语句必须是完备的，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值得情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在 <code>switch</code> 语句的最后面。</p>

<h3 id="toc_2">不存在隐式的贯穿（No Implicit Fallthrouth）</h3>

<p>和其他语言的 Switch 不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 <code>switch</code> 语句，而不会继续执行下一个 case 分支。所以，不需要再 case 分支中显式地使用 <code>break</code> 语句。</p>

<p>如果想要贯穿到特定的 case 分支中，请使用 <code>fallthrough</code> 语句。</p>

<h3 id="toc_3">区间匹配</h3>

<p>case 分支的模式也可以是一个值得区间。</p>

<h3 id="toc_4">元组</h3>

<p>可以只用元组在同一个 <code>switch</code> 语句中测试多个值，元组中的元素可以是值，也可以是区间，使用下划线 <code>_</code> 来匹配所有可能的值。</p>

<h3 id="toc_5">值绑定</h3>

<p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了。</p>

<p>case 分支的模式可以使用 <code>where</code> 语句来判断额外的条件。</p>

<h2 id="toc_6">控制转移语句</h2>

<h3 id="toc_7">continue</h3>

<p><code>continue</code> 语句告诉一个循环体立刻停止本次循环迭代，重现开始下次循环迭代。</p>

<h3 id="toc_8">break</h3>

<p><code>break</code> 语句会立即结束整个控制流的执行。</p>

<h2 id="toc_9">带标签的语句</h2>

<p>在 Swift 中，你可以在循环体和 <code>switch</code> 代码块中嵌套循环体和 <code>switch</code> 代码块来创造复杂的控制流结构。然而，循环体和 <code>switch</code> 代码块亮着都可以使用 <code>break</code> 语句来提前结束整个方法。因此，显式地指明 <code>break</code> 语句想要终止是哪个循环体或者 <code>switch</code> 代码块，会很有用。</p>

<p>为了实现这个目的，可以使用标签来标记一个循环体或者 <code>switch</code> 代码块，当使用 <code>break</code> 或者 <code>continue</code> 时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>

<p>语法：</p>

<pre><code class="language-swift">label name: while condition { statements }
</code></pre>

<h2 id="toc_10">提前退出</h2>

<p>像 <code>if</code> 语句一样， <code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 分句，如果条件不为真则执行 <code>else</code> 分句中的代码。</p>
]]>
    </content>
  </entry>
  
</feed>
