<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hack Notes]]></title>
  <link href="http://forrestchang.com/atom.xml" rel="self"/>
  <link href="http://forrestchang.com/"/>
  <updated>2017-11-13T14:10:00+08:00</updated>
  <id>http://forrestchang.com/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[摄影笔记（一）：实景人像]]></title>
    <link href="http://forrestchang.com/15105534165006.html"/>
    <updated>2017-11-13T14:10:16+08:00</updated>
    <id>http://forrestchang.com/15105534165006.html</id>
    <content type="html">
<![CDATA[<p>什么是「实景人像」，我们使用这个词是指在摄影室以外的任何地方所拍摄的人像。</p>

<p>什么才算是「合适的」实景呢？适合于被摄者的生活方式和任务特性的实景就是你需要的实景。正如你所知，所有优秀人像的关键在于向我们介绍照片中有关这位「真实人像」某些情况的能力。不仅仅是被摄者的外表如何，而是这位被摄者的内在是什么。</p>

<p>在你拍摄实景人像时，必须考虑在摄影室不成为问题的一些其他细节。例如：</p>

<p>在人像摄影室，你通常要你的被摄者按固定的姿势坐着或站着，在实景摄影中，常拍摄动态的被摄者，或许拿着一件表明个人身份的东西，或从事一项喜爱的活动，诸如跑步、修理私车、锻炼或烹饪。</p>

<p>在摄影室里，背景通常是一块简单的涂色的背景布或无接缝的背白纸。在实景人像中，你必须认真观察实际环境中的一切，它可以是起居室、厨房、娱乐室或草地。在实景人像中，背景充满细节，有些有助于表现被摄者的「身份」或「地位」，有些是无足轻重的。</p>

<p>在摄影室，你要认真控制灯光照明。在实景人像摄影中，你必须调整现场照明——太阳光，室内灯光、有光线照射的窗户以及黑云笼罩的天空。</p>

<h2 id="toc_0">家庭人像</h2>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-062407.png" alt=""/></p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-062457.png" alt=""/></p>

<p>应当考虑让你的被摄者的手做些什么事情，一般人不知道如何放手。他们或是将双手藏起来或是笨拙地做个姿势。为了避免这些问题，最好是让唐门做点什么事情，正如我们所说，最好是做些与他们的兴趣或嗜好有关的事情。例如，编织、读书、写字，若有所思地拿着意志钢笔或铅笔，或正在看家庭影集。</p>

<p>如果房间有壁炉或钢琴，可以考虑将它们作为背景使用，但要注意，只能拍摄这种大物件的某一部分，不要将整个东西都表现出来。以免「喧宾夺主」，而且还要注意背景中的复杂结构，其图案太显眼会分散观众的注意力。</p>

<p>寻找能为照片增加韵味的建筑环境。例如，有趣的台阶、照片橱窗、书架。</p>

<p>保持你的布光简单并注意阴影，闪光灯在被摄者身后墙上投射的阴影会破坏一副优秀人像的效果。通过防止照明灯可以避免这种阴影，这样，阴影投落到照相机拍摄范围以外，或者让你的被摄者离开墙，一遍阴影落在被摄者身后并且不再相机拍摄的范围之内。</p>

<p>在日光下拍摄，你通过让你的被摄者置身在一扇窗户前面的方法，常常可以获得迷人的背景光。由于自然的日光来自被摄者身后，你获取需要在相机前面增加一些辅助光。如果日光特别明亮，你可以用你的辅助闪光灯安全地压过它。但是这种自然光如果微弱，你应该保持辅助光也微弱，这样，才不会主次颠倒。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-063409.png" alt=""/></p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-063441.png" alt=""/></p>

<h2 id="toc_1">户外人像</h2>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-063839.png" alt=""/></p>

<p>如果能避免阳光直接照射你的被摄者，那你通常省事多了，你知道，直射的阳光会造成你的被摄者眯起眼睛，并会在其面部产生一块刺目的明亮高光及浓重的阴影。因此在晴天时，你应该尽量将你的被摄者安排在阴影之下。悬垂的树枝常常可以利用，这种宽阔的阴影既可以避免被摄者眯起眼睛，又可以消除其面部的高光阴影问题。但是，要仔细观察北京，注意不要让明亮的光点从背景的枝叶之间透射过来，这样会产生削弱主题的光斑，因此，尽量选择在完全不透光的北京进行实景拍摄。</p>

<p>在没有适宜阳光的多云天气如何拍摄呢？专业摄影师对这样的天气情有独钟，云彩制造出宽阔的阴影，在这种多云的光线下，你不必担心被摄者皱眉或其面部高光和阴影产生的反差，但是，你要考虑可能出现的其他问题。</p>

<p>首先，正式因为太阳在云后，但这并不意味着天空黑暗，相反，它可能会非常明亮，因此，你要根据情况进行测光。你必须确信，你是对着被摄者面部而不是对着可能是背景的明亮天空测光。</p>

<p>其次，一个可能出现的问题与我们上面讨论的问题相同，也就是说，观察北京，确保没有任何其他分散注意力的明亮光斑与你的被摄者争镜头。此外，天空可能非常明亮，即使无直射的阳光，北京如果不是特别实，而是有些光从缝隙中透射过来照在被摄者面部或其他部位，也会产生很刺眼的光斑。</p>

<p>如何进行逆光拍摄？逆光会在被摄者的头发周围产生灿烂的光辉，勾画出被摄者的肩部轮廓。但是，逆光可能很棘手，首先，要确保太阳光不能直接照到镜头，你只要井相机放在阴影处就可避免这一问题，或者使用长度合适的镜头罩。其次，上面已经提及，不要让你的测光表误测被摄者身后的明亮光线，应该走近被摄者对其脸部测光，并注意在你退回原味取景前锁住曝光。最后，如果来此侧面的太阳光线较多，注意这种光可能在被摄者面部形成不均匀的光斑，如果你看见这种管线可以让被摄者转一下脸，或用一块纸板或类似的遮挡物挡住这些光线。</p>

<h3 id="toc_2">户外背景</h3>

<p>拍摄户外人像时，你不一定要大花园来为拍摄者提供合适的背景，如果你善用背景，一棵树或一丛灌木也许就可以了。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-065549.png" alt=""/></p>

<p>例如，上面这幅图中，摄影师通过紧凑取景和使用浅景深，让背景的枝叶焦点不实，但这些枝叶向观众表明了这幅照片是在户外拍摄的。不用再画蛇添足了，没有比这种照片更简洁的了。</p>

<h3 id="toc_3">简洁</h3>

<p>要保持被摄者身后的背景不过于突出，并用强光照亮你的被摄者。</p>

<p>一堵石墙、砖墙都可以成功的称为户外人像的背景。然而，你需要小心，通过取景器光差，直至画面简洁，确保你的背景不要太杂乱，太醒目。背景如果杂乱、刺眼，或更换一个实景，或利用浅景深将其排斥在焦点之外。此外，如果由于自然光而产生难看的条纹，不放细心光差光的图案。这种光的条纹或许能为人像增添戏剧性效果或分散观众的注意力。睁大眼睛，保持清醒头脑。如果它分散精力，不妨力求简洁。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-11-13-071104.png" alt=""/></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[近期的一些事]]></title>
    <link href="http://forrestchang.com/15104701426674.html"/>
    <updated>2017-11-12T15:02:22+08:00</updated>
    <id>http://forrestchang.com/15104701426674.html</id>
    <content type="html">
<![CDATA[<p>发现好久没有写博客了，并不是没时间，主要还是懒。</p>

<p>大四的上学期已经快过完了，对大四基本上没什么概念，因为没有回学校，所以有人问我今年大几了，有时候还会说成大三。</p>

<p>暑假来上海实习，人生地不熟，有幸和两个漂亮的小姐姐一起合租在一起，发生了很多有趣的事，因为我买了一个显示器，所以每周都会一起追《权力的游戏》和《中国有嘻哈》。8 月底从实习的公司辞职，又上海呆了几周，她们也实习结束回美国继续学业。</p>

<p>九月份和十月份基本都在找工作中度过，九月份的时候其实找工作并不积极，只是网申投了一些简历，各种宣讲会都没有参加，结果网申好多笔试没有过，失去了面试的机会，十月份的时候还是 0 offer，说实话心里已经很紧张了，知道不能再在老家待着了，于是又跑到上海来，投了不少简历，最后拿了几个还算满意的 offer。</p>

<p>这里要说一下 Daocloud，其实几年 3 月份的时候投过这家公司的实习，但是一面就挂了，一面问了很多协程的问题，这在当时确实是我的薄弱点。这一次我又投了这家公司（其实是海投的，后来面了两轮我才知道是 Daocloud），面试出乎意料地简单，一面面试官说看了我 GitHub 上的代码，觉得没什么要问的，于是就简单聊了一些 Flask 框架的东西，二面面试也很简单，问了一道算法题，简单聊了一下项目，三面基本上就是谈人生，然后面试官看到了我会 Lisp，然后又扯了一堆函数式编程和 Haskell，然后就是 HR 面拿 offer 了，整个过程轻松得难以置信。</p>

<p>面的另一家公司是爱奇艺，约了某一天下午去面试，不过因为有了 Daocloud 保底，所以心里也没有那么紧张，一共面了 4 轮，几乎每一个问题我都在白板上写了一堆，除了数据库部分有点卡壳之外，其他都还可以，面试官反馈也比较好，不过心里还是比较虚的，第二天 HR 打电话过来发了 offer，才真正放松下来。</p>

<p>基本上面试的一些公司都拿到了 offer，比较遗憾的就是没有拿到 BAT 一线公司的面试机会。拿到爱奇艺 offer 之后就开始懈怠下来了，把进行中的面试和其他 offer 都拒掉，天天宅在家里刷剧刷电影。</p>

<p>过两天就要去实习了，本来不想实习，想出去浪一段时间，没办法，房子租期签了半年的时间，而且用白条买了一台相机，生活所迫，哎……</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员修炼之道》阅读笔记（二）]]></title>
    <link href="http://forrestchang.com/15029260086085.html"/>
    <updated>2017-08-17T07:26:48+08:00</updated>
    <id>http://forrestchang.com/15029260086085.html</id>
    <content type="html">
<![CDATA[<h3 id="toc_0">重复的危害</h3>

<p>系统中的每一项知识都必须具有单一、无歧义、权威的表示。（感觉翻译得怪怪的）</p>

<blockquote>
<p>Tip 11<br/>
DRY - Don&#39;t Repeat Yourself<br/>
不要重复你自己</p>
</blockquote>

<h4 id="toc_1">重复是怎样发生的</h4>

<ul>
<li>强加的重复（imposed duplication）：开发者觉得他们无可选择 —— 环境似乎要求重复。</li>
<li>无意的重复（inadvertent duplication）：开发者没有意识到他们在重复信息。</li>
<li>无耐性的重复（impatient duplication）：开发者偷懒，他们重复，因为那样似乎更容易。</li>
<li>开发者之间的重复（interdeveloper duplication）：同一团队（或不同团队）的几个人重复了同样的信息。</li>
</ul>

<h5 id="toc_2">强加的重复</h5>

<ul>
<li><p>信息的多种表示</p>

<p>我们也许在编写客户-服务器应用，在客户和服务器端使用了不同的语言，并且需要在两端都表示某种共有的结构。我们或许需要一个类，其属性是某个数据库表的 schema。</p>

<p>解决办法是编写简单的过滤器或代码生成器。可以在每次构建（build）软件时，使用简单的代码生成器，根据公共的元数据表示构建多种语言下的结构。可以用最初用于构建 schema 的元数据，自动生成类定义。</p></li>
<li><p>代码中的文档</p>

<p>代码为什么需要注释：糟糕的代码才需要许多注释。</p>

<p>DRY 法则告诉我们，要把低级的知识放在代码中，它属于那里；把注释保留给其他高级说明。否则，我们就是在重复知识，而每一次改变都意味着既要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟。</p></li>
<li><p>文档与代码</p>

<p>你撰写文档，然后编写代码。有些东西变了，你修订文档、更新代码。文档和代码都含有同一知识表示。</p>

<p>可以根据文档来生成测试。</p></li>
<li><p>语言问题</p>

<p>许多语言会在源码中强加可观的重复。如果语言使模块的接口与其实现分离，就常常会出现这样的情况。C/C++ 有头文件，在其中重复了被导出变量、函数和（C++）类的名称和类型信息。</p>

<p>再思考一下头文件和实现文件中的注释。绝对没有理由在这两种文件之间重复函数或类头注释（head comment）。应该用头文件记载接口问题，用实现文件记载代码的使用者无需了解的实际细节。</p></li>
</ul>

<h5 id="toc_3">无意的重复</h5>

<p>有时，重复来自设计中的错误。</p>

<p>举个例子：</p>

<pre><code class="language-c++">class Line {
    public:
        Point start;
        Point end;
        double lenght;
};
</code></pre>

<p>第一眼看上去这个类似乎是合理的。线段显然有起点和终点，并总是有长度的。但这里有重复，长度是由起点和终点决定的：改变其中一个，长度就会变化。最好是让长度编程计算字段：</p>

<pre><code class="language-c++">class Line {
    public:
        Point start;
        Point end;
        double lenght() { return start.distanceTo(end); }
};
</code></pre>

<h5 id="toc_4">无耐性的重复</h5>

<p>每个项目都有时间压力。</p>

<p>如果你觉得受到了诱惑，想一想古老的格言「欲速则不达」。你现在也许可以节省几秒钟（感觉不止），但以后可能损失几小时。（如果一个人不打算在公司长久待下去的话是会写出重复的代码的，所以 code review 要做好）</p>

<p>无耐性的重复是一种容易检测和处理的重复形式，但那需要你接受训练，并愿意为避免以后的痛苦而预先话一些时间。</p>

<h5 id="toc_5">开发者之间的重复</h5>

<p>或许最难检测和处理的重复发生在项目的不同开发者之间。处理这个问题的最佳方式是鼓励开发者进行主动地交流。</p>

<blockquote>
<p>Tip 12<br/>
Make It Easy to Reuse<br/>
让复用变得容易</p>
</blockquote>

<p>你所要做的就是营造一种环境，在其中找到并复用已有的东西，比自己编写更容易。</p>

<h3 id="toc_6">正交性</h3>

<p>如果你想要制作易于设计、构建、测试及扩展的系统，正交性是一个十分关键的概念。</p>

<h4 id="toc_7">什么是正交性</h4>

<p>「正交性」是从几何学中借来的术语。如果两条直线相交成直角，它们就是正交的。</p>

<p>在计算机技术中，该术语用于表示某种不相依赖性和解耦性。如果两个或更多事物中的一个发生变化，不会影响到其他事物，这些事物就是正交的。</p>

<h4 id="toc_8">正交的好处</h4>

<p>非正交系统的改变与控制更复杂是其固有的性质。当任何系统的各组件互相高度依赖时，就不在具有局部修正这样的事情。</p>

<blockquote>
<p>Tip 13<br/>
Eliminate Effects Between Unrelated Things<br/>
消除无关事物之间的影响</p>
</blockquote>

<p>我们想要设计自足（self-contained）的组件：独立、具有单一、良好定义的目的（内聚）。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你不改变组件的外部接口。</p>

<ul>
<li>提高生产率

<ul>
<li>改动得以局部化，所以开发实践和测试时间得以降低。编写多个相对较小的、自足的组件更为容易，你可以设计、编写简单的组间，对其进行单元测试。当你增加新代码时，无需不断改动已有的代码。</li>
<li>正交的途径还能够促进复用。如果组间具有明确而具体的、良好定义的责任，就可以把它们和新组件整合到一起。</li>
<li>如果你对正交的组件进行组合，生产效率会有相当微妙的提高（M x N &gt; M * (N - i), i 为 M、N 重复内容）</li>
</ul></li>
<li>降低风险

<ul>
<li>有问题的代码区域被隔离开来。</li>
<li>所得的系统更健壮。</li>
<li>政教系统很可能得到更好的测试。</li>
</ul></li>
</ul>

<h4 id="toc_9">项目团队</h4>

<p>怎样把团队划分为责任得到了良好定义的小组，并使重叠降至最低呢？没有简单的答案。我们的偏好是从使基础设施与应用分离开始。每个主要的基础设施组间（数据库、通信接口、中间件层等）有自己的子团队。如果应用功能的划分显而易见，那就照此划分。然后我们考察现有的人员，并对分组进行相应的调整。</p>

<p>在讨论每个所需改动时需要涉及多少人。人数越多，团队的正交性就越差。</p>

<h4 id="toc_10">设计</h4>

<p>对于正交设计，有一种简单的测试方法。一旦设计好组件，问问你自己：如果我显著地改变了某个特定功能背后的需求，有多少模块会受到影响？在正交系统中，大难应该是「一个」。</p>

<p>不要依赖你无法控制的事物属性。</p>

<h4 id="toc_11">工具箱与库</h4>

<p>在你引入第三方工具箱和库时，要注意保持系统的正交性。要明智地选择技术。它是否会迫使你对代码进行不必要的改动。如果对象持久模型（object persistence scheme）是透明的，那么它就是正交的。如果它要求你以一种特殊的方式创建或访问对象，那么它就不是正交的。</p>

<p>正交性的另一个有趣的变体是面向切片编程（Aspect-Oriented Programming, AOP）。AOP 能让你在一个地方表达本来会分散在源码各处的某种行为。例如，日志消息通常是在源码各处、通过显式地调用某个日志函数生成的。通过 AOP，你可以把日志功能正交地实现到要进行日志记录的代码中。（Python 中的装饰器就可以实现这个功能）</p>

<h4 id="toc_12">编码</h4>

<p>你可以将若干技术用于维持正交性：</p>

<ul>
<li>让你的代码保持「解耦」：编写不会没有必要地向其他模块暴露任何事情、也不依赖其他模块具体实现的模块。</li>
<li>避免使用全局数据</li>
<li>避免编写相似的函数：使用 Strategy（策略）模式</li>
</ul>

<p>养成不断地批判对待自己打的代码的习惯，寻找任何重新进行组织、以改善其结构和正交性的机会。这个过程叫重构（refactoring）。</p>

<h4 id="toc_13">测试</h4>

<p>正交地设计和实现的系统也更易于测试，因为系统的各组件间的交互是形式化和有限的，更多的系统测试可以在单个的模块进行。</p>

<h3 id="toc_14">可撤销性</h3>

<blockquote>
<p>如果某个想法是你唯一的想法，再没有什么比这更危险的事了。 —— Emil-Auguste Chartier</p>

<p>Tip 14<br/>
There Are No Final Decisions<br/>
不存在最终决策</p>
</blockquote>

<p>通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。</p>

<h3 id="toc_15">曳光弹</h3>

<p>为了在代码中获得「曳光弹」的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求。</p>

<blockquote>
<p>Tip 15<br/>
Use Tracer Bullets to Find the Target<br/>
用曳光弹找到目标</p>
</blockquote>

<p>曳光弹告诉你击中的是什么，那不一定总是目标，于是你调整准心，直到完全击中目标为止，这正是要点所在。</p>

<h3 id="toc_16">原型与便笺</h3>

<p>你可以为下列事物制作原型：</p>

<ul>
<li>架构</li>
<li>已有系统中的新功能</li>
<li>外部数据的结构或内容</li>
<li>第三方工具或组件</li>
<li>性能问题</li>
<li>用户界面设计</li>
</ul>

<p>原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。那才是原型制作的要点所在。</p>

<blockquote>
<p>Tip 16<br/>
Prototype to Learn<br/>
为了学习而制作原型</p>
</blockquote>

<h4 id="toc_17">怎样使用原型</h4>

<p>在构建原型时，你可以忽略哪些细节？</p>

<ul>
<li>正确性：你也许可以在适当的地方使用虚假的数据；</li>
<li>完整性：原型也许只能在非常有限的意义上工作；</li>
<li>健壮性：错误检查很有可能不完整。如果你偏离预定路径，原型就可能崩溃，这没有关系；</li>
<li>风格：原型代码可能没有多少注释或文档。</li>
</ul>

<p>因为原型应该遮盖细节，并聚焦于所考虑系统的某些具体方面，你可以用非常高级的语言实现原型。高级的脚本语言能让你推迟考虑许多细节，并且仍然能制作出可以工作的代码。</p>

<h4 id="toc_18">制作架构原型</h4>

<p>一些你可以在架构原型中寻求解答的具体问题：</p>

<ul>
<li>主要组间的责任是否得到了良好的定义？是否适当？</li>
<li>主要组间间的协作是否得到了良好的定义？</li>
<li>耦合是否得以最小化？</li>
<li>你能否确定重复的潜在来源？</li>
<li>接口定义和各项约束是否可接受？</li>
<li>每个模块在执行过程中是否能访问到其所需的数据？能够在需要时进行访问？</li>
</ul>

<h3 id="toc_19">领域语言</h3>

<blockquote>
<p>Tip 17<br/>
Program Close to the Problem domain<br/>
靠近问题领域编程</p>
</blockquote>

<p>无论适用于配置和控制应用程序的简单语言，还是用于指定规则或过程的更为复杂的语言，我们认为，你都应该考虑让你的项目更靠近问题领域。通过在更高的抽象层面上编码，你获得了专心解决领域问题的自由，并且可以忽略琐碎的实现细节。</p>

<h3 id="toc_20">估算</h3>

<blockquote>
<p>Tip 18<br/>
Estimate to Avoid Surprises<br/>
估算，以避免发生意外</p>
</blockquote>

<h4 id="toc_21">估算来自哪里</h4>

<ol>
<li>理解提问内容：任何估算练习的第一步都是建立对提问内容的理解。除了上面讨论的精确度以外，你还需要把我问题域的范围。这常常隐含在问题中，但你需要养成在开始猜想之前先思考范围的习惯。</li>
<li>建立系统的模型：根据你对所提问题的理解，建立粗略、就绪的思维模型骨架。</li>
<li>把模型分解为组件：你需要找出描述这些组件怎样交互的数学规则。你将会发现，在典型的情况下，每个组件都有一些参数，会对它给整个模型带来什么造成影响。在这一阶段，只要确定每个参数就行了。</li>
<li>给每个参数指定值：一旦你分解出各个参数，你就可以逐一给每个参数赋值。在这个步骤中你可能会引入一些错误。诀窍是找出哪些参数对结果的影响最大，并致力于让它们大致正确。</li>
<li>计算答案：在计算阶段，你可能会得到看起来很奇怪的答案。不哟啊太快放弃它们，如果你的运算是正确的，那你对问题或模型的理解就很可能是错的。这是非常宝贵的信息。</li>
<li>追踪你的估算能力</li>
</ol>

<h4 id="toc_22">估算项目进度</h4>

<p>在面对相当大的应用开发的各种复杂问题与反复无常的情况时，普通的估算规则可能会失效。为项目确定进度表的唯一途径常常是在相同的项目上获取经验。</p>

<ul>
<li>检查需求</li>
<li>分析风险</li>
<li>设计、实现、继承</li>
<li>向用户确认</li>
</ul>

<blockquote>
<p>Tip 19<br/>
Iterate the Schedule with the Code<br/>
通过代码对进度表进行迭代</p>
</blockquote>

<h3 id="toc_23">总结</h3>

<p>第二章其实更多的再讲团队和产品设计方面的问题，自己在这两方面并没有什么经验。不过 DRY 和正交性的概念还是比较重要的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员修炼之道》阅读笔记（一）]]></title>
    <link href="http://forrestchang.com/15026034118735.html"/>
    <updated>2017-08-13T13:50:11+08:00</updated>
    <id>http://forrestchang.com/15026034118735.html</id>
    <content type="html">
<![CDATA[<p>实习到现在差不多两个月了，博客也一直荒废了没写。这次更新就先来写写读书笔记好了。</p>

<p>这本书从书名来看其实很像那种鸡汤类的书，英文名「The Pragmatic Programmer」（注重实效的程序员）看上去就好了许多。<a href="https://book.douban.com/subject/1152111/">豆瓣评分</a> 8.6 分。大一的时候买的书，之前随意地写过几年的玩具代码，所以初读这本书的时候觉得很有道理，但是读完了之后发现什么也没有记住。用<a href="http://blog.youxu.info">徐宥</a>的话来说就是「读者如果没有类似的经历，看到这些珠玑，也只是觉得把玩颇为有趣而已，极少能有同感。」大一的时候读这是这种感觉。</p>

<p>出来实习之后，接触到实际生产中的代码，在代码量比较大的情况下（几十万行），之前书中所讲的一些问题都一一浮现了。为了写出优雅的代码，有必要把这本书再读一遍，可能以后还要反复读很多遍（不是所有的内容看一遍就能内化在心里的），所以每读一部分就记一点笔记，留作日后复习用。</p>

<p>给自己制定以下阅读的计划，因为这本书每一张的内容读起来都比较轻松，所以预计用两周的时间读完：</p>

<ol>
<li>每 1-2 天阅读一章（共 8 章）</li>
<li>每一章都写一篇笔记，读的时候可以做一些摘录，读完一章之后写一篇总结性的笔记；</li>
</ol>

<p>下面是「序言」和「第一章」的笔记。</p>

<hr/>

<h2 id="toc_0">序</h2>

<h3 id="toc_1">注重实效的程序员都有哪些特征</h3>

<ul>
<li>早期的采纳者/快速的改编者：给你一样新东西，你很快能把握它，并把它与你的知识的其余部分结合在一起（尝试新技术）；</li>
<li>好奇：你喜欢提问，你是收集小知识的林鼠（建立自己的知识 wiki）；</li>
<li>批判的思考者：你会首先抓住事实，而不是照搬别人所说的；</li>
<li>有现实感：你会设法理解你面临的每个问题的内在本质（事情有多困难，需要花多长时间完成？）</li>
<li>多才多艺：你尽力熟悉广泛的技术和环境；</li>
</ul>

<p>（审视一下自己，上面几点好像都没有做到，或者说有的做到了但是并不到位。）</p>

<blockquote>
<p>Tip 1<br/>
Care About Your Craft<br/>
关心你的技艺</p>
</blockquote>

<p>如何做到上面所说的？<strong>在你做某件事情的时候思考你在做什么</strong>。</p>

<blockquote>
<p>Tip 2<br/>
Think! About Your Work<br/>
思考！你的工作</p>
</blockquote>

<h3 id="toc_2">它是一个持续的过程</h3>

<p>每天为提炼你所拥有的技能而工作，为把新的工具增加到你的技能列表中二工作。草坪不是一天修成的。</p>

<h2 id="toc_3">第一章：注重实效的哲学</h2>

<h3 id="toc_4">我的源码让猫给吃了</h3>

<blockquote>
<p>在所有的弱点中，最大的弱点就是害怕暴露弱点。—— J.B.Bossuet</p>
</blockquote>

<p>如果你确实同意要为某个结果负责，你就应该切实负起责任。当你犯错误的时候，不要责备别人或别的东西，或是拼凑借口。你可以选择提供解决方案，而不是寻找借口。</p>

<blockquote>
<p>Tip 3<br/>
Provide Options, Don&#39;t Make Lame Excuses<br/>
提供各种选择，不要找蹩脚的借口</p>
</blockquote>

<p>在你走向任何人，告诉他们为何某件事做不到、为何耽搁、为何出现问题之前，先停下来，听一听你心里的声音。在你去告诉他们坏消息之前，是否还有其他你可以再试一试的办法？有时，你其实知道他们会说什么，所以还是不要给他们添麻烦。</p>

<p>（这一点深有感触，在实习的这一段时间里面，经常因为一些小事去麻烦 leader，比如说环境跑步起来，某个莫名其妙的报错等，这虽然有文档不全的原因在，不过自己也没想着去补全文档这种解决办法。）</p>

<h3 id="toc_5">软件的熵</h3>

<p>软件中的无序增长时，程序员们称之为「软件腐烂」（software rot）。</p>

<p>「破窗理论」：以一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里占领、定居或者纵火。又或想像一条人行道有些许纸屑，如果无人清理，不久后就会有更多垃圾，最终人们会视为理所当然地将垃圾顺手丢弃在地上。</p>

<blockquote>
<p>Tip 4<br/>
Don&#39;t Live with Broken Windows<br/>
不要容忍破窗户</p>
</blockquote>

<p>不要留着「破窗户」（低劣的设计、错误决策、或是糟糕的代码）不修，发现一个修一个。</p>

<p>如果没有足够的时间进行适当的修理，可以把出现问题的代码放到注释中，或者是用虚拟的数据来代替。<strong>采取某种行动防止进一步破坏，并说明情势处在你的控制之下</strong>。</p>

<p>如果你发现自己在有好些破窗户的项目里工作，会很容易产生这样的想法：「这些代码的其余部分也是垃圾，我只要照着做就行了。」</p>

<h3 id="toc_6">石头汤与煮青蛙</h3>

<blockquote>
<p>Tip 5<br/>
Be a Catalyst for Change<br/>
做变化的催化剂</p>
</blockquote>

<p>（有的时候想要做出一个新功能，可以先开发一个简单的版本，然后诱导别人往其中添加新功能。）</p>

<blockquote>
<p>Tip 6<br/>
Remember the Big Picture<br/>
记住大图景</p>
</blockquote>

<p>当你设法催生变化时，你能否确定你是在做石头汤还是青蛙汤？决策是主观的还是客观的？</p>

<h3 id="toc_7">足够好的软件</h3>

<blockquote>
<p>Tip 7<br/>
Make Quality a Requirements Issue<br/>
使质量称为需求问题</p>
</blockquote>

<p>不要因为过度修饰和过于精于求精而破坏完好的程序。继续前进，让你的代码凭借自己的质量站立一会儿，它也许不完美，但不用担心：它不可能完美。</p>

<h3 id="toc_8">你的知识资产</h3>

<blockquote>
<p>知识上的投资总能得到最好的回报。—— 本杰明·富兰克林</p>
</blockquote>

<p>管理知识资产与管理金融资产非常相似：</p>

<ul>
<li>严肃的投资者定期投资</li>
<li>多元化是长期成功的关键：你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特定技术的各种特性，但不要就此止步。</li>
<li>聪明的投资者在保守的投资和高风险、高回报的投资之间平衡他们的资产</li>
<li>投资者设法低买高卖，以获取最大回报：在新兴的技术流行之前学习它可能就和找到被低估的股票一样困难，但所得到的就和那样的股票带来的收益一样。</li>
<li>应周期性地重新评估和平衡资产</li>
</ul>

<blockquote>
<p>Tip 8<br/>
Invest Regularly in YOur Knowledge Portfolio<br/>
定期为你的知识资产投资</p>
</blockquote>

<ul>
<li><strong>每年至少学习一种新语言</strong>。</li>
<li><strong>每季度阅读一本技术书籍</strong>。一旦你养成习惯，就一个月读一本书。在你掌握了你正在使用的技术之后，扩宽范围，阅读一些与你的项目无关的书籍。</li>
<li><strong>也要阅读非技术书籍</strong>。</li>
<li><strong>上课</strong>。</li>
<li><strong>参加本地用户组织</strong>。不要只是去听讲，而要主动参与。</li>
<li><strong>试验不同的环境</strong>。</li>
<li><strong>跟上潮流</strong>。订阅商务杂志和其他期刊。</li>
<li><strong>上网</strong>。</li>
</ul>

<p>持续投入非常重要，一旦你熟悉了某种新语言或技术，继续前进，学习另外一种。设法把你学到的东西应用到你当前的项目当中，即使你的项目没有使用该技术，你或许也能借鉴一些想法。</p>

<p>所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先规划。让自己在空闲的片刻时间里总有东西可读。</p>

<p>最后一个药店是，批判地思考你读到的和听到的。你需要确保你的资产中的知识是准确的。</p>

<blockquote>
<p>Tip 9<br/>
Critically Analyze What You Read and Hear<br/>
批判地分析你读到的和听到的</p>
</blockquote>

<h3 id="toc_9">交流</h3>

<blockquote>
<p>Tip 10<br/>
It&#39;s Both What You Say and the Way You Say It<br/>
你说什么和你怎么说同样重要</p>
</blockquote>

<p>除非你生活在真空中，你猜不需要交流，交流越有效，你就越有影响力。</p>

<h2 id="toc_10">总结</h2>

<p>大概花了两个多小时的时间把第一章的内容看了一遍，顺便摘录了一些内容。这一章其实更多的是讲「道」层面上的内容，与技术内容关联不大，但又是至关重要的，做好了上面几点可以从「码农」蜕变成「程序员」，能有自己的思考，能够与他人交流，能够对自己进行投资，而不是一味地按照要求写代码。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start A Coding Challenge]]></title>
    <link href="http://forrestchang.com/14943348129857.html"/>
    <updated>2017-05-09T21:00:12+08:00</updated>
    <id>http://forrestchang.com/14943348129857.html</id>
    <content type="html">
<![CDATA[<p>最近在 YouTube 上看了很多 <a href="https://www.youtube.com/channel/UCvjgXvBlbQiydffZU7m1_aw">Daniel Shiffman</a> 做的 <a href="https://www.youtube.com/playlist?list=PLRqwX-V7Uu6ZiZxtDDRCi6uhfTH4FilpH">Coding Challenges</a> 系类的视频，然后自己也用 p5.js 写了两个<a href="https://github.com/forrestchang/p5js-coding-challenges">项目</a>，发现还挺有意思的。在这之前我的 JavaScript 仅仅只是看过「XX 分钟速成 JavaScript」的水平，除了学校的作业几乎也没有写过 JS。所以想借此机会来练习一下 JavaScript。</p>

<p>在 GitHub 上开了一个 repo，名字叫「<a href="https://github.com/forrestchang/p5js-coding-challenges">p5js-coding-challenges</a>」，给自己定几个要求：</p>

<ol>
<li>每天用 p5.js 完成一个小的 Project（已经写了 <a href="http://forrestchang.com/p5js-coding-challenges/Day001-StarField/">Star Field</a> 和 <a href="http://forrestchang.com/p5js-coding-challenges/Day002-Flappy-Bird/">Flappy Bird</a>）</li>
<li>Project Idea 可以是参考别人的，也可以是自己想，但是不能照着抄代码，可以看完了自己写出来或者改进别人的实现</li>
<li>每天想好第二天要写的 Project 是什么，避免第二天多花时间想这个</li>
<li>因为最近的主要任务是看《计算机网络——自顶向下方法》，所以这个不能够花太多时间在上面，写的时候也要控制一下自己的时间，quick coding</li>
<li>也不知道能够坚持多久，先定一个礼拜的挑战时间</li>
</ol>

<p>因为写完了就可以在浏览器中跑起来，所以交互性很强。每天写了什么和第二天打算写的项目应该会在 <a href="https://twitter.com/tisoga">Twitter</a> 中更新。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Week 19：时间管理]]></title>
    <link href="http://forrestchang.com/14941475791022.html"/>
    <updated>2017-05-07T16:59:39+08:00</updated>
    <id>http://forrestchang.com/14941475791022.html</id>
    <content type="html">
<![CDATA[<p>之前有在博客上写 Weekly Review 的习惯，后来因为被朋友说博客真水然后都撤下来了，有些文章确实是类似于「流水账」的记事，但也有一些是围绕这周做的东西来讨论的。总的来说，写 Weekly Review 对自己帮助还是很大的，可以在一周中 Focus 一个特定的主题，而不是想到什么做什么，所以这个系列以后还会继续写下去，只是写的内容更加具体一天，可以围绕着这周的 Project，或者这周听的音乐，或者读的书之类的。以前的文章看情况要不要放上来。</p>

<p>这周算是正式把我的任务管理系统从 org-mode 转移到 Todoist 上来了。在不考虑时间成本和易用性上来说，org-mode 依然是目前我认为最完备的任务和时间管理系统，我用它来：</p>

<ol>
<li>任务管理：类似于 OmniFocus 的多层级任务管理，支持标签和优先级，可以自定义过滤视图</li>
<li>时间记录：按照项目的方式来记录时间，基本是在做哪件事之前把计时器打开，一个番茄时间后自动关闭，可以自定义生成各种时间报表</li>
<li>番茄工作法</li>
</ol>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-05-07-092455.jpg" alt=""/></p>

<p>自定义生成的时间记录表：</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-05-07-092544.jpg" alt=""/></p>

<p>虽然 org-mode 的优点众多，但是始终是一个基于 Emacs 的 major mode，所以诸多限制在所难免：</p>

<ol>
<li>没有一个简单易用的移动端</li>
<li>没办法做到全局 capture，虽然借助 Alfred 的 Workflow 和 Elisp 脚本能够实现这一功能，但是使用起来体验并不是很好</li>
<li>编辑功能过重，很显然，做任务管理不需要多么高效的编辑操作，类似于 OmniFocus 使用鼠标 + 快捷键才是更高效的方法，在 Emacs 里经常编辑速度过快把整个文件搞乱了</li>
</ol>

<p>不用 OmniFocus 的原因是本来就是从 OmniFocus 转到 org-mode 上来的，OmniFocus 有一个很致命的缺点就是不支持多标签，并且 Perspective 提供的设置选项也很有限，根不能不能满足一些复杂的过滤要求。除此之外，OmniFocus 应该是最优秀的任务管理软件了。</p>

<p>Todoist 初次使用的时候感觉很难用，尤其是鼠标点击就进入编辑模式，这个设计真的不知道怎么想的，并且各平台的客户端一点也不 Native，基本就是 Web 版套了一个壳。macOS 客户端经常有一些莫名的 bug，反正软件的使用体验上来说和 OmniFocus 简直不能比。</p>

<p>经过一段时间的调教，现在基本还能满足日常使用了。我认为一个可靠的任务管理系统需要满足两点：</p>

<ol>
<li>能够随时把想法和任务记录进去</li>
<li>能够按照特定的要求过滤出任务</li>
</ol>

<p>其他的一些东西其实都是为了服务这两点的，比如说标签系统，其实就是在过滤任务的时候多加了一个维度。Todoist 的过滤系统比 OmniFocus 好很多，但是和 org-mode 这种可以完全自定义的过滤系统相比还是差点，不过也完全够用。</p>

<p>具体要写 Todoist 怎么用可能一篇文章也写不完（或许以后会写），另外 Todoist 还刚使用，有些东西还需要熟悉一下，下一篇文章会介绍一下目前我在用的一些过滤器。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这周在读什么 Issue#1]]></title>
    <link href="http://forrestchang.com/14903286295184.html"/>
    <updated>2017-03-24T12:10:29+08:00</updated>
    <id>http://forrestchang.com/14903286295184.html</id>
    <content type="html">
<![CDATA[<p>为什么要写这个？最主要的原因还是激励自己多多阅读，读好书和好文章，然后写 review。</p>

<p>读些什么？平常的阅读比较杂，除了书籍之外，还会读很多的博客文章，所以会写这周的 book review，主要是针对这周读完的书，读了一半放弃不打算再读的书也会写，没有读完的书不写；文章就简单写一些笔记性的 review。</p>

<p>*注：标注了 <code>[TECH]</code> 是和我专业相关的内容，可以跳过。</p>

<h2 id="toc_0">Books</h2>

<h3 id="toc_1"><a href="https://book.douban.com/subject/4251102/">《清华园日记》</a>，季羡林，外语教学与研究出版社，二零零九。</h3>

<p>这本书断断续续得读了有一个月的时间，因为是日记体的形式，所以什么时候都可以拿出来读一下。</p>

<blockquote>
<p>日记是写给自己看的，什么样的思想，什么样在人前难以说出口的话，都写了进去。万没想到今天会把日记公开。这些话是不是要删掉呢？我考虑了一下，决定不删。一仍其旧，一句话也没有删。<mark>我七十年前不是圣人，将来也不会成为圣人。我不想到孔庙里去陪着吃冷猪肉。我把自己活脱脱地暴露于光天化日之下。</mark></p>
</blockquote>

<p>这本日记是季羡林在清华园求学时所记，从大三一直写到大四。百年之前的大学生活和现在相比，并无什么太大的不同。季老也有过迷茫，对前途的忧虑，但是更多的是在勤勉地读书、写文章。</p>

<blockquote>
<p>苏东坡词「谁到人生无再少，门前流水尚能西」。难道这就是「再少」吗？</p>
</blockquote>

<p>阅读用时：7 小时 26 分，<a href="https://www.evernote.com/l/AYC42MIUq-5BXIHRNGdRcL1OxXt3DPzLT5k">摘录</a>。</p>

<h2 id="toc_2">Articles</h2>

<h3 id="toc_3">1. <a href="https://medium.freecodecamp.com/how-i-got-a-second-degree-and-earned-5-developer-certifications-in-just-one-year-while-working-and-2b902ee291ab#.gblxpzdk0">How I got a second degree and earned 5 developer certifications in just one year, while working and raising two kids</a></h3>

<p>全职教师、两个孩子、五张开发者证书、一个第二学位。如何在一年内实现这么多事？</p>

<blockquote>
<p>Ambitious goals are important.</p>
</blockquote>

<p>另外，你还不得不放弃一些东西。比如，剧是不能追了。</p>

<blockquote>
<p>It was important for me to give things up in order to accomplish my goals.</p>
</blockquote>

<p>学会使用 8/2 法则，逃出自己的 comfort zone。</p>

<blockquote>
<p>Really, when learning anything, you should ask yourself if it is part of the 20% of learning content that will give you 80% of value.</p>
</blockquote>

<p>这和很久前看的<a href="https://www.douban.com/group/topic/34856495/">一篇文章</a>很像。</p>

<h3 id="toc_4">2. <a href="https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c#.6o98rs4xs">Unconventional way of learning a new programming language</a></h3>

<p>Open source projects oriented programming.</p>

<p>如何学习一门新的语言，参加关于那个语言的开源项目。开源项目没有想象的那么难。</p>

<blockquote>
<p>I had a look at the issues and found a lot of “beginner” issues. I immediately started working on them and submitted a couple of pull requests. Fast forward to today, I am one of the main contributors for a couple of their open projects and also one of the 20 Open Source Community Leaders for DuckDuckGo.</p>
</blockquote>

<h3 id="toc_5">3. <a href="https://medium.freecodecamp.com/looking-back-to-what-started-it-all-731ef5424aec#.scacfw9pe">A Vision of Coding, Without Opening your Eyes</a></h3>

<blockquote>
<p>I’m a coder. I’m also blind. Blind as a bat, you might say. And I was born this way.</p>
</blockquote>

<p>这篇文章写自一个 blind coder，解释了三个（在我看来）有点 offensive 的问题：1）如何阅读；2）如何 coding；3）会做梦吗？</p>

<blockquote>
<p>I’ll try and sketch out an image for those of you who are curious about accessibility, and how blind people use computers to code, and to do the work of the 21st century.</p>
</blockquote>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[叛逃 Spotify]]></title>
    <link href="http://forrestchang.com/14899058720947.html"/>
    <updated>2017-03-19T14:44:32+08:00</updated>
    <id>http://forrestchang.com/14899058720947.html</id>
    <content type="html">
<![CDATA[<p>不久前我还<a href="digital-life-in-2016-music-part.html">写文</a>称赞过 Apple Music，现在光速打脸，叛逃 Spotify。</p>

<p>主要原因有几点：</p>

<ol>
<li>Apple Music 的「My Favorites Mix」一周才更新一次，不够听。</li>
<li>推荐的歌单都是听过的，专辑也是，重复推荐，并且由于是人工编辑的歌单，难免有不合自己口味的。</li>
<li>个性化推荐的内容太单一，经常出现歌慌，需要自己去找歌。</li>
<li>同步问题。</li>
</ol>

<p>Spotify 的 Premium 之前就买了，但是一直没有用。这几天用了一下，说一下使用体验：</p>

<ol>
<li>推荐算法很厉害，机器推荐的歌更个人一些，不会有人工歌单的主观因素在里面。</li>
<li>「Based on the songs in this playlist」这个功能很有用，可以用来扩充歌单。</li>
<li>Radio 功能比 Apple Music 强大。</li>
<li>多设备同步，这个功能太方便了，我只需要在电脑上断开蓝牙连接，然后就可以直接在手机上听了（配合蓝牙耳机）。</li>
</ol>

<p>一些不满意的地方：</p>

<ol>
<li>不能收藏专辑，有的专辑里面并不是每首歌都喜欢听，save 专辑会把整张专辑里面的歌添加到资料库里，这不得不让我又新建一个 Loved 的歌单，专门用来放喜欢的歌，这样和 Apple Music 就是差不多的操作逻辑。</li>
<li>没有提供加心功能，「+」仅仅是把歌曲添加到资料库，所以还得手动建一个歌单然后再添加，比较麻烦（可能我使用的方法不正确？）</li>
</ol>

<p>不过毕竟才用了几天，还没有深度体验过。Mac 上推荐配合 Alfred 的 Workflow 来使用，可以避免到 Spotify 应用里面进行操作。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 刷题笔记]]></title>
    <link href="http://forrestchang.com/14891114444883.html"/>
    <updated>2017-03-10T10:04:04+08:00</updated>
    <id>http://forrestchang.com/14891114444883.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">001 Two Sum [Easy]</a>
<ul>
<li>
<a href="#toc_1">题目</a>
</li>
<li>
<a href="#toc_2">时间复杂度</a>
</li>
<li>
<a href="#toc_3">思路</a>
</li>
<li>
<a href="#toc_4">代码</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">002 Add Two Numbers [Medium]</a>
<ul>
<li>
<a href="#toc_6">时间复杂度</a>
</li>
<li>
<a href="#toc_7">思路</a>
</li>
<li>
<a href="#toc_8">代码</a>
</li>
<li>
<a href="#toc_9">笔记</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">007 Reverse Integer [Easy]</a>
<ul>
<li>
<a href="#toc_11">题目</a>
</li>
<li>
<a href="#toc_12">思路</a>
</li>
<li>
<a href="#toc_13">代码</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">001 Two Sum [Easy]</h2>

<h3 id="toc_1">题目</h3>

<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>Example：</p>

<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<h3 id="toc_2">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_3">思路</h3>

<p>比较暴力的做法就是用两个循环来穷举，这样的话时间复杂度会达到 \(O(n^2)\)。</p>

<p>另外一种思路就是使用一个 dict 来保存外循环中 target 与 num 的差值，这样在数组中只要发现这个值就可以直接返回了，而在 dic 查找的时间复杂度为 \(O(1)\)。</p>

<h3 id="toc_4">代码</h3>

<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            else:
                dic[target - num] = i
</code></pre>

<h2 id="toc_5">002 Add Two Numbers [Medium]</h2>

<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>Example:</p>

<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre>

<h3 id="toc_6">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_7">思路</h3>

<p>把两个数相加存在链表里，这两个数字的每一位都存在链表中，并且链表是反转的。思路很简单，就是遍历链表，把数取出来，然后加完后再添加到链表中。</p>

<p>代码写得很直白。</p>

<h3 id="toc_8">代码</h3>

<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        num1 = []
        num2 = []
        current = l1
        while current != None:
            num1.append(str(current.val))
            current = current.next
        current = l2
        while current != None:
            num2.append(str(current.val))
            current = current.next
        num1 = &#39;&#39;.join(num1)[::-1]
        num2 = &#39;&#39;.join(num2)[::-1]
        sum = int(num1) + int(num2)
        first = ListNode(str(sum)[0])
        for i in str(sum)[1:]:
            oldfirst = first
            first = ListNode(i)
            first.next = oldfirst
        return first
</code></pre>

<h3 id="toc_9">笔记</h3>

<p>翻了一下 discuss，发现我的解法实在是太 dirty 了。</p>

<p>下面这一段代码我认为还是非常优美的实现：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        def tolist(n):
            node = ListNode(n % 10)
            if n &gt; 9:
                node.next = tolist(n // 10)
            return node
        return tolist(toint(l1) + toint(l2))
</code></pre>

<p>非递归版本：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        n = toint(l1) + toint(l2)
        first = last = ListNode(n % 10)
        while n &gt; 9:
            n /= 10
            last.next = last = ListNode(n % 10)
        return first
</code></pre>

<p>解释一下思路。</p>

<p>首先 <code>toint(node)</code> 函数是将链表转化成 <code>int</code> 类型的数据，因为 Python 中 <code>int</code> 可以存非常大的数，所以不用考虑链表的长度。算法也很简单，因为链表是转置的，所以高位在链表后面，依次乘以 10 的 n 次方再相加就可以了。</p>

<p><code>tolist(n)</code> 函数式将计算好的数据转化成链表，再纸上拿一个一个例子画一个图就很好理解了。<code>node = ListNode(n % 10)</code> 每一次递归都创建一个节点来存放某一位的数据，<code>tolist(n // 10)</code> 每一次递归都截取一位数字。</p>

<p>非递归的方法类似。</p>

<h2 id="toc_10">007 Reverse Integer [Easy]</h2>

<h3 id="toc_11">题目</h3>

<p>Reverse digits of an integer.</p>

<p>The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.</p>

<p>Ex：</p>

<pre><code>Example1: x = 123, return 321
Example2: x = -123, return -321
</code></pre>

<h3 id="toc_12">思路</h3>

<p>这道题很简单，但是要考虑转置之后会不会溢出，但是 Python 的 <code>int</code> 是不会溢出的，所以就需要手动判断一下，INT32 最大值是 \(2^{31}-1\)，用十六进制表示就是 <code>0x7FFFFFFF</code>。</p>

<h3 id="toc_13">代码</h3>

<pre><code class="language-python">class Solution(object):
    def reverse(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: int
        &quot;&quot;&quot;
        if x &lt; 0:
            result = -(int(str(x).lstrip(&#39;-&#39;)[::-1]))
        else:
            result = int(str(x)[::-1])
        
        if abs(result) &gt; 0x7FFFFFFF:
            return 0
        return result
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digital Life in 2016: 音乐篇]]></title>
    <link href="http://forrestchang.com/digital-life-in-2016-music-part.html"/>
    <updated>2017-02-24T11:52:04+08:00</updated>
    <id>http://forrestchang.com/digital-life-in-2016-music-part.html</id>
    <content type="html">
<![CDATA[<p>最近知乎上的一个朋友和我私信聊了一些关于效率工具以及 Workflow（此处指的是「工作流」）方面的一些问题。聊的内容比较碎片，所以还是打算写一篇文章来具体讨论一下。考虑到会涉及很多不同的主题，所以还是一个主题写一篇，这样也可以控制文章的长度。暂定按照以下主题来写：音乐篇、阅读篇、写作篇和时间管理篇。</p>

<p>音乐对我来说，应该算是日常生活中比较重要的一项内容了，除了一些需要特别 Focus 的工作（例如看数学）不会听音乐外，其他时间都会戴着耳机。2016 年彻底地转入到 Apple Music 中来，期间试用过一段时间的 Spotify，网易云音乐几乎没怎么打开过。这篇打算讨论一下所有（尽量）听音乐方面相关的问题。</p>

<h2 id="toc_0">用什么设备听</h2>

<p>我的大多数电子设备都是 Apple 系的，包括 rMBP、iPhone、iPad，所以听音乐也都是围绕着这些设备来。严格的来说，并不能算一个「音乐发烧友」，我对设备的要求并不是太高，甚至对音源也没有太高的要求，Apple Music 的音质已经完全能够满足了，无损音源内容几乎不听，其一是没有购买 CD 的习惯，所以没有合法的途径获取无损资源；其二是一直都是拿 iTunes 听音乐，无损还需要转格式编辑信息，过于麻烦。</p>

<p>主力播放器是 Macbook，几乎 80% 的时间都是在 Macbook 上听（写代码、阅读、写作等）。另外便是新购入的 iPhone 7，主要是外出坐车、跑步或是睡前听一下（之前是用 5s）。iPad 很少用来听音乐。</p>

<p>使用的耳机是 <a href="https://www.amazon.com/Westone-Pro30-Performance-Universal-Earphones/dp/B00FKY3IFA">Westone UM Pro 30</a>，使用体验很好，对比 Apple 自带的耳机有惊艳的提升，而且长时间佩戴也没有不适感（几乎没有戴着耳机的感觉）。想要具体了解得可以去搜相关的评测来看。</p>

<p>耳机是在 7 发售之前买的，传闻 7 要去掉耳机接口的时候其实我是不信的，结果还真去掉了。这导致了插 7 上需要多接一根转接线，略显累赘，所以现在在 iPhone 上听歌就直接拿自带的耳机了。</p>

<h2 id="toc_1">为什么不用网易云音乐</h2>

<p>我知道，我也很讨厌类似「我为什么不 xxx」的说法，「不用就不用，还要批判一番」，但是还是要写一写。</p>

<p>其实我很早就开始使用网易云音乐了，那个时候一些热门的歌曲下评论还只有几百条，不像现在，动辄上千上万条评论。也安利过身边好多人用，曾经是长期的会员用户，所以还是有一些资格来谈论一下这个音乐服务的。</p>

<p>很明显，网易云音乐最初就是模仿 Spotify 的，包括界面设计，几乎一模一样。除了借鉴 Spotify 之外，网易云音乐还加入了很多自己的「创新」，而正是这些所谓的创新，让我开始慢慢得不想用它。</p>

<ol>
<li>评论：其实我是赞成加入评论功能的，但是网易云的评论已经偏离了音乐评论的范围，变成了编故事、讲段子、骗赞评论的聚集地。认真评论音乐的几乎没有，我不知道如果想看段子为什么不上微博？这一点实际上让一个音乐软件变成了社交软件，不好意思，我只想好好听音乐。</li>
<li>歌曲：网易云上很多歌曲的信息混乱不堪，包括专辑信息、专辑封面、年份等，很多单曲甚至没有专辑信息，直接被编排到「热门歌曲串烧」这样的专辑里，我有强迫症，看着挺 low 的。并且很多的歌来源都不明确，大多数都是网友上传，甚至很多 Bilibili 鬼畜区的音乐也被上传上来，哪天听推荐就冷不丁得听到。</li>
<li>专辑封面不完整：网易云的一大特色就是模仿唱片机旋转，想看一下专辑封面是什么样还要点到专辑列表里面去看。在我看来，在电子设备上「拟物」是一种很没有效率的事，就像之前电子书的模拟翻页一样，「翻页」这个动作本来就是一个三维的过程，在手机上再怎么模拟也达不到现实中的效果，「瀑布式」的阅读方式才是正确的选择。所以我推崇「反拟物化」、「扁平化」和「极简化」的设计风格。</li>
<li>歌单：几乎所有的歌单都是由用户创建，和 Apple Music 与 Spotify 专门的音乐编辑创建的歌单相比，高下立判。</li>
</ol>

<p>在我看来，听音乐是一件很纯粹的事，而网易云给这件纯粹的事加了太多的东西。</p>

<h2 id="toc_2">Apple Music 之痛</h2>

<p>Apple Music 自从 2015 年 6 月发布以来，到现在已经有接近两年的时间了，从发布当天付费到现在，中间用了一段时间的国区，由于曲库原因，现在还换回了港区，每月 48 港币，虽然比国区每月 10 ￥（学生 5 ￥）贵了不少，不过依然很值，想想一张专辑的钱就可以听一个月。</p>

<p>虽说经过这么长时间的发展，Apple Music 依然可以说做得很烂，我在一年前的一篇文章（<a href="http://forrestchang.github.io/14824082548997.html">《Apple Music，古典音乐，阅读》</a>）中已经吐槽过了，除了网络问题有了明显改善之外，其他的并没有太大的改进。以至于现在每年的 WWDC 最期待的不是发布什么新产品，而是 Apple Music 有什么大的改进，加了些什么功能。</p>

<p>我在 V2EX 上也发过<a href="https://www.v2ex.com/t/336425">一篇帖子</a>吐槽过 Apple Music。</p>

<p>这些问题肯定和 iTunes 的历史因素有关，iTunes 本身就是作为一个音乐商店，在没有 Apple Music 之前，听音乐的流程就是从商店中购买数字音乐（或者从 CD 中导入），然后添加到 Library 中，之后对这些音乐做什么事都与商店中的音乐无关了。而到了 Apple Music，它依然延续着之前的流程，当把音乐添加到 Library 中后，你对音乐做出的评分、加心实际上都和云端的数据无关了，所有数据都存放在本地的 <code>iTunes Library.xml</code> 文件中，所以这才会导致一部分音乐明明加过心了，到了手机上一看却是没有加过心的，并且由于存放在本地的原因，云端的数据也不会更新，这也会影响到每天推荐给你的音乐。</p>

<p>Medium 上的一个设计师专门帮 Apple Music 重新设计了一下：<a href="https://medium.com/product-design-ux-ui/apple-music-redesign-part-1-526c4c4c4777#.lopgpvt41">Apple Music Redesign</a>，在我看来，比原版的 Apple Music 好太多。</p>

<p>很难想象，把 iPhone 做得只有 7 mm 厚的科技公司，竟然连 iTunes 中遗留的种种问题也解决不好。</p>

<h2 id="toc_3">听什么</h2>

<p>我并不打算讲太多「听什么」的内容，音乐本来就是一个很个人的事情，但是，音乐真的没有好坏吗？实际上，Apple Music 与网易云一个很大的不同点就是，前者有意得引导你听，而后者是根据你听歌的记录推荐相似的（尽管并不准）歌曲。</p>

<p>相比较网易云的每日推荐，Apple Music 只有一个最爱精选（My Favorites Mix），里面有很多你之前就已经喜欢的歌，每周更新一次。而更多的每天推荐是类似「朴树：音乐灵感」、「古典音乐：混音和改编歌曲」这样的人工手动编辑的歌单，而一般这样的歌单都会附带编辑的一些评语，让你能够大体得了解这张歌单内容，比如今天推荐给我的「古典音乐：混音和改编歌曲」：</p>

<blockquote>
<p>古典樂的經典旋律恆久不變，但同樣的旋律放在此歌單中卻可讓你帶來驚喜！耳熟能詳的柴可夫斯基、韋瓦第等大師作品，換上電子工程師 Max Richer、CFCF 及 DJ Spooky 的混音和改編，令幾百年前的作品添上時代感，即使充滿實驗性和玩味，趣味滿分。</p>
</blockquote>

<p>相比没有目的、仅仅根据自己的喜好乱听，这种引导的方式会慢慢影响你的音乐品味。</p>

<p>另一方面，它还会每天给你推荐不一样的专辑，比如我喜欢听 Imagine Dragons，它今天就给我基于此推荐了《An Awesome Wave》、《Skying》、《Megalithic Symphony》等专辑。</p>

<p>快餐音乐时代，很多歌曲单独从专辑中拿出来听也不会有什么问题，但是按照专辑来听，依然是严肃欣赏音乐的唯一方式。</p>

<h2 id="toc_4">怎么听</h2>

<p>用过两种方法。</p>

<p>1）类似于 Spotify，添加到 Library 的歌曲就算是你想以后继续听的，「加心」的行为只是用来作为推荐的参考。这种方式就不需要再本地再建一个智能播放列表专门用来过滤加心的歌曲了，因为 Library 中的所有的歌都是你想听的。</p>

<p>2）添加到 Library 中只是作为一个「稍后听」的过程，一般这种情况是按照专辑来添加到 Library 中，然后把这张专辑从头到尾（或者以你喜欢的方式）听一遍，把喜欢的歌加心，并给歌曲评分（可选），然后建立智能播放列表过滤出加心的歌，例如，我除了有一个 「Favorites」 歌单（自动更新 Library 中加心的歌曲），还有一个「古典精选」歌单，其中内容是类型为「Classical」并且已经加心了的歌曲。智能播放列表可以使用很复杂的过滤器。这种听歌方式也是现在我用的，这其实和之前在 iTunes Store 上购买音乐再听并没有什么区别，除了改成了订阅的方式并且附带了推荐功能。</p>

<p>不过听音乐这种事各有各的方法，这里也仅仅是提供参考。</p>

<h2 id="toc_5">一些辅助工具</h2>

<p>其实写到这里基本已经写完了。如果你不是一个强迫症、数据控、偏执狂或是一个完美主义者，最后这部分并没有什么太多帮助。</p>

<p>我使用 <a href="https://www.last.fm">last.fm</a> 来记录自己听了什么，Mac 上使用的是官方的 Last.fm Scrobbler 这个软件，不过它只能记录离线的歌曲，对于 Radio 就无能为力了，所以我辅助 <a href="http://bowtieapp.com/">Bowtie</a> 这个小软件来记录，为了防止重复记录，需要把 Last.fm Scrobbler 中的 Enable Scrobbling 选项关闭。</p>

<p>记录数据可以让你更好得知道平常的音乐喜好，以及某张专辑、某首歌、某个艺人听了多少次等等。并且 last.fm 提供通用的 API 来方便导出这些数据，说不定以后有什么用。</p>

<p>过去一周我的听歌记录可以在 <a href="https://www.last.fm/user/Tisoga/listening-report/week">这里</a> 看到。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[换了一个新地方写东西]]></title>
    <link href="http://forrestchang.com/14878992387553.html"/>
    <updated>2017-02-24T09:20:38+08:00</updated>
    <id>http://forrestchang.com/14878992387553.html</id>
    <content type="html">
<![CDATA[<p>现在这个博客只写技术相关的内容，其他的随笔都写在<a href="https://medium.com/@Tisoga">新博客</a>里，Medium 是被大陆屏蔽的，所以请自备梯子。另外一些比较私人的笔记——例如「Week Review」系列就不发表在互联网上了。</p>

<p>至于原因，单纯得觉得 Medium 上的衬线字体很好看。<del>如果需要魔改这个博客的话，还是挺麻烦的，自己目前的前端知识还处于未入门的水平，所以就不折腾了。</del>结果我还是魔改了，现在风格比较简洁了，照着 <a href="https://github.com/lepture/yue.css">yue.css</a> 改的。</p>

<p>既然重新换了一个主题，就不换地方写了……</p>

<p>主题的代码放在 <a href="https://github.com/forrestchang/Cuckoo">GitHub</a> 上，完全是新手的作品，所以还是不要 star 了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017 Week 1 Review]]></title>
    <link href="http://forrestchang.com/14832795759469.html"/>
    <updated>2017-01-01T22:06:15+08:00</updated>
    <id>http://forrestchang.com/14832795759469.html</id>
    <content type="html">
<![CDATA[<p>今天是元旦，因为在 Calendar 中把今天归到 2017 年的第一周里了，所以就按照上面所写的把这周当做第一周吧。</p>

<p>这周结束了在中软的课程设计实训，以前总嫌弃小渔村破，现在回来才知道还是小渔村好啊。课程设计实训的内容是用 Java 写一个点餐系统，一个小组只需要做一份就可以了，不过几乎所有人都不知道 Git 是个什么东西，小组合作还是用的 U 盘拷贝代码，所以代码质量可想而知了，本组的其他人都比较厉害，索性我就抱大腿划水了，什么也没有参与，代码也没有写一行。</p>

<p>不过虽说没有写课程设计的项目，但还是有写代码的。这周把两个月前参加 HACKxFDU 的项目拿出来用 Python 3 重写了一遍。项目的地址：<a href="https://github.com/forrestchang/Neutron">Neutron</a>，当初我们考虑做 Neutron 的时候是想把它做成一个通用的智能家居语音终端的，类似于 Amazon 的 Echo，只要提供第三方的 API，就能轻松集成到 Neutron 来，但是实际上碍于 Hackathon 的时间限制，只是完成了一个简单的 Demo，完全没有拓展性。本来这个项目参加完 Hackathon 之后就没有管了，不过最近看到 Facebook CEO 扎克伯格写了一个 Jarvis，觉得和之前做的东西很像（当然还是差远了，基本我们做的东西就是用别人的 API），所以又掏出来拿 Python 3.5 重写了一遍。现在在 <a href="https://github.com/forrestchang/neutron/tree/develop">develop</a> 分支基本上把框架搭建好了，最底层是和 API 交互的 layer 层，这一层需要为每个 API 写特定的代码，其上是抽象的 handler 层，提供通用的接口，抽象 layer 层的操作：例如语音控制模块、AI 模块等，这一层上还可能包裹一层特定的 wrapper，例如对特定的 message 做语义分析。通过配置文件来选择使用哪个 layer 以及配置 layer 的内容（key 等内容），开始的时候打算用 json 来做配置文件的，后来看了一下还有 yaml 这种更加简洁的配置文件，所以打算换成 yaml 的。目前这个项目还有很多内容要写的，比如特定的 layer，都需要更具不同的 API 写特定的代码，这一点上我参考的 <a href="https://github.com/syl20bnr/spacemacs">Spacemacs</a> 的方法。</p>

<p>这周在中软那边的宿舍里面把08版的《射雕英雄传》看完了，虽然槽点挺多的（特效、台词、演技），但是还是看得很欢乐，林依晨的黄蓉甚是喜欢。记得以前应该是看过朱茵版的黄蓉的，不过时间太久远了，已经记不太清了。小说倒没有读完，还是看剧比较快啊。看完后好长一段时间里面都觉得特别空虚，总感觉少了些什么。这种孤独感几乎在每次看完某部小说和电视剧后都会有（电影倒没有这种感觉，可能时间太短了），总觉得还沉浸在别人的故事里，可惜别人的故事已经结束，不得不回到现实中来。想起席慕蓉的一句话『在别人的故事里，留着自己的泪』 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 。</p>

<hr/>

<p>就借着这篇博客顺便说说 17 年的计划吧。</p>

<ol>
<li>学习一门新语言：14年学了 C、Scheme，15年学了 Java、Python，16年学了 Swift，再加上各种用过但是不熟的语言，也有好多个了。现在主力开发语言是 Python，17年打算学习 一下 JavaScript，这门 GitHub 上最火的语言，不会都不好意思说自己是程序员。也不用学到多么深，只求达到入门水平。</li>
<li>Python 水平达到 professional，用了接近两年的 Python，但是水平也没有长进多少，今年打算深入一下 Python，多写一些项目。</li>
<li>去周边国家玩一次，其实挺想去尼泊尔的，不知道今年有没有时间。不过即使不出国，也要多出去走走，一个人的旅行。</li>
</ol>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>席慕蓉的《戏子》，用在这里并不完全准确。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 52 Review]]></title>
    <link href="http://forrestchang.com/14827163208652.html"/>
    <updated>2016-12-26T09:38:40+08:00</updated>
    <id>http://forrestchang.com/14827163208652.html</id>
    <content type="html">
<![CDATA[<p>2016 年最后一周（实际上还有6天，不过那一周就算到 2017 年第一周吧）。</p>

<ul>
<li><strong>编程</strong>：这周在看《Python 网络数据采集》，以前虽然也用过爬虫，但是毕竟没有系统地学过，所以还是找了一本书来看。但是说实话，这本书写得并不是很好，不知道是写书时间的原因还是什么，挺多语法错误的，而且代码的风格很差（完全不符合 PEP8 标准）。内容也比较浅，基本上都是之前已经知道了的东西，所以收获也不是很多，（下一篇的博客可以来写一写怎么写一个高效的爬虫）。面试的事情作废了，1）看了一下他们做的产品，感觉不是自己想要做的东西；2）开出的薪资太低，up to 2k（其实主要是薪资太低了，每天要往返金石滩和大连市，太累了）。所以还是好好学习准备明年的暑期实习吧。另外 GSoC 也应该放上日程了，即使有申请不上的可能，还是要试一试的。</li>
<li><strong>阅读</strong>：开始读金庸的《射雕英雄传》，以前上学的时候一直被家里教导不要沉迷武侠小说，所以一直没有读过金庸和古龙（然而那些时间都用来看网文玄幻了……）。最近读来还是觉得很有意思，作为实训的时候消遣很不错（主要没有网）。</li>
<li><strong>生活</strong>：这周五就可以离开这鬼地方了，见识过外包公司的情况后决定以后肯定是不会进这种公司的。在公司里实训也一直没有写代码，本来打算用 Python 实现一下实训的题目的，但是老师说不允许，这也没什么办法，索性就划水吧。</li>
<li><strong>博客</strong>：可以看到，我博客又换样子了。用 Emacs 来写博客还是太麻烦了一些，而且 render 的速度实在是太感人，本地的 org 文件多了之后好几次 render 的时候卡住。现在这个博客是 Mweb 自带的 generator 生成的，就是主题不怎么好看，其他的都很方便。奈何自己的前端知识太渣，改了半天也没有改成自己想要的样子，所以还是凑合着先用吧。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐系统笔记]]></title>
    <link href="http://forrestchang.com/14824086421976.html"/>
    <updated>2016-12-22T20:10:42+08:00</updated>
    <id>http://forrestchang.com/14824086421976.html</id>
    <content type="html">
<![CDATA[<p>开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。</p>

<p>这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。</p>

<h2 id="toc_0">基于用户的协同过滤</h2>

<h3 id="toc_1">协同过滤（Collaborative filtering）</h3>

<p>一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。</p>

<h3 id="toc_2">测试数据集</h3>

<p>为了演示一些算法，我们需要从<a href="http://grouplens.org/datasets/movielens/">这个网站</a>上下载一份数据集。这里因为是作为演示使用，所以只需要下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>这一份简单的数据集就可以了。</p>

<h3 id="toc_3">相似度计算</h3>

<p>在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的<strong>相似度评价值</strong>。</p>

<h4 id="toc_4">欧几里德距离评价（Euclidean Distance Score）</h4>

<p>欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作\((p_1, p_2, p_3, p_4, ...)\)和\((q_1, q_2, q_3, q_4, ...)\)，则欧几里德距离的计算公式为：</p>

<p>\[<br/>
\sqrt{((p_1-q_1)^2+(p_2-q_2)^2+...+(p_n-q_n)^2)} = \sqrt{(\sum_{i=1}^n(p_i-q_i)^2)}<br/>
\]</p>

<p>创建 <code>recommendations.py</code>。</p>

<p>用代码表示：</p>

<pre><code class="language-python">from math import sqrt

# 返回一个有关 person1 与 person2 的基于距离的相似度评价
def sim_distance(prefs, person1, person2):
    # 得到 shared_items 的列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
        shared_items[item] = 1
    
    # 如果两者没有共同之处，则返回 0
    if len(shared_items) == 0:
        return 0
        
    # 计算所有差值的平方和
    sum_of_squares = sum([pow(prefs[person1][item]-prefs[person2][item], 2)for item in prefs[person1] if item in prefs[person2]])
    
    return 1 / (1 + sqrt(sum_of_squares))
</code></pre>

<p>欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。</p>

<p>好了，现在我们需要先将数据读取进来，在 <code>recommendations.py</code> 中添加如下代码:</p>

<pre><code class="language-python">def loadMovieLens(path=&#39;data&#39;):
    movies = {}
    for line in open(path + &#39;/movies.csv&#39;):
        (id, title) = line.split(&#39;,&#39;)[0:2]
        movies[id] = title

    prefs = {}
    for line in open(path+&#39;/ratings.csv&#39;):
        (user, movieid, rating, ts) = line.split(&#39;,&#39;)
        prefs.setdefault(user, {})
        prefs[user][movies[movieid]] = float(rating)
    return prefs
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; import recommendations
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 比较 10 号用户 和 20 号用户的相似度评价
&gt;&gt;&gt; recommendations.sim_distance(prefs, &#39;10&#39;, &#39;20&#39;)
0.23371479611805132
</code></pre>

<h4 id="toc_5">皮尔逊相关系数（Pearson Correlation Coefficient）</h4>

<p>皮尔逊相关系数是一种度量两个变量间相关程度的方法，它是一个介于 1 和 -1 之间的值，其中，1 表示变量完全正相关，0 表示无关， -1 则表示完全负相关（一个变量的值越大，则另一个变量的值反而会越小）。</p>

<p>计算公式：</p>

<p>\[<br/>
r = \frac{\sum{XY}-\frac{\sum X \sum Y}{N}}{\sqrt{(\sum X^2 - \frac{(\sum X)^2}{N})(\sum Y^2 - \frac{(\sum Y)^2}{N})}}<br/>
\]</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def sim_pearson(prefs, person1, person2):
      # 得到双方都曾评价过的物品列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            shared_items[item] = 1
      # 得到物品列表元素的个数
    n = len(shared_items)

      # 如果两者没有共同元素，则返回0
    if n == 0:
        return 0

      # 计算 person1 和 person2 的皮尔逊相关系数
    sumxy = sum([prefs[person1][item] * prefs[person2][item]
                for item in shared_items])
    sumx = sum([prefs[person1][item] for item in shared_items])
    sumy = sum([prefs[person2][item] for item in shared_items])
    sumx2 = sum([prefs[person1][item] ** 2 for item in shared_items])
    sumy2 = sum([prefs[person2][item] ** 2 for item in shared_items])

    zahler = sumxy - (sumx * sumy) / n
    nenner = sqrt((sumx2 - (sumx ** 2) / n) * (sumy2 - (sumy ** 2) / n))
    if nenner == 0:
        return 0
    r = zahler / nenner

    return r
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.sim_pearson(prefs, &#39;10&#39;, &#39;20&#39;)
0.4908806936738162
</code></pre>

<p>可以看到和上面使用欧几里德距离评价计算出来的相似度是不一样的。</p>

<h4 id="toc_6">关于该使用哪一种相似性度量方法</h4>

<p>除了这两种计算相似度的方法，实际上还有许多别的计算相似度的算法，例如<strong>Tanimoto 分值</strong>。使用哪一种方法，完全取决于具体的应用。</p>

<p>下面的代码中，将使用一个通用的相似性函数来计算相似度，只要它满足以下条件：拥有同样的函数签名，以一个浮点数作为返回值，其数值越大代表相似度越大。</p>

<h3 id="toc_7">寻找相似的用户</h3>

<p>既然我们已经有了对两个人进行比较的函数，下面我们就可以编写，根据指定人员对每个人进行打分，并找出最接近的匹配结果了。</p>

<pre><code class="language-python"># 从反映偏好的字典中返回最佳匹配者
# 返回结果的个数和相似度函数均为可选参数
def topMatches(prefs, person, n=5, similarity=sim_pearson):
    scores = [(similarity(prefs, person, other), other) for other in prefs if other != person]
    
    # 对列表进行排序，评价值最高者排在最前面
    scores.sort(reverse=True)
    return scores[:n]
</code></pre>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 与 40 号用户相似的 10 个用户
&gt;&gt;&gt; recommendations.topMatches(prefs, &#39;40&#39;, n=10)
[(1.0, &#39;63&#39;),
 (1.0, &#39;582&#39;),
 (1.0, &#39;326&#39;),
 (1.0, &#39;260&#39;),
 (1.0, &#39;220&#39;),
 (1.0, &#39;198&#39;),
 (1.0, &#39;153&#39;),
 (1.0, &#39;116&#39;),
 (0.9999999999999947, &#39;474&#39;),
 (0.9999999999999947, &#39;215&#39;)]
</code></pre>

<h3 id="toc_8">推荐物品</h3>

<p>有的时候我们可能不需要寻找相似的用户，例如在购物网站中，我们需要的是一份可能会想要购买的物品列表，一种方法是从相似的用户所购买的物品列表中选出没有购买的，但是这种方法不确定的因素太多，例如可能相似用户还未购买某些物品，而这些物品恰恰就是我们所需要的。</p>

<p>为了解决上面的问题，我们需要通过一个经过加权的评价值来为影片打分，评论者的评分结果因此而形成了先后的排名。为此，我们需要取得所有其他评论者的评价结果，借此得到相似度之后，再乘以他们为每部影片所给的评价值。</p>

<p>以以下数据集为例：</p>

<pre><code>{&#39;Lisa Rose&#39;: {&#39;Lady in the Water&#39;: 2.5,
               &#39;Snakes on a Plane&#39;: 3.5,
               &#39;Just My Luck&#39;: 3.0,
               &#39;Superman Returns&#39;: 3.5,
               &#39;You, Me and Dupree&#39;: 2.5,
               &#39;The Night Listener&#39;: 3.0},
 &#39;Gene Seymour&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 1.5,
                  &#39;Superman Returns&#39;: 5.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Michael Phillips&#39;: {&#39;Lady in the Water&#39;: 2.5,
                      &#39;Snakes on a Plane&#39;: 3.0,
                      &#39;Superman Returns&#39;: 3.5,
                      &#39;The Night Listener&#39;: 4.0},
 &#39;Claudia Puig&#39;: {&#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 3.0,
                  &#39;The Night Listener&#39;: 4.5,
                  &#39;Superman Returns&#39;: 4.0,
                  &#39;You, Me and Dupree&#39;: 2.5},
 &#39;Mick LaSalle&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 4.0,
                  &#39;Just My Luck&#39;: 2.0,
                  &#39;Superman Returns&#39;: 3.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 2.0},
 &#39;Jack Matthews&#39;: {&#39;Lady in the Water&#39;: 3.0,
                   &#39;Snakes on a Plane&#39;: 4.0,
                   &#39;The Night Listener&#39;: 3.0,
                   &#39;Superman Returns&#39;: 5.0,
                   &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Toby&#39;: {&#39;Snakes on a Plane&#39;: 4.5,
          &#39;You, Me and Dupree&#39;: 1.0,
          &#39;Superman Returns&#39;: 4.0}}
</code></pre>

<p>假设我们需要给 Toby 提供影片推荐，我们可以根据上面的算法得出一张表：</p>

<table>
<thead>
<tr>
<th>评论者</th>
<th>相似度</th>
<th>Night</th>
<th>S.xNight</th>
<th>Lady</th>
<th>S.xLady</th>
<th>Luck</th>
<th>S.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Rose</td>
<td>0.99</td>
<td>3.0</td>
<td>2.97</td>
<td>2.5</td>
<td>2.48</td>
<td>3.0</td>
<td>2.97</td>
</tr>
<tr>
<td>Seymour</td>
<td>0.38</td>
<td>3.0</td>
<td>1.14</td>
<td>3.0</td>
<td>1.14</td>
<td>1.5</td>
<td>0.57</td>
</tr>
<tr>
<td>Puig</td>
<td>0.89</td>
<td>4.5</td>
<td>4.02</td>
<td></td>
<td></td>
<td>3.0</td>
<td>2.68</td>
</tr>
<tr>
<td>LaSalle</td>
<td>0.92</td>
<td>3.0</td>
<td>2.77</td>
<td>3.0</td>
<td>2.77</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Matthews</td>
<td>0.66</td>
<td>3.0</td>
<td>1.99</td>
<td>3.0</td>
<td>1.99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td></td>
<td>12.89</td>
<td></td>
<td>8.38</td>
<td></td>
<td>8.07</td>
</tr>
<tr>
<td>Sim.Sum</td>
<td></td>
<td></td>
<td>3.84</td>
<td></td>
<td>2.95</td>
<td></td>
<td>3.18</td>
</tr>
<tr>
<td>总计/Sim.Sum</td>
<td></td>
<td></td>
<td>3.35</td>
<td></td>
<td>2.83</td>
<td></td>
<td>2.53</td>
</tr>
</tbody>
</table>

<p>表中列出来每位评论者的相关度评价值，以及他们对三部影片的评分情况。以 S.x 打头的列给出了乘以评价值之后的相似度。如此一来，相比于与我们不相近的人，那些与我们相近的人将会对整体评价拥有更多的贡献。总计所有加权评价值的和。</p>

<p>我们也可以选择利用总计值来计算排名，但是这其中有一个问题，一部受更多人评论的影片会对结果产生很大影响。为了修正这一问题，我们需要除以表总名为 Sim.Sum 的那一行，它代表了<strong>所有对这部电影有过评论的评论者的相似度之和</strong>。对于影片《Lady in the Water》来说，Puig 并未做过评论，所以我们将这部影片的总计值除以所有其他人的相似度之和。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python"># 利用所有其他人评价值得加权平均，为某人提供建议
def getRecommendations(prefs, person, similarity=sim_pearson):
    totals = {}
    simSums = {}
    for other in prefs:
        # 不要和自己做比较
        if other == person:
            continue
        sim = similarity(prefs, person, other)
        
        # 忽略评价值为零或者小于零的情况
        if sim &lt;= 0:
            continue
            
        for item in prefs[other]:
            # 只对自己还未看过的影片进行评价
            if item not in prefs[person] or prefs[person][item] == 0:
                # 相似度*评价值
                totals.setdefault(item, 0)
                totals[item] += prefs[other][item] * sim
                # 相似度之和
                simSums.setdefault(item, 0)
                simSums[item] += sim
        
        # 建立一个归一化的列表
        rankings = [(total / simSums[item], item) for item, total in totals.items()]
        
        # 返回经过排序的列表
        rankings.sort(reverse=True)
        return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; relaod(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.getRecommendations(prefs, &#39;10&#39;)[:20]
[(5.000000000000001,
  &#39;The Slipper and the Rose: The Story of Cinderella (1976)&#39;),
 (5.000000000000001, &#39;Hands on a Hard Body (1996)&#39;),
 (5.000000000000001, &#39;For the Birds (2000)&#39;),
 (5.000000000000001, &#39;Diva (1981)&#39;),
 (5.0, &#39;Zorba the Greek (Alexis Zorbas) (1964)&#39;),
 (5.0, &#39;Zerophilia (2005)&#39;),
 (5.0, &#39;Zelary (2003)&#39;),
 (5.0, &#39;Z Channel: A Magnificent Obsession (2004)&#39;),
 (5.0, &#39;Yossi (Ha-Sippur Shel Yossi) (2012)&#39;),
 (5.0, &#39;World of Tomorrow (2015)&#39;),
 (5.0, &#39;Woody Allen: A Documentary (2012)&#39;),
 (5.0, &#39;Woman on Top (2000)&#39;),
 (5.0, &#39;Without a Clue (1988)&#39;),
 (5.0, &#39;Withnail &amp; I (1987)&#39;),
 (5.0, &#39;Wild Zero (2000)&#39;),
 (5.0, &#39;War Room (2015)&#39;),
 (5.0, &#39;Walker (1987)&#39;),
 (5.0, &#39;Voices from the List (2004)&#39;),
 (5.0, &#39;Videodrome (1983)&#39;),
 (5.0, &#39;Victoria (2015)&#39;)]
</code></pre>

<h3 id="toc_9">匹配商品</h3>

<p>现在我们已经可以为指定人员寻找品味相近的用户，以及如何向其推荐商品。假如我们想要了解哪些物品是相近的，那又该如何呢？</p>

<p>在我们浏览 Amazon 的时候，经常会看到页面底部会推荐与当前浏览的物品相似的商品。这种情况，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，这和我们之前用来计算人与人之间的相似度是一样的，只需要把人和物品相互调换就行了。</p>

<p>我们来编写这个翻转字典的函数：</p>

<pre><code class="language-python">def transformPrefs(prefs):
    result = {}
    for person in prefs:
        for item in prefs[person]:
            result.setdefault[item, {}]
            # 将物品和人对调
            result[item][person] = prefs[person][item]
    return result
</code></pre>

<p>有了这个方法之后，我们就可以复用之前所写的方法了。</p>

<p>在 ipython 环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; load(recommendations)
&gt;&gt;&gt; movies = recommendations.transformPrefs()
&gt;&gt;&gt; recommendations.topMatches(movies, &#39;For the Birds (2000)&#39;)
[(1.000000000000016, &#39;&quot;Silence of the Lambs&#39;),
 (1.0, &#39;World War Z (2013)&#39;),
 (1.0, &#39;Wallace &amp; Gromit in The Curse of the Were-Rabbit (2005)&#39;),
 (1.0, &#39;Tron: Legacy (2010)&#39;),
 (1.0, &#39;Transcendence (2014)&#39;)]
</code></pre>

<p>我们还可以为影片推荐评论者：</p>

<pre><code class="language-python">&gt;&gt;&gt; recommendations.getRecommendations(movies, &#39;For the Birds (2000)&#39;)[:20]
[(5.0, &#39;668&#39;),
 (5.0, &#39;618&#39;),
 (5.0, &#39;543&#39;),
 (5.0, &#39;541&#39;),
 (5.0, &#39;536&#39;),
 (5.0, &#39;52&#39;),
 (5.0, &#39;464&#39;),
 (5.0, &#39;46&#39;),
 (5.0, &#39;409&#39;),
 (5.0, &#39;357&#39;),
 (5.0, &#39;308&#39;),
 (5.0, &#39;296&#39;),
 (5.0, &#39;29&#39;),
 (5.0, &#39;28&#39;),
 (5.0, &#39;197&#39;),
 (5.0, &#39;196&#39;),
 (5.0, &#39;190&#39;),
 (5.0, &#39;131&#39;),
 (5.0, &#39;113&#39;),
 (4.999999999999999, &#39;465&#39;)]
</code></pre>

<h2 id="toc_10">基于物品的协同过滤</h2>

<p>当前所完成的推荐系统，要求我们使用每一位用户的全部评分来构建数据集，这种方法对于小规模的数据集是没有问题的，但是对于像 Amazon 这样有着上百万用户和商品的大型网站而言，讲一个用户同其他所有用户进行比较，然后再对每位用户评过分的商品进行比较，时间花费上是巨大的。</p>

<p>目前为止我们所使用的技术被称为<strong>基于用户的协同过滤</strong>（user-based collaborative filtering）。除此以外，还有一种可供选择的方法被称为<strong>基于物品的协同过滤</strong>（item-based collaborative filtering）。在拥有大量数据集的情况下，基于物品的协同过滤能够得出更好的结论，而且它允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们所要的结果。</p>

<p>基于物品的协同过滤总体思路就是为每件物品预先计算好最为相近的其他物品。然后，当我们想为某位用户提供推荐的时候，就可以查看他曾经评过分的物品，并从中选出排名靠前者，再构造一个加权列表，其中包含了与这些选中物品最相近的其他物品。此处最显著的区别在于，尽管第一步要求我们检查所有的数据，但是物品间的比较不会像用户间比较那么频繁变化。</p>

<h3 id="toc_11">构造物品比较数据集</h3>

<p>为了对物品进行比较，我们要做的第一件事就是编写一个函数，构造一个包含相近物品的完整数据集。构建完数据集之后，我们就可以在需要的时候重复使用它。</p>

<p>将下面代码添加到 <code>recommendations.py</code> 中：</p>

<pre><code class="language-python">def calculateSimilarItems(prefs, n=10):
    # 建立字典，以给出与这些物品最为相近的其他物品
    result = {}
    
    # 以物品为中心最偏好矩阵进行倒置处理
    itemPrefs = transformPrefs(prefs)
    c = 0
    for item in itemPrefs:
        # 针对大数据集更新状态变量
        c += 1
        if c % 100 == 0:
            print &quot;%d / %d&quot; % (c, len(itemPrefs))
        scores = tomMatchs(itemPrefs, item, n=n, similarity=sim_pearson)
        result[item] = scores
    return result
</code></pre>

<p>该函数首先利用了此前定义过得 <code>transformPrefs</code> 函数，对反映评价的字典进行倒置处理，从而得到一个有关物品及其用户评价情况的列表，然后程序又循环遍历每项物品，并将转换了的字典传入 <code>tomMatches</code> 函数中，求得最为相近的物品及其相似度评价值，最后，它建立并返回了一个包含物品及其最相近物品列表的字典。</p>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; itemsim = recommendations.calculateSimilarItems(prefs)
100 / 8963
200 / 8963
300 / 8963
400 / 8963
500 / 8963
600 / 8963
700 / 8963
800 / 8963
900 / 8963
1000 / 8963
1100 / 8963
1200 / 8963
1300 / 8963
1400 / 8963
1500 / 8963
1600 / 8963
1700 / 8963
1800 / 8963
1900 / 8963
...
</code></pre>

<p>首次运行需要等待一段时间进行计算。</p>

<p>只有频繁执行该函数，才能令物品的相似度不至于过期。通常我们需要在用户基数和评分数量不是很大的时候执行这一函数，但是随着用户数量的不断增长，物品间的相似度评价通常会变得越来越稳定。</p>

<h3 id="toc_12">获得推荐</h3>

<p>现在，我们可以利用反映物品相似度的字典来给出推荐了，我们可以去到用户评价过得所有物品，并找出其相近的物品，根据相似度对其进行加权。</p>

<p>下表给出了利用基于物品的方法寻找推荐的过程，所用到的数据可以在上面<strong>推荐物品</strong>一节中找到。</p>

<p>为 Toby 提供基于物品的推荐：</p>

<table>
<thead>
<tr>
<th>影片</th>
<th>评分</th>
<th>Night</th>
<th>R.xNight</th>
<th>Lady</th>
<th>R.xLady</th>
<th>Luck</th>
<th>R.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Snakes</td>
<td>4.5</td>
<td>0.182</td>
<td>0.818</td>
<td>0.222</td>
<td>0.999</td>
<td>0.105</td>
<td>0.474</td>
</tr>
<tr>
<td>Superman</td>
<td>4.0</td>
<td>0.103</td>
<td>0.412</td>
<td>0.091</td>
<td>0.363</td>
<td>0.065</td>
<td>0.258</td>
</tr>
<tr>
<td>Dupree</td>
<td>1.0</td>
<td>0.148</td>
<td>0.148</td>
<td>0.4</td>
<td>0.4</td>
<td>0.182</td>
<td>0.182</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>0.433</td>
<td>1.378</td>
<td>0.713</td>
<td>1.762</td>
<td>0.352</td>
<td>0.914</td>
</tr>
<tr>
<td>归一化结果</td>
<td></td>
<td></td>
<td>3.183</td>
<td></td>
<td>2.473</td>
<td></td>
<td>2.598</td>
</tr>
</tbody>
</table>

<p>此处每一行都列出了一部我们曾经观看过的影片，以及对该片的个人评价。对于每一部我们还未曾看过的影片，相应有一列会指出它与已观看影片的相似程度。以 R.x 打头的列给出了我们队影片的评价值乘以相似度之后的结果。</p>

<p>总计一行给出了每部影片相似度评价值的总和以及 R.x 列的总和，为了预测我们对每一部影片的评分情况，只要将 R.x 列的总计值除以相似度一列的总计值即可。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def getRecommendedItems(prefs, itemMatch, user):
    userRatings = prefs[user]
    scores = {}
    totlaSim = {}
    
    # 循环遍历由当前用户评分的物品
    for (item, rating) in userRatings.items():
        
        # 循环遍历与当前物品相近的物品
        for (similarity, item2) in itemMatch[item]:
        
            # 如果该用户已经对当前物品做过评价，则将其忽略
            if item2 in userRatings:
                continue
            
            # 评价值与相似度加权之和
            scores.setdefault(item2, 0)
            scores[item2] += similarity * rating
            
            # 全部相似度之和
            totalSim.setdefault(item2, 0)
            totalSim[item2] += similarity
            
    # 将每个合计值除以加权和，求出平均值
    rankings = [(score / totalSim[item], item) for item, score in scores.items()]
    
    # 按最高值到最低值的顺序，返回评分结果
    rankings.sort(reverse=True)
    return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; recommendations.getRecommendedItems(prefs, itemsim, &#39;20&#39;)[:10]
[(5.0, &#39;Zoot Suit (1981)&#39;),
 (5.0, &#39;Zoolander (2001)&#39;),
 (5.0, &#39;Zack and Miri Make a Porno (2008)&#39;),
 (5.0, &quot;You&#39;ve Got Mail (1998)&quot;),
 (5.0, &#39;X-Men: The Last Stand (2006)&#39;),
 (5.0, &#39;X-Men: Apocalypse (2016)&#39;),
 (5.0, &#39;X-Men (2000)&#39;),
 (5.0, &quot;Von Ryan&#39;s Express (1965)&quot;),
 (4.75, &#39;Willow (1988)&#39;),
 (4.75, &quot;White Men Can&#39;t Jump (1992)&quot;)]
</code></pre>

<h2 id="toc_13">基于用户进行过滤还是基于物品进行过滤</h2>

<p>在数据集大小上，基于物品进行过滤的方式要比基于用户进行过滤更快；在数据的稀疏程度上，稀疏的数据集使用基于物品的过滤方法更优，而对于秘密集的数据集而言，两者的效果几乎一样。</p>

<p>基于用户的过滤方法更加易于实现，而且无需额外步骤，因此它通常更适用于规模较小的变化非常频繁的数据集。在一些应用中，告诉用户还有哪些人与自己有着相近偏好是有一定价值的——也许对于一个购物网站而言，我们并不想这么做，但是对于一个音乐分享类或者电影评分类网站而言，这种潜在的需求却是存在的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 51 Review]]></title>
    <link href="http://forrestchang.com/14824103542982.html"/>
    <updated>2016-12-22T20:39:14+08:00</updated>
    <id>http://forrestchang.com/14824103542982.html</id>
    <content type="html">
<![CDATA[<p>看了一下日历，上一周是 2016 年的倒数第二周了（写这篇文章的时候已经是 52 周了），换了新博客之后就一直没有再写过 Week Review，这其中虽然有一些外部的因素，但大抵上还是不想写。</p>

<p>上周学校组织来中软做课程设计，所以这些天一直待在中软的培训中心里，课程设计的题目是一个点餐的 Web 应用，用 Java 开发，因为并不打算从事 Java，所以也并没有怎么听，大部分时间都是在自己看书和写自己的 Project。不过要吐槽一下这边的环境，宿舍除了床什么也没有，所以晚上回去什么都干不了，只能坐在床上看看电影，最不能忍的是网都没有……学校送来培训中心的这种做法我是很不认同的，好好的大学为什么要搞成职业教育呢？</p>

<p>最近找到了大连的一家做 Python Web 的 start up，联系了一下准备过去面试，不过软件园离学校太远了，估计面过了也不会去吧。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 46 Review]]></title>
    <link href="http://forrestchang.com/14824081615573.html"/>
    <updated>2016-12-22T20:02:41+08:00</updated>
    <id>http://forrestchang.com/14824081615573.html</id>
    <content type="html">
<![CDATA[<p>编程学习方面，不完全看完了《利用 Python 进行数据分析》，感觉光看没有进行练习的话很难一次记住那么多用法，所以这本书最好还是最 NumPy、Pandas 这几个库用过一段时间之后再看。之后开始看《集体智慧编程》，目前才看了两章，内容写得还是挺好的，不过很多代码不是很规范（比如命名、缩进什么的），还有就是可能书已经比较老了，很多例子中使用的 API 已经挂掉了，所以不得不自己找数据集下来测试。不知道别人看书是怎样的，反正我看书不把书中每个例子测试一下就感觉书好像没看过，所以看书的速度还是挺慢的，昨天和今天花了两天的时间把第2章的东西总结了一下，写了篇博客。</p>

<p>朋友说我现在才开始学习机器学习并且想要以此为以后的职业简直在玩火（并且还不打算读研究生的情况下），说得也是，毕竟现在已经大三了，按照道理，应该刷刷题准备下学期的实习面试的。不过既然跳进这个火坑里了，就不能半途而废，至少先学习几个月看看情况再变更计划。如果实在不行，到时候再去做 Web 开发还是可以的。</p>

<p>前几天在登录 iPad 上的 Evernote 的时候，突然提示我登录的设备超过了两台，需要开通会员（之前开通过一年的会员，后来没有续费），总觉得为了这个再开通会员有点不值得，并且之前 Evernote 在 Mac 上使用就有很多诟病，所以打算换 OneNote 了。更新了一下 Mac 上 OneNote，发现竟然支持手写了，果断用用用。不过 OneNote 最开始的字体问题到现在还没有解决……</p>

<p>下周五就可以玩上 Pokemon Moon 了，激动不已，虽然破解党们早已二周目通关……</p>

<p>另外，发现番茄工作法挺好用的，现在也没有什么课了，每天就直接到图书馆里来，打开番茄钟，然后无脑干活就好了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 45 Review]]></title>
    <link href="http://forrestchang.com/14824080993859.html"/>
    <updated>2016-12-22T20:01:39+08:00</updated>
    <id>http://forrestchang.com/14824080993859.html</id>
    <content type="html">
<![CDATA[<p>已经第 45 周了啊，再过 10 周 2016 年就要过去了。今天大连下起了雪，似乎冬天就这么不知不觉得来了，记得上一次下大雪的时候去了一次海边，可惜 Photos 在一次事故中数据全部丢失了。作为一个南方人当初决定来北方的时候其实是对雪有一种很强烈的期待的，不过来了大连之后发现其实这里也不怎么下雪，偶尔下一次的雪也不是很大，这在一定程度上有点令人失望。</p>

<p>上周在读《挪威的森林》这本书，第一次读的时候大概是在初中的时候，当时没看懂里面写的是什么，纯属当做一本小黄书来读的。这次读的时候依旧有好多东西没明白。有一天听着 Thirteen Senses 的专辑猛地读到了 50%，感觉特别压抑，说不出来的压抑，所以就暂时放下了，顺便把翻拍的电影看了一遍，说实话，电影拍得不是很好，剧情的跳跃度有些大了，让没读过小说的人看得莫名其妙。</p>

<p>学习方面感觉上周特别颓废，什么事情都不相干，每天就窝在宿舍里，果然宿舍是一个让人堕落的地方，甚至连门都不想出去了，吃饭全部叫外卖。还好今天周一强迫自己来了图书馆，希望能做些东西吧。</p>

<p>这学期的课程基本结束了，免修了两门课，除了上机可能会去一下，其他时间都是空余的了，有大块的时间可以用来做自己想要做额事情了。</p>

<p>看了一眼窗外，雪似乎已经停了，耳机里放着坂本龙一的「A Flower Is Not A Flower」。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 44 Review]]></title>
    <link href="http://forrestchang.com/14824080414983.html"/>
    <updated>2016-12-22T20:00:41+08:00</updated>
    <id>http://forrestchang.com/14824080414983.html</id>
    <content type="html">
<![CDATA[<ul>
<li><strong>Coding</strong> - 本周主要在看《利用 Python 进行数据分析》，大概看了有一半的样子，下周应该能够结束掉。接下来的打算可能是先不看书，而是把<a href="https://www.quora.com/What-should-I-learn-in-data-science-in-100-hours">What should I learn in data science in 100 hours?</a>这个问题下面的回答内容实践一遍。</li>
<li><strong>Japanese</strong> - 日语已经落下好久了，大概还有1个月的时间考试，虽然只是报了一个三级试试水，但是不去考试总感觉白费报名费了，当初以为交了钱就会好好学，然而想多了。另外，日语现在并不是刚需的语言，之前决定学习是为了玩游戏，现在基本想玩的游戏都出了中文，《怪物猎人》玩了几个小时，发现不适合我这种手残。所以到底要不要继续学习日语还有待商榷……</li>
<li><strong>English</strong> - 英语自从到了大学以来就没有刻意地学过，除了准备托福的那段时间背了一些单词，然后其他都是直接用，导致了现在听说读写水平参差不齐，听力和阅读还算可以（至少能听懂和读懂技术相关的内容），口语基本就是没有说过，写作也没怎么练过，写一些基本的句子也要查语法（靠语感来写作结果就是一堆语法错……）。相比较日语来说，英语还算一个刚需的技能，尤其是写作和口语部分，还需要加强训练。接下来的一段时间内也会把英语学习提到日程上来，暂时的计划还没有想好，先加到 TODO 中。</li>
<li><strong>Reading</strong> - 发现这学期都没有读过几本书，上学期还能保持基本每周都读一本书，现在 Kindle 都吃灰了。下周先把《挪威的森林》这本书看完吧……</li>
<li><strong>Game</strong> - 等《精灵宝可梦 日月》发售，还有20天的样子，没有预定，直接买现货或者买下载版吧。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 Python 科学计算环境]]></title>
    <link href="http://forrestchang.com/14824083276745.html"/>
    <updated>2016-12-22T20:05:27+08:00</updated>
    <id>http://forrestchang.com/14824083276745.html</id>
    <content type="html">
<![CDATA[<p>最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。</p>

<h2 id="toc_0">安装虚拟环境</h2>

<p>不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在<a href="http://forrestchang.github.io/2016/07/17/virtualenv-notes/">virtualenv 相关笔记</a>这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用<code>alias</code>），这样就避免每次一打开就输入一长串命令了。</p>

<p>因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。</p>

<p>然后使用以下命令一键安装所需要的库：</p>

<pre><code class="language-shell">sudo pip install numpy pandas matplotlib jupyter scikit-learn
</code></pre>

<p>安装不上的请检查是不是需要翻墙。</p>

<h2 id="toc_1">IPython</h2>

<p>熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。</p>

<h3 id="toc_2">开启 IPython Notebook</h3>

<p>使用以下命令来打开 IPython Notebook：</p>

<pre><code class="language-shell">(ENV2.7)$ jupyter notebook
</code></pre>

<p>这样 server 就启动了，浏览器会自动打开一个目录树。</p>

<p>Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。</p>

<p>然后我们新建一个 IPython Notebook 用作演示：</p>

<p><img src="media/14824083276745/14776647413275.jpg" alt="14776647413275"/></p>

<p><code>In [1]</code> 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 <code>matplotlib</code> 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。</p>

<h3 id="toc_3">内省</h3>

<p>在变量的前面或后面加上一个 <code>?</code> 就可以将有关该对象的一些通用信息显示出来。</p>

<p><img src="media/14824083276745/14776649884990.jpg" alt="14776649884990"/></p>

<p>基本上什么都能看。</p>

<h3 id="toc_4"><code>%run</code> 命令</h3>

<p>使用 <code>%run</code> 可以运行本地的 Python 脚本，并可以在 IPython 中访问脚本中定义的所有变量。</p>

<p>如果想要脚本能够访问 IPython 中的命名空间，可以使用 <code>%run -i</code> 命令。</p>

<h3 id="toc_5">测试代码的执行时间</h3>

<p>使用 <code>%time</code> 和 <code>%timeit</code> 可以用来测试代码的执行时间。</p>

<p><img src="media/14824083276745/14776653395450.jpg" alt="14776653395450"/></p>

<h2 id="toc_6">Example</h2>

<p>下面使用一个具体的例子来演示 IPython Notebook 的使用。</p>

<p>使用到的数据可以在<a href="https://www.ssa.gov/oact/babynames/limits.html">Beyond the Top 1000 Names</a>下载到，这是一份包含1880-2015年每年出生婴儿姓名出现次数的数据表。</p>

<p>由于该数据按年份被分割成了好多文件，所以第一步我们需要把所有数据组装到一个 DataFrame 中去。</p>

<p><img src="media/14824083276745/14776659007521.jpg" alt="14776659007521"/></p>

<p>不知道这些 Python 代码没关系，因为这里只是用来演示 IPython Notebook。</p>

<p>然后我们按照性别和年度统计总出生数：</p>

<p><img src="media/14824083276745/14776660937109.jpg" alt="14776660937109"/></p>

<p>然后绘制出表格：</p>

<p><img src="media/14824083276745/14776661445090.jpg" alt="14776661445090"/></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 Week 42-43 Review]]></title>
    <link href="http://forrestchang.com/14824079755630.html"/>
    <updated>2016-12-22T19:59:35+08:00</updated>
    <id>http://forrestchang.com/14824079755630.html</id>
    <content type="html">
<![CDATA[<p>连续两周没写周总结了，41周的周总结因为涉及到一些私事所以还是删掉了（当然感兴趣的还是可以在我的 repo 里面找到之前的 commit）。</p>

<p>过去两周还是发生了很多事情的，一件一件来说吧。</p>

<p>10.15-10.17 去上海参加了 HACKxFDU，这也是第一次参加 Hackathon，最后抱了大腿队友水到了一个微软的万物互联奖，不过奖品就两套物联网套件，根本不够四个人分(╯°□°）╯。在上海大概玩了一个礼拜，去了趟迪士尼（人多，体验差，项目无聊）就回学校了。然后上一周基本上没做什么事情，一是要准备大创项目的中期检查答辩，二是要复习软件工程的考试。</p>

<p>最近做出比较重要的一个决定就是确定了以后将要从业的方向，以前基本上都是按照兴趣来学，什么都做过一些，但都不是很深入，也没有想好以后工作想要干嘛。最近不知道怎么突然对数据挖掘和机器学习产生兴趣了，正好之前做的一个大创项目也是和这个有关的（虽然项目内容都是在划水），所以还算对这方面有点经验。</p>

<p>但是要解决的问题还是有很多的，比如说如何找到工作的问题，搜索了一下，机器学习/数据挖掘的岗位都需要有研究生学历，作为一个辣鸡学校的本科生，能不能找到工作就是一个问题。跟一个朋友说了一下想法，他说我在玩火……当然，实际上这方面倒不是太担心，如果有普通研究生能力的话找到一个工作还是不难的。</p>

<p>另外一个就是需要系统得学习这一套东西了，包括微积分、线性代数、概率论、统计学、机器学习，大部分内容是数学，现在有点后悔大一大二的时候没有好好学数学了，高数那些课基本就是划水过去的，欠下来的债还要还的。</p>

<p>现在基本的计划就是：</p>

<ol>
<li>看《利用 Python 进行数据分析》，把 Python 的几个科学计算库用熟练；</li>
<li>复习一下数学的知识，看《程序员的数学》系列的三本书，有基础的话应该挺快就能看完；</li>
<li>看李航的《统计学习方法》；</li>
<li>看《集体智慧编程》；</li>
<li>看周志华的《机器学习》；</li>
</ol>

<p>上面就是初步的入门计划，应该看完了对数据挖掘/机器学习有一个基本的了解了，可以顺便去 Kaggle 上打打比赛，虽然不一定能够能拿到好名次，积累一些经验总是好的。另外 Ng 的课和台大的《机器学习基石》也可以看一下。</p>

<p>其他一些资源：</p>

<ul>
<li><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers">Top-down learning path: Machine Learning for Software Engineers</a></li>
<li><a href="https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009">机器学习工程师（中/英）</a></li>
<li><a href="https://cn.udacity.com/course/data-analyst-nanodegree--nd002">数据分析师（中/英）</a></li>
</ul>

<p>这周和下周的计划就是把《利用 Python 进行数据分析》这本书看完。</p>

<p>ps：买了《文明6》，感觉时间还是挺紧的(╯▽╰)</p>
]]>
    </content>
  </entry>
  
</feed>
