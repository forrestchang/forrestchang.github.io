<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hack Notes]]></title>
  <link href="http://forrestchang.com/atom.xml" rel="self"/>
  <link href="http://forrestchang.com/"/>
  <updated>2017-05-07T17:40:38+08:00</updated>
  <id>http://forrestchang.com/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[Week 19：时间管理]]></title>
    <link href="http://forrestchang.com/14941475791022.html"/>
    <updated>2017-05-07T16:59:39+08:00</updated>
    <id>http://forrestchang.com/14941475791022.html</id>
    <content type="html">
<![CDATA[<p>之前有在博客上写 Weekly Review 的习惯，后来因为被朋友说博客真水然后都撤下来了，有些文章确实是类似于「流水账」的记事，但也有一些是围绕这周做的东西来讨论的。总的来说，写 Weekly Review 对自己帮助还是很大的，可以在一周中 Focus 一个特定的主题，而不是想到什么做什么，所以这个系列以后还会继续写下去，只是写的内容更加具体一天，可以围绕着这周的 Project，或者这周听的音乐，或者读的书之类的。以前的文章看情况要不要放上来。</p>

<p>这周算是正式把我的任务管理系统从 org-mode 转移到 Todoist 上来了。在不考虑时间成本和易用性上来说，org-mode 依然是目前我认为最完备的任务和时间管理系统，我用它来：</p>

<ol>
<li>任务管理：类似于 OmniFocus 的多层级任务管理，支持标签和优先级，可以自定义过滤视图</li>
<li>时间记录：按照项目的方式来记录时间，基本是在做哪件事之前把计时器打开，一个番茄时间后自动关闭，可以自定义生成各种时间报表</li>
<li>番茄工作法</li>
</ol>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-05-07-092455.jpg" alt=""/></p>

<p>自定义生成的时间记录表：</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-05-07-092544.jpg" alt=""/></p>

<p>虽然 org-mode 的优点众多，但是始终是一个基于 Emacs 的 major mode，所以诸多限制在所难免：</p>

<ol>
<li>没有一个简单易用的移动端</li>
<li>没办法做到全局 capture，虽然借助 Alfred 的 Workflow 和 Elisp 脚本能够实现这一功能，但是使用起来体验并不是很好</li>
<li>编辑功能过重，很显然，做任务管理不需要多么高效的编辑操作，类似于 OmniFocus 使用鼠标 + 快捷键才是更高效的方法，在 Emacs 里经常编辑速度过快把整个文件搞乱了</li>
</ol>

<p>不用 OmniFocus 的原因是本来就是从 OmniFocus 转到 org-mode 上来的，OmniFocus 有一个很致命的缺点就是不支持多标签，并且 Perspective 提供的设置选项也很有限，根不能不能满足一些复杂的过滤要求。除此之外，OmniFocus 应该是最优秀的任务管理软件了。</p>

<p>Todoist 初次使用的时候感觉很难用，尤其是鼠标点击就进入编辑模式，这个设计真的不知道怎么想的，并且各平台的客户端一点也不 Native，基本就是 Web 版套了一个壳。macOS 客户端经常有一些莫名的 bug，反正软件的使用体验上来说和 OmniFocus 简直不能比。</p>

<p>经过一段时间的调教，现在基本还能满足日常使用了。我认为一个可靠的任务管理系统需要满足两点：</p>

<ol>
<li>能够随时把想法和任务记录进去</li>
<li>能够按照特定的要求过滤出任务</li>
</ol>

<p>其他的一些东西其实都是为了服务这两点的，比如说标签系统，其实就是在过滤任务的时候多加了一个维度。Todoist 的过滤系统比 OmniFocus 好很多，但是和 org-mode 这种可以完全自定义的过滤系统相比还是差点，不过也完全够用。</p>

<p>具体要写 Todoist 怎么用可能一篇文章也写不完（或许以后会写），另外 Todoist 还刚使用，有些东西还需要熟悉一下，下一篇文章会介绍一下目前我在用的一些过滤器。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[叛逃 Spotify]]></title>
    <link href="http://forrestchang.com/14899058720947.html"/>
    <updated>2017-03-19T14:44:32+08:00</updated>
    <id>http://forrestchang.com/14899058720947.html</id>
    <content type="html">
<![CDATA[<p>不久前我还<a href="digital-life-in-2016-music-part.html">写文</a>称赞过 Apple Music，现在光速打脸，叛逃 Spotify。</p>

<p>主要原因有几点：</p>

<ol>
<li>Apple Music 的「My Favorites Mix」一周才更新一次，不够听。</li>
<li>推荐的歌单都是听过的，专辑也是，重复推荐，并且由于是人工编辑的歌单，难免有不合自己口味的。</li>
<li>个性化推荐的内容太单一，经常出现歌慌，需要自己去找歌。</li>
<li>同步问题。</li>
</ol>

<p>Spotify 的 Premium 之前就买了，但是一直没有用。这几天用了一下，说一下使用体验：</p>

<ol>
<li>推荐算法很厉害，机器推荐的歌更个人一些，不会有人工歌单的主观因素在里面。</li>
<li>「Based on the songs in this playlist」这个功能很有用，可以用来扩充歌单。</li>
<li>Radio 功能比 Apple Music 强大。</li>
<li>多设备同步，这个功能太方便了，我只需要在电脑上断开蓝牙连接，然后就可以直接在手机上听了（配合蓝牙耳机）。</li>
</ol>

<p>一些不满意的地方：</p>

<ol>
<li>不能收藏专辑，有的专辑里面并不是每首歌都喜欢听，save 专辑会把整张专辑里面的歌添加到资料库里，这不得不让我又新建一个 Loved 的歌单，专门用来放喜欢的歌，这样和 Apple Music 就是差不多的操作逻辑。</li>
<li>没有提供加心功能，「+」仅仅是把歌曲添加到资料库，所以还得手动建一个歌单然后再添加，比较麻烦（可能我使用的方法不正确？）</li>
</ol>

<p>不过毕竟才用了几天，还没有深度体验过。Mac 上推荐配合 Alfred 的 Workflow 来使用，可以避免到 Spotify 应用里面进行操作。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 刷题笔记]]></title>
    <link href="http://forrestchang.com/14891114444883.html"/>
    <updated>2017-03-10T10:04:04+08:00</updated>
    <id>http://forrestchang.com/14891114444883.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">001 Two Sum [Easy]</a>
<ul>
<li>
<a href="#toc_1">题目</a>
</li>
<li>
<a href="#toc_2">时间复杂度</a>
</li>
<li>
<a href="#toc_3">思路</a>
</li>
<li>
<a href="#toc_4">代码</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">002 Add Two Numbers [Medium]</a>
<ul>
<li>
<a href="#toc_6">时间复杂度</a>
</li>
<li>
<a href="#toc_7">思路</a>
</li>
<li>
<a href="#toc_8">代码</a>
</li>
<li>
<a href="#toc_9">笔记</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">007 Reverse Integer [Easy]</a>
<ul>
<li>
<a href="#toc_11">题目</a>
</li>
<li>
<a href="#toc_12">思路</a>
</li>
<li>
<a href="#toc_13">代码</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">001 Two Sum [Easy]</h2>

<h3 id="toc_1">题目</h3>

<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>Example：</p>

<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<h3 id="toc_2">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_3">思路</h3>

<p>比较暴力的做法就是用两个循环来穷举，这样的话时间复杂度会达到 \(O(n^2)\)。</p>

<p>另外一种思路就是使用一个 dict 来保存外循环中 target 与 num 的差值，这样在数组中只要发现这个值就可以直接返回了，而在 dic 查找的时间复杂度为 \(O(1)\)。</p>

<h3 id="toc_4">代码</h3>

<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            else:
                dic[target - num] = i
</code></pre>

<h2 id="toc_5">002 Add Two Numbers [Medium]</h2>

<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>Example:</p>

<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre>

<h3 id="toc_6">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_7">思路</h3>

<p>把两个数相加存在链表里，这两个数字的每一位都存在链表中，并且链表是反转的。思路很简单，就是遍历链表，把数取出来，然后加完后再添加到链表中。</p>

<p>代码写得很直白。</p>

<h3 id="toc_8">代码</h3>

<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        num1 = []
        num2 = []
        current = l1
        while current != None:
            num1.append(str(current.val))
            current = current.next
        current = l2
        while current != None:
            num2.append(str(current.val))
            current = current.next
        num1 = &#39;&#39;.join(num1)[::-1]
        num2 = &#39;&#39;.join(num2)[::-1]
        sum = int(num1) + int(num2)
        first = ListNode(str(sum)[0])
        for i in str(sum)[1:]:
            oldfirst = first
            first = ListNode(i)
            first.next = oldfirst
        return first
</code></pre>

<h3 id="toc_9">笔记</h3>

<p>翻了一下 discuss，发现我的解法实在是太 dirty 了。</p>

<p>下面这一段代码我认为还是非常优美的实现：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        def tolist(n):
            node = ListNode(n % 10)
            if n &gt; 9:
                node.next = tolist(n // 10)
            return node
        return tolist(toint(l1) + toint(l2))
</code></pre>

<p>非递归版本：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        n = toint(l1) + toint(l2)
        first = last = ListNode(n % 10)
        while n &gt; 9:
            n /= 10
            last.next = last = ListNode(n % 10)
        return first
</code></pre>

<p>解释一下思路。</p>

<p>首先 <code>toint(node)</code> 函数是将链表转化成 <code>int</code> 类型的数据，因为 Python 中 <code>int</code> 可以存非常大的数，所以不用考虑链表的长度。算法也很简单，因为链表是转置的，所以高位在链表后面，依次乘以 10 的 n 次方再相加就可以了。</p>

<p><code>tolist(n)</code> 函数式将计算好的数据转化成链表，再纸上拿一个一个例子画一个图就很好理解了。<code>node = ListNode(n % 10)</code> 每一次递归都创建一个节点来存放某一位的数据，<code>tolist(n // 10)</code> 每一次递归都截取一位数字。</p>

<p>非递归的方法类似。</p>

<h2 id="toc_10">007 Reverse Integer [Easy]</h2>

<h3 id="toc_11">题目</h3>

<p>Reverse digits of an integer.</p>

<p>The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.</p>

<p>Ex：</p>

<pre><code>Example1: x = 123, return 321
Example2: x = -123, return -321
</code></pre>

<h3 id="toc_12">思路</h3>

<p>这道题很简单，但是要考虑转置之后会不会溢出，但是 Python 的 <code>int</code> 是不会溢出的，所以就需要手动判断一下，INT32 最大值是 \(2^{31}-1\)，用十六进制表示就是 <code>0x7FFFFFFF</code>。</p>

<h3 id="toc_13">代码</h3>

<pre><code class="language-python">class Solution(object):
    def reverse(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: int
        &quot;&quot;&quot;
        if x &lt; 0:
            result = -(int(str(x).lstrip(&#39;-&#39;)[::-1]))
        else:
            result = int(str(x)[::-1])
        
        if abs(result) &gt; 0x7FFFFFFF:
            return 0
        return result
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digital Life in 2016: 音乐篇]]></title>
    <link href="http://forrestchang.com/digital-life-in-2016-music-part.html"/>
    <updated>2017-02-24T11:52:04+08:00</updated>
    <id>http://forrestchang.com/digital-life-in-2016-music-part.html</id>
    <content type="html">
<![CDATA[<p>最近知乎上的一个朋友和我私信聊了一些关于效率工具以及 Workflow（此处指的是「工作流」）方面的一些问题。聊的内容比较碎片，所以还是打算写一篇文章来具体讨论一下。考虑到会涉及很多不同的主题，所以还是一个主题写一篇，这样也可以控制文章的长度。暂定按照以下主题来写：音乐篇、阅读篇、写作篇和时间管理篇。</p>

<p>音乐对我来说，应该算是日常生活中比较重要的一项内容了，除了一些需要特别 Focus 的工作（例如看数学）不会听音乐外，其他时间都会戴着耳机。2016 年彻底地转入到 Apple Music 中来，期间试用过一段时间的 Spotify，网易云音乐几乎没怎么打开过。这篇打算讨论一下所有（尽量）听音乐方面相关的问题。</p>

<h2 id="toc_0">用什么设备听</h2>

<p>我的大多数电子设备都是 Apple 系的，包括 rMBP、iPhone、iPad，所以听音乐也都是围绕着这些设备来。严格的来说，并不能算一个「音乐发烧友」，我对设备的要求并不是太高，甚至对音源也没有太高的要求，Apple Music 的音质已经完全能够满足了，无损音源内容几乎不听，其一是没有购买 CD 的习惯，所以没有合法的途径获取无损资源；其二是一直都是拿 iTunes 听音乐，无损还需要转格式编辑信息，过于麻烦。</p>

<p>主力播放器是 Macbook，几乎 80% 的时间都是在 Macbook 上听（写代码、阅读、写作等）。另外便是新购入的 iPhone 7，主要是外出坐车、跑步或是睡前听一下（之前是用 5s）。iPad 很少用来听音乐。</p>

<p>使用的耳机是 <a href="https://www.amazon.com/Westone-Pro30-Performance-Universal-Earphones/dp/B00FKY3IFA">Westone UM Pro 30</a>，使用体验很好，对比 Apple 自带的耳机有惊艳的提升，而且长时间佩戴也没有不适感（几乎没有戴着耳机的感觉）。想要具体了解得可以去搜相关的评测来看。</p>

<p>耳机是在 7 发售之前买的，传闻 7 要去掉耳机接口的时候其实我是不信的，结果还真去掉了。这导致了插 7 上需要多接一根转接线，略显累赘，所以现在在 iPhone 上听歌就直接拿自带的耳机了。</p>

<h2 id="toc_1">为什么不用网易云音乐</h2>

<p>我知道，我也很讨厌类似「我为什么不 xxx」的说法，「不用就不用，还要批判一番」，但是还是要写一写。</p>

<p>其实我很早就开始使用网易云音乐了，那个时候一些热门的歌曲下评论还只有几百条，不像现在，动辄上千上万条评论。也安利过身边好多人用，曾经是长期的会员用户，所以还是有一些资格来谈论一下这个音乐服务的。</p>

<p>很明显，网易云音乐最初就是模仿 Spotify 的，包括界面设计，几乎一模一样。除了借鉴 Spotify 之外，网易云音乐还加入了很多自己的「创新」，而正是这些所谓的创新，让我开始慢慢得不想用它。</p>

<ol>
<li>评论：其实我是赞成加入评论功能的，但是网易云的评论已经偏离了音乐评论的范围，变成了编故事、讲段子、骗赞评论的聚集地。认真评论音乐的几乎没有，我不知道如果想看段子为什么不上微博？这一点实际上让一个音乐软件变成了社交软件，不好意思，我只想好好听音乐。</li>
<li>歌曲：网易云上很多歌曲的信息混乱不堪，包括专辑信息、专辑封面、年份等，很多单曲甚至没有专辑信息，直接被编排到「热门歌曲串烧」这样的专辑里，我有强迫症，看着挺 low 的。并且很多的歌来源都不明确，大多数都是网友上传，甚至很多 Bilibili 鬼畜区的音乐也被上传上来，哪天听推荐就冷不丁得听到。</li>
<li>专辑封面不完整：网易云的一大特色就是模仿唱片机旋转，想看一下专辑封面是什么样还要点到专辑列表里面去看。在我看来，在电子设备上「拟物」是一种很没有效率的事，就像之前电子书的模拟翻页一样，「翻页」这个动作本来就是一个三维的过程，在手机上再怎么模拟也达不到现实中的效果，「瀑布式」的阅读方式才是正确的选择。所以我推崇「反拟物化」、「扁平化」和「极简化」的设计风格。</li>
<li>歌单：几乎所有的歌单都是由用户创建，和 Apple Music 与 Spotify 专门的音乐编辑创建的歌单相比，高下立判。</li>
</ol>

<p>在我看来，听音乐是一件很纯粹的事，而网易云给这件纯粹的事加了太多的东西。</p>

<h2 id="toc_2">Apple Music 之痛</h2>

<p>Apple Music 自从 2015 年 6 月发布以来，到现在已经有接近两年的时间了，从发布当天付费到现在，中间用了一段时间的国区，由于曲库原因，现在还换回了港区，每月 48 港币，虽然比国区每月 10 ￥（学生 5 ￥）贵了不少，不过依然很值，想想一张专辑的钱就可以听一个月。</p>

<p>虽说经过这么长时间的发展，Apple Music 依然可以说做得很烂，我在一年前的一篇文章（<a href="http://forrestchang.github.io/14824082548997.html">《Apple Music，古典音乐，阅读》</a>）中已经吐槽过了，除了网络问题有了明显改善之外，其他的并没有太大的改进。以至于现在每年的 WWDC 最期待的不是发布什么新产品，而是 Apple Music 有什么大的改进，加了些什么功能。</p>

<p>我在 V2EX 上也发过<a href="https://www.v2ex.com/t/336425">一篇帖子</a>吐槽过 Apple Music。</p>

<p>这些问题肯定和 iTunes 的历史因素有关，iTunes 本身就是作为一个音乐商店，在没有 Apple Music 之前，听音乐的流程就是从商店中购买数字音乐（或者从 CD 中导入），然后添加到 Library 中，之后对这些音乐做什么事都与商店中的音乐无关了。而到了 Apple Music，它依然延续着之前的流程，当把音乐添加到 Library 中后，你对音乐做出的评分、加心实际上都和云端的数据无关了，所有数据都存放在本地的 <code>iTunes Library.xml</code> 文件中，所以这才会导致一部分音乐明明加过心了，到了手机上一看却是没有加过心的，并且由于存放在本地的原因，云端的数据也不会更新，这也会影响到每天推荐给你的音乐。</p>

<p>Medium 上的一个设计师专门帮 Apple Music 重新设计了一下：<a href="https://medium.com/product-design-ux-ui/apple-music-redesign-part-1-526c4c4c4777#.lopgpvt41">Apple Music Redesign</a>，在我看来，比原版的 Apple Music 好太多。</p>

<p>很难想象，把 iPhone 做得只有 7 mm 厚的科技公司，竟然连 iTunes 中遗留的种种问题也解决不好。</p>

<h2 id="toc_3">听什么</h2>

<p>我并不打算讲太多「听什么」的内容，音乐本来就是一个很个人的事情，但是，音乐真的没有好坏吗？实际上，Apple Music 与网易云一个很大的不同点就是，前者有意得引导你听，而后者是根据你听歌的记录推荐相似的（尽管并不准）歌曲。</p>

<p>相比较网易云的每日推荐，Apple Music 只有一个最爱精选（My Favorites Mix），里面有很多你之前就已经喜欢的歌，每周更新一次。而更多的每天推荐是类似「朴树：音乐灵感」、「古典音乐：混音和改编歌曲」这样的人工手动编辑的歌单，而一般这样的歌单都会附带编辑的一些评语，让你能够大体得了解这张歌单内容，比如今天推荐给我的「古典音乐：混音和改编歌曲」：</p>

<blockquote>
<p>古典樂的經典旋律恆久不變，但同樣的旋律放在此歌單中卻可讓你帶來驚喜！耳熟能詳的柴可夫斯基、韋瓦第等大師作品，換上電子工程師 Max Richer、CFCF 及 DJ Spooky 的混音和改編，令幾百年前的作品添上時代感，即使充滿實驗性和玩味，趣味滿分。</p>
</blockquote>

<p>相比没有目的、仅仅根据自己的喜好乱听，这种引导的方式会慢慢影响你的音乐品味。</p>

<p>另一方面，它还会每天给你推荐不一样的专辑，比如我喜欢听 Imagine Dragons，它今天就给我基于此推荐了《An Awesome Wave》、《Skying》、《Megalithic Symphony》等专辑。</p>

<p>快餐音乐时代，很多歌曲单独从专辑中拿出来听也不会有什么问题，但是按照专辑来听，依然是严肃欣赏音乐的唯一方式。</p>

<h2 id="toc_4">怎么听</h2>

<p>用过两种方法。</p>

<p>1）类似于 Spotify，添加到 Library 的歌曲就算是你想以后继续听的，「加心」的行为只是用来作为推荐的参考。这种方式就不需要再本地再建一个智能播放列表专门用来过滤加心的歌曲了，因为 Library 中的所有的歌都是你想听的。</p>

<p>2）添加到 Library 中只是作为一个「稍后听」的过程，一般这种情况是按照专辑来添加到 Library 中，然后把这张专辑从头到尾（或者以你喜欢的方式）听一遍，把喜欢的歌加心，并给歌曲评分（可选），然后建立智能播放列表过滤出加心的歌，例如，我除了有一个 「Favorites」 歌单（自动更新 Library 中加心的歌曲），还有一个「古典精选」歌单，其中内容是类型为「Classical」并且已经加心了的歌曲。智能播放列表可以使用很复杂的过滤器。这种听歌方式也是现在我用的，这其实和之前在 iTunes Store 上购买音乐再听并没有什么区别，除了改成了订阅的方式并且附带了推荐功能。</p>

<p>不过听音乐这种事各有各的方法，这里也仅仅是提供参考。</p>

<h2 id="toc_5">一些辅助工具</h2>

<p>其实写到这里基本已经写完了。如果你不是一个强迫症、数据控、偏执狂或是一个完美主义者，最后这部分并没有什么太多帮助。</p>

<p>我使用 <a href="https://www.last.fm">last.fm</a> 来记录自己听了什么，Mac 上使用的是官方的 Last.fm Scrobbler 这个软件，不过它只能记录离线的歌曲，对于 Radio 就无能为力了，所以我辅助 <a href="http://bowtieapp.com/">Bowtie</a> 这个小软件来记录，为了防止重复记录，需要把 Last.fm Scrobbler 中的 Enable Scrobbling 选项关闭。</p>

<p>记录数据可以让你更好得知道平常的音乐喜好，以及某张专辑、某首歌、某个艺人听了多少次等等。并且 last.fm 提供通用的 API 来方便导出这些数据，说不定以后有什么用。</p>

<p>过去一周我的听歌记录可以在 <a href="https://www.last.fm/user/Tisoga/listening-report/week">这里</a> 看到。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[换了一个新地方写东西]]></title>
    <link href="http://forrestchang.com/14878992387553.html"/>
    <updated>2017-02-24T09:20:38+08:00</updated>
    <id>http://forrestchang.com/14878992387553.html</id>
    <content type="html">
<![CDATA[<p>现在这个博客只写技术相关的内容，其他的随笔都写在<a href="https://medium.com/@Tisoga">新博客</a>里，Medium 是被大陆屏蔽的，所以请自备梯子。另外一些比较私人的笔记——例如「Week Review」系列就不发表在互联网上了。</p>

<p>至于原因，单纯得觉得 Medium 上的衬线字体很好看。<del>如果需要魔改这个博客的话，还是挺麻烦的，自己目前的前端知识还处于未入门的水平，所以就不折腾了。</del>结果我还是魔改了，现在风格比较简洁了，照着 <a href="https://github.com/lepture/yue.css">yue.css</a> 改的。</p>

<p>既然重新换了一个主题，就不换地方写了……</p>

<p>主题的代码放在 <a href="https://github.com/forrestchang/Cuckoo">GitHub</a> 上，完全是新手的作品，所以还是不要 star 了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐系统笔记]]></title>
    <link href="http://forrestchang.com/14824086421976.html"/>
    <updated>2016-12-22T20:10:42+08:00</updated>
    <id>http://forrestchang.com/14824086421976.html</id>
    <content type="html">
<![CDATA[<p>开始学习机器学习/数据挖掘相关的内容，打算每学习一部分知识就写一篇博客总结一下，当做学习过程中的笔记，也为以后看的时候提供存档。</p>

<p>这一篇笔记是关于推荐系统的，主要讲了两种推荐算法（基于用户和基于物品的协同过滤）。</p>

<h2 id="toc_0">基于用户的协同过滤</h2>

<h3 id="toc_1">协同过滤（Collaborative filtering）</h3>

<p>一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。</p>

<h3 id="toc_2">测试数据集</h3>

<p>为了演示一些算法，我们需要从<a href="http://grouplens.org/datasets/movielens/">这个网站</a>上下载一份数据集。这里因为是作为演示使用，所以只需要下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>这一份简单的数据集就可以了。</p>

<h3 id="toc_3">相似度计算</h3>

<p>在有了数据之后，我们需要有一种方法来确定人们在品味方面的相似程度。为此，我们可以将每个人与所有其他人进行对比，并计算他们的<strong>相似度评价值</strong>。</p>

<h4 id="toc_4">欧几里德距离评价（Euclidean Distance Score）</h4>

<p>欧几里德距离是指多维空间中两点间的距离，这是一种用直尺测量出来的距离。如果我们将两个点分别记作\((p_1, p_2, p_3, p_4, ...)\)和\((q_1, q_2, q_3, q_4, ...)\)，则欧几里德距离的计算公式为：</p>

<p>\[<br/>
\sqrt{((p_1-q_1)^2+(p_2-q_2)^2+...+(p_n-q_n)^2)} = \sqrt{(\sum_{i=1}^n(p_i-q_i)^2)}<br/>
\]</p>

<p>创建 <code>recommendations.py</code>。</p>

<p>用代码表示：</p>

<pre><code class="language-python">from math import sqrt

# 返回一个有关 person1 与 person2 的基于距离的相似度评价
def sim_distance(prefs, person1, person2):
    # 得到 shared_items 的列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
        shared_items[item] = 1
    
    # 如果两者没有共同之处，则返回 0
    if len(shared_items) == 0:
        return 0
        
    # 计算所有差值的平方和
    sum_of_squares = sum([pow(prefs[person1][item]-prefs[person2][item], 2)for item in prefs[person1] if item in prefs[person2]])
    
    return 1 / (1 + sqrt(sum_of_squares))
</code></pre>

<p>欧几里德距离计算公式可以计算出距离值，偏好越相似的人，其距离就越短。不过，我们还需要一个函数，来对偏好越相近的情况给出越大的值，为此，我们可以将函数的值加 1（这样就可以避免遇到被 0 整除的错误了），并取其倒数，入上面代码最后一行所示。</p>

<p>好了，现在我们需要先将数据读取进来，在 <code>recommendations.py</code> 中添加如下代码:</p>

<pre><code class="language-python">def loadMovieLens(path=&#39;data&#39;):
    movies = {}
    for line in open(path + &#39;/movies.csv&#39;):
        (id, title) = line.split(&#39;,&#39;)[0:2]
        movies[id] = title

    prefs = {}
    for line in open(path+&#39;/ratings.csv&#39;):
        (user, movieid, rating, ts) = line.split(&#39;,&#39;)
        prefs.setdefault(user, {})
        prefs[user][movies[movieid]] = float(rating)
    return prefs
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; import recommendations
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 比较 10 号用户 和 20 号用户的相似度评价
&gt;&gt;&gt; recommendations.sim_distance(prefs, &#39;10&#39;, &#39;20&#39;)
0.23371479611805132
</code></pre>

<h4 id="toc_5">皮尔逊相关系数（Pearson Correlation Coefficient）</h4>

<p>皮尔逊相关系数是一种度量两个变量间相关程度的方法，它是一个介于 1 和 -1 之间的值，其中，1 表示变量完全正相关，0 表示无关， -1 则表示完全负相关（一个变量的值越大，则另一个变量的值反而会越小）。</p>

<p>计算公式：</p>

<p>\[<br/>
r = \frac{\sum{XY}-\frac{\sum X \sum Y}{N}}{\sqrt{(\sum X^2 - \frac{(\sum X)^2}{N})(\sum Y^2 - \frac{(\sum Y)^2}{N})}}<br/>
\]</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def sim_pearson(prefs, person1, person2):
      # 得到双方都曾评价过的物品列表
    shared_items = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            shared_items[item] = 1
      # 得到物品列表元素的个数
    n = len(shared_items)

      # 如果两者没有共同元素，则返回0
    if n == 0:
        return 0

      # 计算 person1 和 person2 的皮尔逊相关系数
    sumxy = sum([prefs[person1][item] * prefs[person2][item]
                for item in shared_items])
    sumx = sum([prefs[person1][item] for item in shared_items])
    sumy = sum([prefs[person2][item] for item in shared_items])
    sumx2 = sum([prefs[person1][item] ** 2 for item in shared_items])
    sumy2 = sum([prefs[person2][item] ** 2 for item in shared_items])

    zahler = sumxy - (sumx * sumy) / n
    nenner = sqrt((sumx2 - (sumx ** 2) / n) * (sumy2 - (sumy ** 2) / n))
    if nenner == 0:
        return 0
    r = zahler / nenner

    return r
</code></pre>

<p>在 ipython 交互环境中：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.sim_pearson(prefs, &#39;10&#39;, &#39;20&#39;)
0.4908806936738162
</code></pre>

<p>可以看到和上面使用欧几里德距离评价计算出来的相似度是不一样的。</p>

<h4 id="toc_6">关于该使用哪一种相似性度量方法</h4>

<p>除了这两种计算相似度的方法，实际上还有许多别的计算相似度的算法，例如<strong>Tanimoto 分值</strong>。使用哪一种方法，完全取决于具体的应用。</p>

<p>下面的代码中，将使用一个通用的相似性函数来计算相似度，只要它满足以下条件：拥有同样的函数签名，以一个浮点数作为返回值，其数值越大代表相似度越大。</p>

<h3 id="toc_7">寻找相似的用户</h3>

<p>既然我们已经有了对两个人进行比较的函数，下面我们就可以编写，根据指定人员对每个人进行打分，并找出最接近的匹配结果了。</p>

<pre><code class="language-python"># 从反映偏好的字典中返回最佳匹配者
# 返回结果的个数和相似度函数均为可选参数
def topMatches(prefs, person, n=5, similarity=sim_pearson):
    scores = [(similarity(prefs, person, other), other) for other in prefs if other != person]
    
    # 对列表进行排序，评价值最高者排在最前面
    scores.sort(reverse=True)
    return scores[:n]
</code></pre>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; # 与 40 号用户相似的 10 个用户
&gt;&gt;&gt; recommendations.topMatches(prefs, &#39;40&#39;, n=10)
[(1.0, &#39;63&#39;),
 (1.0, &#39;582&#39;),
 (1.0, &#39;326&#39;),
 (1.0, &#39;260&#39;),
 (1.0, &#39;220&#39;),
 (1.0, &#39;198&#39;),
 (1.0, &#39;153&#39;),
 (1.0, &#39;116&#39;),
 (0.9999999999999947, &#39;474&#39;),
 (0.9999999999999947, &#39;215&#39;)]
</code></pre>

<h3 id="toc_8">推荐物品</h3>

<p>有的时候我们可能不需要寻找相似的用户，例如在购物网站中，我们需要的是一份可能会想要购买的物品列表，一种方法是从相似的用户所购买的物品列表中选出没有购买的，但是这种方法不确定的因素太多，例如可能相似用户还未购买某些物品，而这些物品恰恰就是我们所需要的。</p>

<p>为了解决上面的问题，我们需要通过一个经过加权的评价值来为影片打分，评论者的评分结果因此而形成了先后的排名。为此，我们需要取得所有其他评论者的评价结果，借此得到相似度之后，再乘以他们为每部影片所给的评价值。</p>

<p>以以下数据集为例：</p>

<pre><code>{&#39;Lisa Rose&#39;: {&#39;Lady in the Water&#39;: 2.5,
               &#39;Snakes on a Plane&#39;: 3.5,
               &#39;Just My Luck&#39;: 3.0,
               &#39;Superman Returns&#39;: 3.5,
               &#39;You, Me and Dupree&#39;: 2.5,
               &#39;The Night Listener&#39;: 3.0},
 &#39;Gene Seymour&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 1.5,
                  &#39;Superman Returns&#39;: 5.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Michael Phillips&#39;: {&#39;Lady in the Water&#39;: 2.5,
                      &#39;Snakes on a Plane&#39;: 3.0,
                      &#39;Superman Returns&#39;: 3.5,
                      &#39;The Night Listener&#39;: 4.0},
 &#39;Claudia Puig&#39;: {&#39;Snakes on a Plane&#39;: 3.5,
                  &#39;Just My Luck&#39;: 3.0,
                  &#39;The Night Listener&#39;: 4.5,
                  &#39;Superman Returns&#39;: 4.0,
                  &#39;You, Me and Dupree&#39;: 2.5},
 &#39;Mick LaSalle&#39;: {&#39;Lady in the Water&#39;: 3.0,
                  &#39;Snakes on a Plane&#39;: 4.0,
                  &#39;Just My Luck&#39;: 2.0,
                  &#39;Superman Returns&#39;: 3.0,
                  &#39;The Night Listener&#39;: 3.0,
                  &#39;You, Me and Dupree&#39;: 2.0},
 &#39;Jack Matthews&#39;: {&#39;Lady in the Water&#39;: 3.0,
                   &#39;Snakes on a Plane&#39;: 4.0,
                   &#39;The Night Listener&#39;: 3.0,
                   &#39;Superman Returns&#39;: 5.0,
                   &#39;You, Me and Dupree&#39;: 3.5},
 &#39;Toby&#39;: {&#39;Snakes on a Plane&#39;: 4.5,
          &#39;You, Me and Dupree&#39;: 1.0,
          &#39;Superman Returns&#39;: 4.0}}
</code></pre>

<p>假设我们需要给 Toby 提供影片推荐，我们可以根据上面的算法得出一张表：</p>

<table>
<thead>
<tr>
<th>评论者</th>
<th>相似度</th>
<th>Night</th>
<th>S.xNight</th>
<th>Lady</th>
<th>S.xLady</th>
<th>Luck</th>
<th>S.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Rose</td>
<td>0.99</td>
<td>3.0</td>
<td>2.97</td>
<td>2.5</td>
<td>2.48</td>
<td>3.0</td>
<td>2.97</td>
</tr>
<tr>
<td>Seymour</td>
<td>0.38</td>
<td>3.0</td>
<td>1.14</td>
<td>3.0</td>
<td>1.14</td>
<td>1.5</td>
<td>0.57</td>
</tr>
<tr>
<td>Puig</td>
<td>0.89</td>
<td>4.5</td>
<td>4.02</td>
<td></td>
<td></td>
<td>3.0</td>
<td>2.68</td>
</tr>
<tr>
<td>LaSalle</td>
<td>0.92</td>
<td>3.0</td>
<td>2.77</td>
<td>3.0</td>
<td>2.77</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Matthews</td>
<td>0.66</td>
<td>3.0</td>
<td>1.99</td>
<td>3.0</td>
<td>1.99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td></td>
<td>12.89</td>
<td></td>
<td>8.38</td>
<td></td>
<td>8.07</td>
</tr>
<tr>
<td>Sim.Sum</td>
<td></td>
<td></td>
<td>3.84</td>
<td></td>
<td>2.95</td>
<td></td>
<td>3.18</td>
</tr>
<tr>
<td>总计/Sim.Sum</td>
<td></td>
<td></td>
<td>3.35</td>
<td></td>
<td>2.83</td>
<td></td>
<td>2.53</td>
</tr>
</tbody>
</table>

<p>表中列出来每位评论者的相关度评价值，以及他们对三部影片的评分情况。以 S.x 打头的列给出了乘以评价值之后的相似度。如此一来，相比于与我们不相近的人，那些与我们相近的人将会对整体评价拥有更多的贡献。总计所有加权评价值的和。</p>

<p>我们也可以选择利用总计值来计算排名，但是这其中有一个问题，一部受更多人评论的影片会对结果产生很大影响。为了修正这一问题，我们需要除以表总名为 Sim.Sum 的那一行，它代表了<strong>所有对这部电影有过评论的评论者的相似度之和</strong>。对于影片《Lady in the Water》来说，Puig 并未做过评论，所以我们将这部影片的总计值除以所有其他人的相似度之和。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python"># 利用所有其他人评价值得加权平均，为某人提供建议
def getRecommendations(prefs, person, similarity=sim_pearson):
    totals = {}
    simSums = {}
    for other in prefs:
        # 不要和自己做比较
        if other == person:
            continue
        sim = similarity(prefs, person, other)
        
        # 忽略评价值为零或者小于零的情况
        if sim &lt;= 0:
            continue
            
        for item in prefs[other]:
            # 只对自己还未看过的影片进行评价
            if item not in prefs[person] or prefs[person][item] == 0:
                # 相似度*评价值
                totals.setdefault(item, 0)
                totals[item] += prefs[other][item] * sim
                # 相似度之和
                simSums.setdefault(item, 0)
                simSums[item] += sim
        
        # 建立一个归一化的列表
        rankings = [(total / simSums[item], item) for item, total in totals.items()]
        
        # 返回经过排序的列表
        rankings.sort(reverse=True)
        return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; relaod(recommendations)
&gt;&gt;&gt; prefs = recommendations.loadMovieLens()
&gt;&gt;&gt; recommendations.getRecommendations(prefs, &#39;10&#39;)[:20]
[(5.000000000000001,
  &#39;The Slipper and the Rose: The Story of Cinderella (1976)&#39;),
 (5.000000000000001, &#39;Hands on a Hard Body (1996)&#39;),
 (5.000000000000001, &#39;For the Birds (2000)&#39;),
 (5.000000000000001, &#39;Diva (1981)&#39;),
 (5.0, &#39;Zorba the Greek (Alexis Zorbas) (1964)&#39;),
 (5.0, &#39;Zerophilia (2005)&#39;),
 (5.0, &#39;Zelary (2003)&#39;),
 (5.0, &#39;Z Channel: A Magnificent Obsession (2004)&#39;),
 (5.0, &#39;Yossi (Ha-Sippur Shel Yossi) (2012)&#39;),
 (5.0, &#39;World of Tomorrow (2015)&#39;),
 (5.0, &#39;Woody Allen: A Documentary (2012)&#39;),
 (5.0, &#39;Woman on Top (2000)&#39;),
 (5.0, &#39;Without a Clue (1988)&#39;),
 (5.0, &#39;Withnail &amp; I (1987)&#39;),
 (5.0, &#39;Wild Zero (2000)&#39;),
 (5.0, &#39;War Room (2015)&#39;),
 (5.0, &#39;Walker (1987)&#39;),
 (5.0, &#39;Voices from the List (2004)&#39;),
 (5.0, &#39;Videodrome (1983)&#39;),
 (5.0, &#39;Victoria (2015)&#39;)]
</code></pre>

<h3 id="toc_9">匹配商品</h3>

<p>现在我们已经可以为指定人员寻找品味相近的用户，以及如何向其推荐商品。假如我们想要了解哪些物品是相近的，那又该如何呢？</p>

<p>在我们浏览 Amazon 的时候，经常会看到页面底部会推荐与当前浏览的物品相似的商品。这种情况，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，这和我们之前用来计算人与人之间的相似度是一样的，只需要把人和物品相互调换就行了。</p>

<p>我们来编写这个翻转字典的函数：</p>

<pre><code class="language-python">def transformPrefs(prefs):
    result = {}
    for person in prefs:
        for item in prefs[person]:
            result.setdefault[item, {}]
            # 将物品和人对调
            result[item][person] = prefs[person][item]
    return result
</code></pre>

<p>有了这个方法之后，我们就可以复用之前所写的方法了。</p>

<p>在 ipython 环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; load(recommendations)
&gt;&gt;&gt; movies = recommendations.transformPrefs()
&gt;&gt;&gt; recommendations.topMatches(movies, &#39;For the Birds (2000)&#39;)
[(1.000000000000016, &#39;&quot;Silence of the Lambs&#39;),
 (1.0, &#39;World War Z (2013)&#39;),
 (1.0, &#39;Wallace &amp; Gromit in The Curse of the Were-Rabbit (2005)&#39;),
 (1.0, &#39;Tron: Legacy (2010)&#39;),
 (1.0, &#39;Transcendence (2014)&#39;)]
</code></pre>

<p>我们还可以为影片推荐评论者：</p>

<pre><code class="language-python">&gt;&gt;&gt; recommendations.getRecommendations(movies, &#39;For the Birds (2000)&#39;)[:20]
[(5.0, &#39;668&#39;),
 (5.0, &#39;618&#39;),
 (5.0, &#39;543&#39;),
 (5.0, &#39;541&#39;),
 (5.0, &#39;536&#39;),
 (5.0, &#39;52&#39;),
 (5.0, &#39;464&#39;),
 (5.0, &#39;46&#39;),
 (5.0, &#39;409&#39;),
 (5.0, &#39;357&#39;),
 (5.0, &#39;308&#39;),
 (5.0, &#39;296&#39;),
 (5.0, &#39;29&#39;),
 (5.0, &#39;28&#39;),
 (5.0, &#39;197&#39;),
 (5.0, &#39;196&#39;),
 (5.0, &#39;190&#39;),
 (5.0, &#39;131&#39;),
 (5.0, &#39;113&#39;),
 (4.999999999999999, &#39;465&#39;)]
</code></pre>

<h2 id="toc_10">基于物品的协同过滤</h2>

<p>当前所完成的推荐系统，要求我们使用每一位用户的全部评分来构建数据集，这种方法对于小规模的数据集是没有问题的，但是对于像 Amazon 这样有着上百万用户和商品的大型网站而言，讲一个用户同其他所有用户进行比较，然后再对每位用户评过分的商品进行比较，时间花费上是巨大的。</p>

<p>目前为止我们所使用的技术被称为<strong>基于用户的协同过滤</strong>（user-based collaborative filtering）。除此以外，还有一种可供选择的方法被称为<strong>基于物品的协同过滤</strong>（item-based collaborative filtering）。在拥有大量数据集的情况下，基于物品的协同过滤能够得出更好的结论，而且它允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们所要的结果。</p>

<p>基于物品的协同过滤总体思路就是为每件物品预先计算好最为相近的其他物品。然后，当我们想为某位用户提供推荐的时候，就可以查看他曾经评过分的物品，并从中选出排名靠前者，再构造一个加权列表，其中包含了与这些选中物品最相近的其他物品。此处最显著的区别在于，尽管第一步要求我们检查所有的数据，但是物品间的比较不会像用户间比较那么频繁变化。</p>

<h3 id="toc_11">构造物品比较数据集</h3>

<p>为了对物品进行比较，我们要做的第一件事就是编写一个函数，构造一个包含相近物品的完整数据集。构建完数据集之后，我们就可以在需要的时候重复使用它。</p>

<p>将下面代码添加到 <code>recommendations.py</code> 中：</p>

<pre><code class="language-python">def calculateSimilarItems(prefs, n=10):
    # 建立字典，以给出与这些物品最为相近的其他物品
    result = {}
    
    # 以物品为中心最偏好矩阵进行倒置处理
    itemPrefs = transformPrefs(prefs)
    c = 0
    for item in itemPrefs:
        # 针对大数据集更新状态变量
        c += 1
        if c % 100 == 0:
            print &quot;%d / %d&quot; % (c, len(itemPrefs))
        scores = tomMatchs(itemPrefs, item, n=n, similarity=sim_pearson)
        result[item] = scores
    return result
</code></pre>

<p>该函数首先利用了此前定义过得 <code>transformPrefs</code> 函数，对反映评价的字典进行倒置处理，从而得到一个有关物品及其用户评价情况的列表，然后程序又循环遍历每项物品，并将转换了的字典传入 <code>tomMatches</code> 函数中，求得最为相近的物品及其相似度评价值，最后，它建立并返回了一个包含物品及其最相近物品列表的字典。</p>

<p>在 ipython 交互环境中测试：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; itemsim = recommendations.calculateSimilarItems(prefs)
100 / 8963
200 / 8963
300 / 8963
400 / 8963
500 / 8963
600 / 8963
700 / 8963
800 / 8963
900 / 8963
1000 / 8963
1100 / 8963
1200 / 8963
1300 / 8963
1400 / 8963
1500 / 8963
1600 / 8963
1700 / 8963
1800 / 8963
1900 / 8963
...
</code></pre>

<p>首次运行需要等待一段时间进行计算。</p>

<p>只有频繁执行该函数，才能令物品的相似度不至于过期。通常我们需要在用户基数和评分数量不是很大的时候执行这一函数，但是随着用户数量的不断增长，物品间的相似度评价通常会变得越来越稳定。</p>

<h3 id="toc_12">获得推荐</h3>

<p>现在，我们可以利用反映物品相似度的字典来给出推荐了，我们可以去到用户评价过得所有物品，并找出其相近的物品，根据相似度对其进行加权。</p>

<p>下表给出了利用基于物品的方法寻找推荐的过程，所用到的数据可以在上面<strong>推荐物品</strong>一节中找到。</p>

<p>为 Toby 提供基于物品的推荐：</p>

<table>
<thead>
<tr>
<th>影片</th>
<th>评分</th>
<th>Night</th>
<th>R.xNight</th>
<th>Lady</th>
<th>R.xLady</th>
<th>Luck</th>
<th>R.xLuck</th>
</tr>
</thead>

<tbody>
<tr>
<td>Snakes</td>
<td>4.5</td>
<td>0.182</td>
<td>0.818</td>
<td>0.222</td>
<td>0.999</td>
<td>0.105</td>
<td>0.474</td>
</tr>
<tr>
<td>Superman</td>
<td>4.0</td>
<td>0.103</td>
<td>0.412</td>
<td>0.091</td>
<td>0.363</td>
<td>0.065</td>
<td>0.258</td>
</tr>
<tr>
<td>Dupree</td>
<td>1.0</td>
<td>0.148</td>
<td>0.148</td>
<td>0.4</td>
<td>0.4</td>
<td>0.182</td>
<td>0.182</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>0.433</td>
<td>1.378</td>
<td>0.713</td>
<td>1.762</td>
<td>0.352</td>
<td>0.914</td>
</tr>
<tr>
<td>归一化结果</td>
<td></td>
<td></td>
<td>3.183</td>
<td></td>
<td>2.473</td>
<td></td>
<td>2.598</td>
</tr>
</tbody>
</table>

<p>此处每一行都列出了一部我们曾经观看过的影片，以及对该片的个人评价。对于每一部我们还未曾看过的影片，相应有一列会指出它与已观看影片的相似程度。以 R.x 打头的列给出了我们队影片的评价值乘以相似度之后的结果。</p>

<p>总计一行给出了每部影片相似度评价值的总和以及 R.x 列的总和，为了预测我们对每一部影片的评分情况，只要将 R.x 列的总计值除以相似度一列的总计值即可。</p>

<p>在 <code>recommendations.py</code> 中添加如下代码：</p>

<pre><code class="language-python">def getRecommendedItems(prefs, itemMatch, user):
    userRatings = prefs[user]
    scores = {}
    totlaSim = {}
    
    # 循环遍历由当前用户评分的物品
    for (item, rating) in userRatings.items():
        
        # 循环遍历与当前物品相近的物品
        for (similarity, item2) in itemMatch[item]:
        
            # 如果该用户已经对当前物品做过评价，则将其忽略
            if item2 in userRatings:
                continue
            
            # 评价值与相似度加权之和
            scores.setdefault(item2, 0)
            scores[item2] += similarity * rating
            
            # 全部相似度之和
            totalSim.setdefault(item2, 0)
            totalSim[item2] += similarity
            
    # 将每个合计值除以加权和，求出平均值
    rankings = [(score / totalSim[item], item) for item, score in scores.items()]
    
    # 按最高值到最低值的顺序，返回评分结果
    rankings.sort(reverse=True)
    return rankings
</code></pre>

<p>在 ipython 中测试一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; reload(recommendations)
&gt;&gt;&gt; recommendations.getRecommendedItems(prefs, itemsim, &#39;20&#39;)[:10]
[(5.0, &#39;Zoot Suit (1981)&#39;),
 (5.0, &#39;Zoolander (2001)&#39;),
 (5.0, &#39;Zack and Miri Make a Porno (2008)&#39;),
 (5.0, &quot;You&#39;ve Got Mail (1998)&quot;),
 (5.0, &#39;X-Men: The Last Stand (2006)&#39;),
 (5.0, &#39;X-Men: Apocalypse (2016)&#39;),
 (5.0, &#39;X-Men (2000)&#39;),
 (5.0, &quot;Von Ryan&#39;s Express (1965)&quot;),
 (4.75, &#39;Willow (1988)&#39;),
 (4.75, &quot;White Men Can&#39;t Jump (1992)&quot;)]
</code></pre>

<h2 id="toc_13">基于用户进行过滤还是基于物品进行过滤</h2>

<p>在数据集大小上，基于物品进行过滤的方式要比基于用户进行过滤更快；在数据的稀疏程度上，稀疏的数据集使用基于物品的过滤方法更优，而对于秘密集的数据集而言，两者的效果几乎一样。</p>

<p>基于用户的过滤方法更加易于实现，而且无需额外步骤，因此它通常更适用于规模较小的变化非常频繁的数据集。在一些应用中，告诉用户还有哪些人与自己有着相近偏好是有一定价值的——也许对于一个购物网站而言，我们并不想这么做，但是对于一个音乐分享类或者电影评分类网站而言，这种潜在的需求却是存在的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 Python 科学计算环境]]></title>
    <link href="http://forrestchang.com/14824083276745.html"/>
    <updated>2016-12-22T20:05:27+08:00</updated>
    <id>http://forrestchang.com/14824083276745.html</id>
    <content type="html">
<![CDATA[<p>最近在看《Python for Data Analysis》（利用 Python 进行数据分析）这本书，贴一点笔记，这一篇是关于环境搭建的。另外吐槽一下，书中还是有不少错误的，语法错误就发现了好多处，大概读完了之后会整理出一份勘误表出来，可能是因为写书的时候是 14 年，两年过去了，pandas 库也有了一些变化。</p>

<h2 id="toc_0">安装虚拟环境</h2>

<p>不想把系统的 python 库搞得乱乱的（其实已经很乱了），所以还是建一个独立虚拟环境专门来做科学计算吧。具体的方法我在<a href="http://forrestchang.github.io/2016/07/17/virtualenv-notes/">virtualenv 相关笔记</a>这篇博客中已经详细写了，建议将启动虚拟环境的命令添加到终端的配置文件中去（使用<code>alias</code>），这样就避免每次一打开就输入一长串命令了。</p>

<p>因为科学计算社区的一些库还是基于 Python 2.x 版本的，所以这里我们使用的 Python 版本为 2.7。</p>

<p>然后使用以下命令一键安装所需要的库：</p>

<pre><code class="language-shell">sudo pip install numpy pandas matplotlib jupyter scikit-learn
</code></pre>

<p>安装不上的请检查是不是需要翻墙。</p>

<h2 id="toc_1">IPython</h2>

<p>熟悉 Python 的同学应该对这个解释器不陌生，自带的 Python 解释器实在是太弱了。它与传统的“edit-compile-run”（编辑-编译-运行）方式的区别在于，它鼓励使用“execute-explore”（执行-探索），所以特别适合用在计算和数据分析领域，可以方便得使用「试错法」和「迭代法」进行开发。这里主要介绍它基于 Web 的交互式笔记本功能（命令行中大同小异）。</p>

<h3 id="toc_2">开启 IPython Notebook</h3>

<p>使用以下命令来打开 IPython Notebook：</p>

<pre><code class="language-shell">(ENV2.7)$ jupyter notebook
</code></pre>

<p>这样 server 就启动了，浏览器会自动打开一个目录树。</p>

<p>Note：记住在启动了虚拟环境的状态下使用这条命令，要不然就会使用系统的 IPython 版本来运行。</p>

<p>然后我们新建一个 IPython Notebook 用作演示：</p>

<p><img src="media/14824083276745/14776647413275.jpg" alt="14776647413275"/></p>

<p><code>In [1]</code> 中的命令是为了能让我们直接在 IPython Notebook 中集成显示 <code>matplotlib</code> 画的图片，所以如果是用作科学计算的话，首先先执行以下这条命令再说。</p>

<h3 id="toc_3">内省</h3>

<p>在变量的前面或后面加上一个 <code>?</code> 就可以将有关该对象的一些通用信息显示出来。</p>

<p><img src="media/14824083276745/14776649884990.jpg" alt="14776649884990"/></p>

<p>基本上什么都能看。</p>

<h3 id="toc_4"><code>%run</code> 命令</h3>

<p>使用 <code>%run</code> 可以运行本地的 Python 脚本，并可以在 IPython 中访问脚本中定义的所有变量。</p>

<p>如果想要脚本能够访问 IPython 中的命名空间，可以使用 <code>%run -i</code> 命令。</p>

<h3 id="toc_5">测试代码的执行时间</h3>

<p>使用 <code>%time</code> 和 <code>%timeit</code> 可以用来测试代码的执行时间。</p>

<p><img src="media/14824083276745/14776653395450.jpg" alt="14776653395450"/></p>

<h2 id="toc_6">Example</h2>

<p>下面使用一个具体的例子来演示 IPython Notebook 的使用。</p>

<p>使用到的数据可以在<a href="https://www.ssa.gov/oact/babynames/limits.html">Beyond the Top 1000 Names</a>下载到，这是一份包含1880-2015年每年出生婴儿姓名出现次数的数据表。</p>

<p>由于该数据按年份被分割成了好多文件，所以第一步我们需要把所有数据组装到一个 DataFrame 中去。</p>

<p><img src="media/14824083276745/14776659007521.jpg" alt="14776659007521"/></p>

<p>不知道这些 Python 代码没关系，因为这里只是用来演示 IPython Notebook。</p>

<p>然后我们按照性别和年度统计总出生数：</p>

<p><img src="media/14824083276745/14776660937109.jpg" alt="14776660937109"/></p>

<p>然后绘制出表格：</p>

<p><img src="media/14824083276745/14776661445090.jpg" alt="14776661445090"/></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualenv 相关笔记]]></title>
    <link href="http://forrestchang.com/14824097975366.html"/>
    <updated>2016-12-22T20:29:57+08:00</updated>
    <id>http://forrestchang.com/14824097975366.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">安装</h2>

<p>直接使用 pip 来进行安装：</p>

<pre><code>$ sudo pip install virtualenv
</code></pre>

<h2 id="toc_1">用途</h2>

<p>主要用来创建隔离的 Python 开发环境，比如说一个项目需要用到 2.7 的库，另一个项目需要用到 3.0 的库，我们就可以使用  virtualenv 来分别给这两个项目创建虚拟的 Python 环境，这样可以有效的避免冲突。</p>

<p>virtualenv 会创建一个拥有独立安装目录的 Python 环境，该隔离环境不会与其他 virtualenv 环境共享模块（可以选择是否访问全局安装目录）。</p>

<h2 id="toc_2">使用</h2>

<h3 id="toc_3">创建虚拟环境</h3>

<p>最基本的使用：</p>

<pre><code>$ virtualenv ENV
</code></pre>

<p>其中 <code>ENV</code> 是用来存放虚拟环境的目录。</p>

<pre><code>$tree -L 1 ENV
ENV
├── bin
├── include
├── lib
└── pip-selfcheck.json
</code></pre>

<p>其中 <code>lib</code> 和 <code>include</code> 目录是用来存放新的虚拟 Python 环境的依赖库，Package 被安装到 <code>lib/pythonX.X/site-packages/</code> 中，<code>bin</code> 目录中是新的 Python 解释器。<code>pip</code> 和 <code>setuptools</code> 默认被安装的。</p>

<h3 id="toc_4">active script</h3>

<p>进入虚拟环境：</p>

<pre><code>$ source ENV/bin/active
</code></pre>

<p>（如果 <code>source</code> 命令不存在可以使用 <code>.</code> 命令。）</p>

<p>退出虚拟环境：</p>

<pre><code>$ deactivate
</code></pre>

<h3 id="toc_5">Removing an Environment</h3>

<pre><code>(ENV)$ deactivate
$ rm -r /path/to/ENV
</code></pre>

<h3 id="toc_6"><code>--system-site-packages</code> 选项</h3>

<p>使用 <code>virtualenv --system-site-packages ENV</code> 将会继承全局 packages。并不是很常用的功能。</p>

<h3 id="toc_7">指定 Python 版本</h3>

<p>使用 <code>-p PYTHON_EXE</code> 选项在创建虚拟环境的时候制定 Python 版本。</p>

<p>Python 2.7:</p>

<pre><code>$ virtualenv -p /usr/bin/python2.7 ENV2.7
</code></pre>

<p>Python 3.5:</p>

<pre><code>$ virtualenv -p /usr/local/bin/python3.5 ENV3.5
</code></pre>

<h3 id="toc_8">生成可打包环境</h3>

<p>某些情况下，我们可能需要在别的地方使用这个已经配置好的虚拟环境，可以使用 <code>virtualenv --relocatable</code> 将 ENV 修改为可迁移的。</p>

<pre><code>(ENV)$ virutalenv --relocatable ./
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 中的内存管理]]></title>
    <link href="http://forrestchang.com/14824093902273.html"/>
    <updated>2016-12-22T20:23:10+08:00</updated>
    <id>http://forrestchang.com/14824093902273.html</id>
    <content type="html">
<![CDATA[<p>这篇文章是在阅读《The Swift Programming Language》Automatic Reference Counting（ARC，自动引用计数）一章时做的一些笔记，同时参考了其他的一些资料。</p>

<p>在早期的 iOS 开发中，内存管理是由开发者手动来完成的。因为传统的垃圾回收机制对于移动平台来说十分低效，苹果采用的是引用计数（RC，Reference Counting）的方式来管理内存，开发者需要通过手工的方式增加或减少一个实例的引用计数。在 iOS 5 之后，引入了 ARC 自动引用计数，使得开发者不需要手动地调用 <code>retain</code> 和 <code>release</code> 来管理引用计数，但是实际上这些方法还是会被调用，只不过是交给了编译器来完成，编译器会在合适的地方帮我们加入这些方法。</p>

<p><strong>什么是自动引用计数？</strong></p>

<p>每当你创建一个类的实例的时候，ARC 便会自动分配一块内存空间来存放这个实例的信息，当这个实例不再被使用的时候，ARC 便释放实例所占用的内存。一般每个被管理的实例都会与一个引用计数器相连，这个计数器保存着当前实例被引用的次数，一旦创建一个新的引用指向这个实例，引用计数器便加 1，每当指向该实例的引用失效，引用计数器便减 1，当某个实例的引用计数器变成 0 的时候，这个实例就会被立即销毁。</p>

<p>在 Swift 中，对引用描述的关键字有三个：<code>strong</code>，<code>weak</code> 和 <code>unowned</code>，所有的引用没有特殊说明都是 <code>strong</code> 强引用类型。在 ARC 中，只有指向一个实例的所有 <code>strong</code> 强引用都断开了，这个实例才会被销毁。</p>

<p>举一个简单的例子：</p>

<pre><code class="language-swift">class A {
    let name: String
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;A deinit&quot;)
    }
}

var a1: A?
var a2: A?

a1 = A(name: &quot;A&quot;)
a2 = a1

a1 = nil
</code></pre>

<p>上面这个例子中，虽然 <code>a1</code> 这个 <code>strong</code> 强引用断开了，但是还有 <code>a2</code> 这个强引用指向这个实例，所以不会在命令行中输出 <code>A deinit</code>，当我们把 <code>a2</code> 也设置为 <code>nil</code> 时，与这个实例关联的所有强引用均断开了，这个实例便会被销毁，在命令行中打印 <code>A deinit</code>。</p>

<p><strong>循环强引用（Strong Reference Cycles）</strong></p>

<p>但是，在某些情况下，一个类实例的强引用数永远不能变为 0，例如两个类实例互相持有对方的强引用，因而每个类实例都让对方一直存在，这就是所谓的强引用循环（Strong Reference Cycles）。</p>

<p>这里引用 TSPL 中的例子：</p>

<pre><code class="language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}
</code></pre>

<p>每一个 <code>Person</code> 实例有一个可选的初始化为 <code>nil</code> 的 <code>Apartment</code> 类型，因为一个人并不总是拥有公寓。同样，每一个 <code>Apartment</code> 实例都有一个可选的初始化为 <code>nil</code> 的 <code>Person</code> 类型，因为一个公寓并不总是属于一个人。</p>

<p>接下来的代码片段定义了两个可选类型的变量 <code>john</code> 和 <code>unit4A</code>，并分别设定为下面的 <code>Person</code> 和 <code>Apartment</code> 的实例，这两个变量都备受设定为 <code>nil</code>：</p>

<pre><code class="language-swift">var john: Person?
var unit4A: Apartment?
</code></pre>

<p>现在可以创建特定的 <code>Person</code> 和 <code>Apartment</code> 实例，并将它们赋值给 <code>john</code> 和 <code>unit4A</code> 变量：</p>

<pre><code class="language-swift">john = Person(name: &quot;John Appleseed&quot;)
unit4A = Apartment(unit: &quot;4A&quot;)
</code></pre>

<p>下面一段代码将这两个实例关联起来：</p>

<pre><code class="language-swift">john!.apartment = unit4A
unit4A!.tenant = john
</code></pre>

<p>将两个实例关联在一起后，强引用的关系如图所示：</p>

<p><img src="media/14824093902273/14607053938205.jpg" alt="14607053938205"/></p>

<p>这两个实例关联之后，会产生一个循环强引用，当断开 <code>john</code> 和 <code>unit4A</code> 所持有的强引用时，引用计数器并不会归零，所以这两块空间也得不到释放，这就导致了内存泄漏。</p>

<p>可以将其中一个类中的变量设定为 <code>weak</code> 弱引用来打破这种强引用循环：</p>

<pre><code class="language-swift">class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}
</code></pre>

<p><img src="media/14824093902273/14607057294969.jpg" alt="14607057294969"/></p>

<p>当断开 <code>john</code> 和 <code>unit4A</code> 所持有的强引用时，<code>Person instance</code> 的引用计数器变成 0，实例被销毁，从而 <code>Apartment instance</code> 的引用计数器也变为 0，实例被销毁。</p>

<p><strong>什么时候使用 <code>weak</code>？</strong></p>

<p>当两个实例是 optional 关联在一起时，确保其中的一个使用 <code>weak</code> 弱引用，就像上面所说的那个例子一样。</p>

<p><strong><code>unowned</code> 无主引用</strong></p>

<p>在某些情况下，声明的变量总是有值得时候，我们需要使用 <code>unowned</code> 无主引用。</p>

<p>同样借用一下 TSPL 中的例子：</p>

<pre><code class="language-swift">class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}
</code></pre>

<p>这里定义了两个类，<code>Customer</code> 和 <code>CreditCard</code>，模拟了银行客户和客户的信用卡，在这个例子中，每一个类都是将另一个类的实例作为自身的属性，所以会产生循环强引用。</p>

<p>和之前那个例子不同的是，<code>CreditCard</code> 类中有一个非可选类型的 <code>customer</code> 属性，因为，一个客户可能有或者没有一张信用卡，但是一张信用卡总是关联着一个用户。</p>

<pre><code class="language-swift">var john: Customer?
john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>

<p>关联两个实例后，它们的引用关系如图所示：</p>

<p><img src="media/14824093902273/14607068387297.jpg" alt="14607068387297"/></p>

<p>当断开 <code>john</code> 变量持有的强引用时，再也没有指向 <code>Customer</code> 的强引用了，所以该实例被销毁了，其后，再也没有指向 <code>CreditCard</code> 的强引用了，该实例也被销毁了。</p>

<p><strong>什么时候使用 <code>unowned</code> 无主引用？</strong></p>

<p>两个实例 A 和 B，如果实例 A 必须在实例 B 存在的前提下才能存在，那么实例 A 必须用 <code>unowned</code> 无主引用指向实例 B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。</p>

<p>例如上面那个例子所说，银行客户可能没有信用卡，但是每张信用卡总是绑定着一个银行客户，所以信用卡这个类就需要用 <code>unowned</code> 无主引用。</p>

<p><strong>无主引用以及隐市解析可选属性</strong></p>

<p>还有一种情况，两个属性都必须有值，并且初始化完成之后永远不会为 <code>nil</code>。在这种情况下，需要一个类使用 <code>unowned</code> 无主引用，另一个类使用<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选属性</a>。</p>

<p><strong>闭包引起的循环强引用</strong></p>

<p>在 Swift 中，闭包和函数都属于引用类型。并且闭包还有一个特性：可以在其定义的上下文中捕获常量或者变量。所以，在一个类中，闭包被赋值给了一个属性，而这个闭包又使用了这个类的实例的时候，就会引起循环强引用。</p>

<p>Swift 提供了一种方法来解决这个问题：闭包捕获列表（closure capture list）。在定义闭包的同时定义捕获列表作为闭包的一部分，捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例之间的循环强引用一样，声明每个捕获的引用为弱引用或者无主引用。</p>

<p>捕获列表中的每一项都由一对元素组成，一个元素是 <code>weak</code> 或者 <code>unowned</code> 关键字，另一个元素是类实例的引用（例如最常见得是 <code>self</code>），这些在方括号内用逗号隔开。</p>

<p>具体的使用方法请参考<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/16_Automatic_Reference_Counting.html#resolving_strong_reference_cycles_for_closures">官方文档</a>。</p>

<p><strong>何时使用 <code>weak</code>，何时使用 <code>unowned</code></strong></p>

<p>在闭包和捕获的实例总是相互引用并且总是同时销毁的时候，将闭包内的捕获定义为 <code>unowned</code> 无主引用。</p>

<p>在被捕获的实例可能变成 <code>nil</code> 的情况下，使用 <code>weak</code> 弱引用。如果被捕获的引用绝对不会变成 <code>nil</code>，应该使用 <code>unowned</code> 无主引用，而不是 <code>weak</code> 弱引用。</p>

<p><strong>Garbage Collection（GC，垃圾回收）</strong></p>

<p>其实 ARC 应该也算 GC 的一种，不过我们一谈到 GC，大多都会想到 Java 中的垃圾回收机制，相比较 GC，ARC 简单得许多。以后有机会可以讨论一下 Java 中的内存管理。</p>

<p>另外，需要注意的一点是，这里所讲的都是针对于<code>引用类型</code>，<code>结构体</code>和<code>枚举</code>在 Swift 中属于值类型，不在 ARC 的考虑范围之内。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[时间记录不完全指北]]></title>
    <link href="http://forrestchang.com/14824089876210.html"/>
    <updated>2016-12-22T20:16:27+08:00</updated>
    <id>http://forrestchang.com/14824089876210.html</id>
    <content type="html">
<![CDATA[<p>两年前，曾经写过一篇有关时间管理的<a href="http://forrestchang.com/14824097073807.html">文章</a>，那个时候还在上高二，对于时间管理仅仅是有一点肤浅的了解，自然写出来的文字也是比较幼稚的。经过两年的实践，积累了很多时间管理的经验，想要拿出来分享一下。预计会写一个系列，包括使用的工具和日常的 Workflow。</p>

<p>日常使用的工具有这些：</p>

<ul>
<li>纸质笔记本（Moleskine）</li>
<li>OmniFocus</li>
<li>Evernote</li>
<li>Toggl</li>
</ul>

<p>这篇文章从题目也可以看出来，主要讲一些关于时间记录的内容，对应的工具是 Toggl。关于 Toggl，我已经在知乎的<a href="https://www.zhihu.com/question/36546814/answer/69161024">一个回答</a>里面推荐过了，这里会更加详细地介绍一下使用流程，在谈论术之前，先来说说道的问题，为什么要做时间记录。</p>

<p>其实我们对时间是很不敏感的，相信你一定有过这样的体验：早晨醒来，干劲满满，准备打开电脑把昨天没有写完的代码解决，这时想到邮件还没看，先查一下邮件吧，反正花不了多少时间，在查看邮件的时候又发现知乎上有人给你发私信了，在到知乎上看一下私信，顺便回复一下，既然上了知乎，那么去首页看看订阅的内容里面有没有什么有意思的东西吧，看到一个有意思的回答，是推荐你买买买的，于是乎又打开淘宝看了看商品的具体情况，顺便加到购物车里，这是候发现已经中午了，算了，先去吃饭吧，代码等等吃完饭再写，吃过午饭后又觉得有一点困意，那就睡一会儿吧，一觉醒来，发现已经四点多了，不行了，赶紧写代码，等等，这个 bug 好像找不到问题所在啊，算了，去 Stack Overflow 上找找吧，在 Stack Overflow 上找到了答案，链接到一篇具体的解释文章，点进去看了看，发现太长了，还是先加到 Pocket 中，以后再看吧，这个人的博客似乎写得不错，浏览一下 Archive 页面看看还有没有其他的好文章，从头到尾浏览了一遍，心中不禁惊叹，写得真好！然后想到今天 Reddit 好像还没看，说不定又有什么好东西，于是又上 /r/programming 刷了一会儿，看到了几篇牛逼的文章，时间也不早了，该吃晚饭了，吃完晚饭自然又不想写代码，休息一会儿，逛一下 Bilibili 吧，看了几个视频之后突然想到今天的代码还没有写，于是又接着关掉网页去写代码，搞到深夜，终于把代码写完了，朋友圈发一条状态「奋战到深夜，终于把代码改完了！」。</p>

<p>多么充实的一天，你这样想到，今天似乎做了很多事情。但是实际上呢？有效的时间几乎只有两三个小时。所以你需要把做什么事用了多长时间记录下来，然后就会发现这「充实」的一天过得是多么可怕了。</p>

<p>根据这些时间的时间记录的经验来看，至少有以下三点好处：</p>

<ol>
<li>提高对时间的感知能力，发现和避免时间黑洞。记录下时间的时候，你会刻意地关注目前手上正在做的事，如果是一些浪费时间的事，会使你减少花在上面的时间。</li>
<li>更好地制定计划。有段时间给自己制定的计划老是不能够完成，目标定得太高，再怎么跳也抓不到，通过记录一些事情所花费的时间，就可以更好地做计划，比如说看完一本书需要用多少时间。</li>
<li>激励自己。积累了一段时间的数据之后，就可以看到在某一方面投入了多少时间了，根据 10000 小时定律，可以知道自己与专家级别的能力还相差多少。</li>
</ol>

<p>当然，凡事有利就必有弊。</p>

<ol>
<li>时间记录本身也会花费时间（可以通过工具来弥补）。</li>
<li>最开始的时候总是会忘记记录。</li>
<li>事无巨细地记录时间，增加压力（这一点会在下面详细说明）。</li>
</ol>

<p>简单地讲了一下「道」层面的问题，想要继续深入的可以看一下<a href="https://book.douban.com/subject/1115353/">《奇特的一生》</a>这本书。下面说一说「术」的层面。</p>

<h3 id="toc_0">简单的系统</h3>

<p>其实最开始的时候一支笔、一本本子、一块手表就够了，这一阶段主要是养成时间记录的习惯，当然使用 Evernote 或者 OneNote 之类的软件也是可以的。可以按照以下的模板来记录：</p>

<blockquote>
<p>2016/04/10<br/>
7:00 - 8:30 阅读 xxx xx 页（1h30min）<br/>
9:00 - 9:45 完成 xxx 项目 xx 功能的开发（45min）<br/>
...</p>

<p>总结：<br/>
编程时间：xx h xx min<br/>
阅读时间：xx h xx min<br/>
有效时间合计：xx h xx min<br/>
娱乐时间：xx h xx min<br/>
...</p>
</blockquote>

<p>具体的分类可以根据自己的需求来进行。如果对时间记录没有接触过的同学可以选择这个方法试着用一段时间，看有没有什么改变。</p>

<h3 id="toc_1">Toggl</h3>

<p>前面说了这么多，中与引来了今天的主角：<a href="https://www.toggl.com/">Toggl</a>。什么是 Toggl，简单得来说，是一款时间记录的工具，试用过市面上几乎所有时间记录的工具，发现 Toggl 是最符合《奇特的一生》中的工作流的。</p>

<h4 id="toc_2">安装</h4>

<p>Toggl 几乎包含了全部平台，其中最强大的属于 Web 版，各种高级的报表功能需要在 Web 版上面才能试使用。</p>

<ul>
<li><a href="https://www.toggl.com/best-free-time-tracking-app-for-iphone">iPhone App</a></li>
<li><a href="https://www.toggl.com/best-free-time-tracking-app-for-android">Android App</a></li>
<li><a href="https://support.toggl.com/toggl-desktop-for-windows">Windows Desktop App</a></li>
<li><a href="https://support.toggl.com/toggl-desktop-for-mac-osx">Mac Desktop App</a></li>
<li><a href="https://support.toggl.com/toggl-desktop-for-linux">Linux Desktop App</a></li>
</ul>

<p>并且它还提供了 <a href="https://github.com/toggl/toggl_api_docs/blob/master/toggl_api.md">API</a>，可以自由定制。</p>

<h4 id="toc_3">基本使用</h4>

<p>下面主要介绍 Web 版的内容。注册完登陆进计时页面就是如下图所示：</p>

<p><img src="media/14824089876210/14602871668402.jpg" alt="14602871668402"/></p>

<ol>
<li>你当前正在记录的内容（如果不确定，可以先不填，这个是比其他软件优秀的原因之一，有时候只是想先记录下时间，之后再进行区分）；</li>
<li>当前记录内容所属分类，可以添加 Tag，后面的美元符号可以添加这个任务的花费，基本没有用到过这个功能；</li>
<li>记录的时间，可以手动添加时间；</li>
<li>Timeline，每天做了什么事情用了多少时间就记录在这里（周六周日没有怎么使用，所以比较空）；</li>
<li>一周记录时间汇总。</li>
</ol>

<p>知道了以上的内容之后就可以开始记录了，比如说就把学习 Toggl 的使用当成第一个记录的内容。</p>

<h4 id="toc_4">更好的分类</h4>

<p>详细的分类可以更好地输出报表。我使用的是三级的分类：大类-具体领域分类-task。Toggl 默认只可以使用两个层级的分类，Project - Task，但是可以把 Client 这个用作最大的分类，这样就可以进行三个层级的分类，下面是我的分类内容；</p>

<ul>
<li>基本工作（Client）

<ul>
<li>计算机（Project）</li>
<li>英语</li>
<li>健身</li>
<li>写作</li>
<li>阅读</li>
<li>工作（几乎用不到，因为还在学校里）</li>
</ul></li>
<li>固定日程

<ul>
<li>上课</li>
<li>睡觉</li>
<li>杂事</li>
</ul></li>
<li>娱乐

<ul>
<li>上网</li>
<li>游戏</li>
<li>视频/电影</li>
</ul></li>
</ul>

<p>分级不宜过多，否则会增加选择的压力，可以在使用的过程中不断改进。</p>

<p>最大的类别（Clients）可以在 Workspace Settings 中添加：</p>

<p><img src="media/14824089876210/14602879238718.jpg" alt="14602879238718"/></p>

<p>Project 的类别在 Projects 选项中添加，可以给每个 Project 不同的颜色以示区分。</p>

<p>Tag 很少使用，可以为一些相同类型的事情设定相关的 Tag 来作为补充。</p>

<h4 id="toc_5">强大的统计功能</h4>

<p>使用纸笔做时间记录的麻烦之处就是统计的时候需要花费很多精力去计算，用 APP 就可以免除这些过程，直接根据记录的内容生成非常漂亮的报表，下面的是我这一周的统计内容，从柱状图可以看出这周的效率是逐渐递减的-_-|||</p>

<p><img src="media/14824089876210/14602882623445.jpg" alt="14602882623445"/></p>

<p>Reports 支持三种模式：Summary, Detailed, Weekly。上面的是 Summary 的 Reports，Detailed 会把你做的所有事情列出来，Weekly 会以周视图的方式来显示：</p>

<p><img src="media/14824089876210/14602884725256.jpg" alt="14602884725256"/></p>

<p>Reports 支持强大的过滤功能，可以根据需要选择 Reports 的时间长度、Project 内容、Tag 内容等等。比如说我想查看这周用在 iOS Dev 上的时间是多少，只需要选择 iOS Dev 这个 Tag 就可以了：</p>

<p><img src="media/14824089876210/14602886317764.jpg" alt="14602886317764"/></p>

<h4 id="toc_6">Dashboard</h4>

<p>Toggl 还提供了仪表盘视图，在这里你可以看到最常 Track 的项目以及一些其他内容。</p>

<p><img src="media/14824089876210/14602889789430.jpg" alt="14602889789430"/></p>

<p>如果在本地 APP 里面打开了 Timeline Track，还可以在 Timeline For Today 这一栏里面查看使用了什么软件，用了多长时间。</p>

<h4 id="toc_7">Workflow</h4>

<p>每天从 Todo 里面拿出一件事情，打开计时器，开始做，本着「做一件事情就把它做好的原则」去完成。积累了一段时间的数据之后，就可以更好地计划自己了，比如说本周阅读多少专业书籍，写多少代码。具体的 Workflow 需要结合 OmniFocus 和笔记本来完成，所以会在下一篇文章中来说明。</p>

<h4 id="toc_8">FAQ</h4>

<h5 id="toc_9">什么事情都需要记录吗？</h5>

<p>只需要记录重要的事情。日常生活中的吃喝拉撒记录了没有任何用处，有一段时间我一直在记录自己的睡眠时间，不过后来固定了之后就不记录了。</p>

<h5 id="toc_10">忘了记录怎么办？</h5>

<p>这个只能慢慢地养成记录的习惯，如果记得大概的时间的话，可以手动录入时间。</p>

<h5 id="toc_11">手边没有电脑怎么办？</h5>

<p>一般我都是用手机进行记录，如果连手机也不在手边的话，可以先拿张纸记着，之后再手动录入上去。</p>

<h3 id="toc_12">后记</h3>

<p>其实，等你做了一段时间的时间日志会发现，会发现效率并没有提高多少，有时候不得不承认这个悲伤的事实，根据自己的时间日志，最高效的一天记录了 7 个小时的学习时间，相比较那些动不动就每天学习 8 小时的人来说，还是差太多了，不过好歹也算是做出了一点点努力。</p>

<p>写这篇文章的契机是看到了 pluskid 写的<a href="http://freemind.pluskid.org/misc/knowledge-accumulate/">《关于知识整理、积累与记忆》</a>，想到自己也有挺多经验可以分享的，于是便以试试的心态动笔开始写。</p>

<p>仓促成文，错误在所难免，还望指正。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 基础笔记]]></title>
    <link href="http://forrestchang.com/linux-basic.html"/>
    <updated>2016-03-23T11:09:38+08:00</updated>
    <id>http://forrestchang.com/linux-basic.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Shell 的基本操作</h2>

<h3 id="toc_1">常用快捷键</h3>

<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Tab</code></td>
<td>命令补全</td>
</tr>
<tr>
<td><code>Ctrl+c</code></td>
<td>强行终止当前程序</td>
</tr>
<tr>
<td><code>Ctrl+d</code></td>
<td>键盘输入结束或退出终端</td>
</tr>
<tr>
<td><code>Ctrl+s</code></td>
<td>暂定当前程序，暂停后按下任意键恢复运行</td>
</tr>
<tr>
<td><code>Ctrl+z</code></td>
<td>将当前程序放到后台运行，恢复到前台命令 <code>fg</code></td>
</tr>
<tr>
<td><code>Ctrl+a</code></td>
<td>将光标移动到行首</td>
</tr>
<tr>
<td><code>Ctrl+e</code></td>
<td>将光标移动到行尾</td>
</tr>
<tr>
<td><code>Ctrl+k</code></td>
<td>删除从光标所在位置到行末</td>
</tr>
<tr>
<td><code>Alt+Backspace</code></td>
<td>向前删除一个单词</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">常用通配符</h3>

<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>*</code></td>
<td>匹配0或多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配 list 中的任意单一字符</td>
</tr>
<tr>
<td><code>[!list]</code></td>
<td>匹配除 list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td><code>[c1-c2]</code></td>
<td>匹配c1-c2中的任意单一字符，如[0-9][a-z]</td>
</tr>
<tr>
<td><code>{string1,string2,...}</code></td>
<td>匹配其中一个字符串</td>
</tr>
<tr>
<td><code>{c2..c2</code></td>
<td>匹配c1-c2中全部字符，如{1..10}</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">用户管理</h2>

<h3 id="toc_4">查看用户</h3>

<pre><code>$ who am i
</code></pre>

<p>或者</p>

<pre><code>$ who mon likes
</code></pre>

<p><code>who</code> 命令其他常用参数</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-a</code></td>
<td>打印能打印的全部</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>打印死掉的进程</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>同 <code>am i</code>, <code>mom likes</code></td>
</tr>
<tr>
<td><code>-q</code></td>
<td>打印当前登陆用户数及用户名</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>打印当前登陆用户登陆信息</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>打印运行等级</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">创建用户</h3>

<p>创建用户需要 <code>root</code> 用户的权限，所以需要使用 <code>sudo</code> 这个命令。使用 <code>sudo</code> 名利需要满足两个条件：</p>

<ol>
<li>知道当前登陆用户的密码</li>
<li>当前用户必须在 <code>sudo</code> 用户组</li>
</ol>

<pre><code>$ su &lt;user&gt; # 切换用户到 user
</code></pre>

<pre><code>$ sudo &lt;cmd&gt; # 以 root 权限运行命令
</code></pre>

<pre><code>$ su - &lt;user&gt; # 切换用户，并且环境变量同时改变到目标用户的环境变量
</code></pre>

<p>新建用户命令：</p>

<pre><code>$ sudo adduser &lt;username&gt;
</code></pre>

<p>创建用户的同时会为用户创建 home 目录。</p>

<h3 id="toc_6">用户组</h3>

<p>在 Linux 中每个用户都有一个用户组，它们共享一些资源和权限，同时拥有私有资源。</p>

<h4 id="toc_7">查看自己的用户组</h4>

<pre><code>$ groups &lt;username&gt;
</code></pre>

<p>或者，查看<code>/etc/group</code>文件</p>

<pre><code>$ cat /etc/group | sort
</code></pre>

<p><code>sort</code> 表示将读取的文本进行一个字典排序再输出。</p>

<h5 id="toc_8"><code>etc/group</code> 文件格式说明</h5>

<p>/etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：</p>

<blockquote>
<p>group_name:password:GID:user_list</p>
</blockquote>

<h4 id="toc_9">将其他用户加入 sudo 用户组</h4>

<p>使用 <code>usermod</code> 命令可以为用户组添加用户，使用该命令需要有 root 权限。</p>

<p>使用一个具有 root 权限的用户为一个不具有 root 权限的用户添加 <code>sudo</code> 权限：</p>

<pre><code>$ sudo usermod -G sudo &lt;username&gt;
</code></pre>

<h3 id="toc_10">删除用户</h3>

<pre><code>$ sudo deluser &lt;username&gt; --remove-home
</code></pre>

<h2 id="toc_11">文件权限</h2>

<h3 id="toc_12">查看文件权限</h3>

<pre><code>$ ls -l
</code></pre>

<p><img src="media/14587025785185/14587048876862.jpg" alt=""/></p>

<p><img src="media/14587025785185/14587049042865.jpg" alt=""/></p>

<p><img src="media/14587025785185/14587049141674.jpg" alt=""/></p>

<h4 id="toc_13">文件类型</h4>

<p>Linux 里面一切皆文件。</p>

<h4 id="toc_14">文件权限</h4>

<ul>
<li>读权限：可以读取某个文件的内容</li>
<li>写权限：可以编辑和修改某个文件</li>
<li>执行权限：通常指可以运行的二进制程序文件或者脚本文件</li>
</ul>

<p>注：一个目录要同时具有读权限和执行权限才可以打开，要有写权限才允许在其中创建其他文件。Linux 不是用过文件的后缀名来区分文件的类型。</p>

<h4 id="toc_15">链接数</h4>

<p>链接到该文件所在的 inode 结点的文件名数目。</p>

<h3 id="toc_16">修改文件权限</h3>

<h4 id="toc_17">方法1：二进制数字表示</h4>

<p><img src="media/14587025785185/14587054006459.jpg" alt=""/></p>

<p>修改<filename>只能自己使用：</p>

<pre><code>$ chmod 700 &lt;filename&gt;
</code></pre>

<h4 id="toc_18">方法2：加减赋值操作</h4>

<pre><code>$ chmod go-rw &lt;filename&gt;
</code></pre>

<p>&#39;g&#39;&#39;o&#39;还有&#39;u&#39;，分别表示group，others，user，&#39;+&#39;，&#39;-&#39; 就分别表示增加和去掉相应的权限。</p>

<h2 id="toc_19">目录结构</h2>

<p>Windows 是以存储介质为主的，之下才是目录；而 Unix 是以目录为主的，存储介质是挂载在目录上的。Linux 以树形目录结构的形式来构建整个系统。</p>

<h3 id="toc_20">FHS 标准</h3>

<blockquote>
<p>FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。</p>
</blockquote>

<p>FHS 定义了两层规范，第一层是，/下面的各个目录应该要放什么文件数据，例如 /etc 应该要放设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。</p>

<p>第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件，/usr/share 放置共享数据等等。</p>

<p><img src="media/14587025785185/14587064442333.jpg" alt=""/></p>

<p>FSH 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会持续更新，FSH 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四中交互作用的形态，如下表示：</p>

<p><img src="media/14587025785185/14587065471253.jpg" alt=""/></p>

<h3 id="toc_21">目录路径</h3>

<h4 id="toc_22">绝对路径</h4>

<p>以根目录为起点的完整路径。</p>

<h4 id="toc_23">相对路径</h4>

<p>相对于你当前目录的路径。</p>

<h2 id="toc_24">文件的基本操作</h2>

<h3 id="toc_25">新建</h3>

<h4 id="toc_26">新建空白文件</h4>

<pre><code>$ touch test
</code></pre>

<p>关于 <code>touch</code> 命令，其主要是用来更改文件时间戳的。</p>

<h4 id="toc_27">新建目录</h4>

<pre><code>$ mkdir testDir
</code></pre>

<p>使用 <code>-p</code> 参数，可以创建一个多级目录，例如：</p>

<pre><code>$ mkdir -p father/son/grandson
</code></pre>

<h3 id="toc_28">复制</h3>

<h4 id="toc_29">复制文件</h4>

<pre><code>$ cp test testDir
</code></pre>

<h4 id="toc_30">复制目录</h4>

<pre><code>$ cp -r father family
</code></pre>

<h3 id="toc_31">删除</h3>

<pre><code>$ rm test
</code></pre>

<p>参数 <code>-f</code> 可以强制删除一些为只读权限的文件。</p>

<pre><code>$ rm -f test
</code></pre>

<p>删除一个目录：</p>

<pre><code>$ rm -r testDir
</code></pre>

<h3 id="toc_32">移动文件</h3>

<pre><code>$ mv testFile testDir
</code></pre>

<h3 id="toc_33">重命名文件</h3>

<p><code>mv</code> 命令还有重命名的作用：</p>

<pre><code>$ mv oldName newName
</code></pre>

<h3 id="toc_34">查看文件</h3>

<h4 id="toc_35"><code>cat</code> 与 <code>tac</code></h4>

<p>这两个命令都是用来打印文件内容到标准输出（终端），其中<code>cat</code> 为正序显示，<code>tac</code> 为倒序显示。</p>

<blockquote>
<p>标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘；标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。</p>
</blockquote>

<p>可以使用<code>-n</code> 参数来显示行号：</p>

<pre><code>$ cat -n &lt;filename&gt;
</code></pre>

<h4 id="toc_36"><code>nl</code></h4>

<p>添加行号并打印，比 <code>cat</code> 更加强大，参数说明：</p>

<pre><code>-b : 指定添加行号的方式，主要有两种：
    -b a:表示无论是否为空行，同样列出行号(&quot;cat -n&quot;就是这种方式)
    -b t:只列出非空行的编号并列出（默认为这种方式）
-n : 设置行号的样式，主要有三种：
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示，且不加 0
    -n rz:在行号字段最右边显示，且加 0
-w : 行号字段占用的位数(默认为 6 位)
</code></pre>

<h3 id="toc_37">查看文件类型</h3>

<p>使用 <code>file</code> 命令来查看文件类型：</p>

<pre><code>$ file /bin/ls
</code></pre>

<p><img src="media/14587025785185/14587183045128.jpg" alt=""/></p>

<p>这表示这是一个可执行文件。</p>

<h2 id="toc_38">环境变量</h2>

<h3 id="toc_39">变量</h3>

<p>使用<code>declare</code>命令可以创建一个变量：</p>

<pre><code>$ declare tmp
</code></pre>

<p>读取变量的值，使用<code>echo</code>命令和<code>$</code>符号：</p>

<pre><code>$ echo $tmp
</code></pre>

<h3 id="toc_40">环境变量</h3>

<p>环境变量就是作用域比自己定义的变量要大，如 Shell 的环境变量作用于自身和它的子进程。例如 Shell 环境变量作用于自身和它的子进程。在类 UNIX 系统中，每个进程都有其各自的环境变量设置，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。</p>

<p>通常我们会涉及到的环境变量有三种：</p>

<ul>
<li>当前 Shell 进程私有用户自定义变量，只在当前 Shell 中有效</li>
<li>Shell 本身内建的变量</li>
<li>从自定义变量导出的环境变量</li>
</ul>

<p><code>set</code>, <code>env</code>, <code>export</code>这三个命令可以用来打印相关环境变量，区别在于涉及的是不同范围的环境变量：</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>set</code></td>
<td>显示当前 shell 所有环境变量，包括其内建环境变量、用户自定义变量及导出的环境变量</td>
</tr>
<tr>
<td><code>env</code></td>
<td>显示与当前用户相关的环境变量，还可以让命令在制定环境中运行</td>
</tr>
<tr>
<td><code>export</code></td>
<td>显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量</td>
</tr>
</tbody>
</table>

<p><img src="media/14587025785185/14592405427797.jpg" alt=""/></p>

<h3 id="toc_41">命令的查找路径与顺序</h3>

<p>Shell 通过环境变量<code>PATH</code>来搜索命令。</p>

<p>查看 <code>PATH</code> 环境变量的内容：</p>

<pre><code>$ echo $PATH
</code></pre>

<p>输出的内容为：</p>

<pre><code>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
</code></pre>

<p>这些目录下面存放的都是可执行文件。</p>

<h3 id="toc_42">添加自定义路径到<code>PATH</code> 环境变量</h3>

<p><code>PATH</code>里面的路径是以<code>:</code>作为分隔符，所以可以这样添加自定义路径：</p>

<pre><code>$ PATH=$PATH:/home/xxxx
</code></pre>

<p>注意到这里一定要使用绝对路径。</p>

<p>这种修改的方式只对当前的 Shell 有效，要想让每个用户都讷讷够使用，需要更改相应的配置文件，例如<code>zsh</code>需要修改相应的<code>.zshrc</code>。</p>

<h3 id="toc_43">修改和删除已有变量</h3>

<p>可以使用<code>unset</code>命令来删除一个环境变量：</p>

<pre><code>$ unset temp
</code></pre>

<h3 id="toc_44">如何让环境变量立即生效</h3>

<p>在修改了配置文件后，可以使用<code>source</code>命令来让其立即生效：</p>

<pre><code>$ source .zshrc
</code></pre>

<h2 id="toc_45">搜索文件</h2>

<h3 id="toc_46"><code>whereis</code>简单快速</h3>

<pre><code>$ whereis who
</code></pre>

<p><code>whereis</code>只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。</p>

<h3 id="toc_47"><code>locate</code>快而全</h3>

<p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行<code>updatedb</code>命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次<code>updatedb</code>命令。他可以用来查找指定目录下的不同文件类型，例如查找/usr/share/下所有的 jpg 文件：</p>

<pre><code>$ locate /usr/share/\*.jpg
</code></pre>

<p>注意要添加<code>*</code>号前面的反斜杠转义，否则会无法找到</p>

<h3 id="toc_48"><code>which</code>小而精</h3>

<p>我们通常使用<code>which</code>来确定是否安装了某个指定的软件，因为它只从<code>PATH</code> 环境变量指定的路径中去搜索命令：</p>

<pre><code>$ which man
</code></pre>

<h3 id="toc_49"><code>find</code> 精而细</h3>

<p><code>find</code>命令应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找，而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p>

<p>在指定目录下搜索指定文件名的文件：</p>

<pre><code>$ find /etc/ -name interface
</code></pre>

<p><code>find</code> 命令的基本参数格式为：<code>find [path] [option] [action]</code></p>

<p>与时间相关的命令参数：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-atime</code></td>
<td>最后访问时间</td>
</tr>
<tr>
<td><code>-ctime</code></td>
<td>创建时间</td>
</tr>
<tr>
<td><code>-mtime</code></td>
<td>最后修改时间</td>
</tr>
</tbody>
</table>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Music，古典音乐，阅读]]></title>
    <link href="http://forrestchang.com/14824082548997.html"/>
    <updated>2016-12-22T20:04:14+08:00</updated>
    <id>http://forrestchang.com/14824082548997.html</id>
    <content type="html">
<![CDATA[<h3 id="toc_0">Apple Music</h3>

<p>自从Apple Music（以下简称「AM」）发布以来，就一直在使用，从最开始的免费试用到现在每个月10￥的订阅。自从Windows时代就使用iTunes听音乐了（当时有一部iPod），在没有AM的时候，都是从论坛下好别人买的专辑来听。一方面在国内想要在iTunes Store上购买专辑过于麻烦（两个账号需要来回切换），另一方面作为一个学生党iTunes Store上两首歌就相当于一顿饭的价钱对于我来说也有点小贵了，所以AM刚推出的时候，还是比较开心的，没想到入华后价格竟然只要10￥每月，就只相当于两首歌的钱！</p>

<p>这几个月使用下来，发现还是存在不少的问题。</p>

<ol>
<li>操作逻辑复杂。例如听到一首好听的歌，标注了心之后，它是不会出现在你的播放列表中的，因为标注心只是为了优化推荐的算法。所以每次听到一首好听的曲子，都要进行两个步骤：先添加到库中，再标注心。这样才会在你的Smart Playlist中显示出来。这个估计是iTunes的遗留问题，因为iTunes是以Library的方式来管理的，所以需要先添加进Library中，才能进行进一步的操作，不过AM作为一个流媒体音乐服务，这样做显然是多此一举了。</li>
<li>每个设备间同步存在问题。我一般都是在Mac上听音乐，不过偶尔也会使用iPhone来听，但是很多加心得歌曲到了iPhone上面就变成没有加心的了。所以现在我也懒得使用iPhone来听歌了，或者就随便打开一个推荐的播放列表来听。</li>
<li>网络问题。这个应该是最要吐槽的一点了，听歌时断时续是最不能忍的事情了。不知道是Apple在国内没有设置服务器还是什么其他原因，有时候即使开着代理缓冲的速度也很慢。有些专辑就只能先下载下来，然后再听。</li>
</ol>

<p>这是我使用过程中遇到的三个比较影响体验的问题，当然还有其他小的，比如说什么中文歌的名字全是英文（使用英文系统的原因，日文歌的名字全是罗马音等等之类的，只不过这些暂时还能够忍受，不是太影响听音乐的体验（个人很少听中文和日文的歌曲）。</p>

<p>作为一个数据控，如果听歌的数据不能够记录下来，那么就好像和没听一样（强迫症的症状），虽然iTunes也可以记录歌曲的播放次数，上一次播放时间之类的数据，不过还是过于简单了。之前一直使用的是Last.fm，使用AM了之后发现Last.fm的客户端没办法抓取到数据了，后来找到了「Bowtie」这个小工具，连Radio中播放的内容都能够抓取到，太强大了。分析一首歌听了多少遍的意义并不是很大，但是累计了这么多的数据之后还是可以发现了一些有趣的东西的，比如说我听的最多的歌手是竟然是「ColdPlay」。</p>

<p>如果作为一个音乐服务来说，AM还存在着很多问题，不过毕竟还是一个新生的流媒体服务，希望下一次大的更新之后能够提高一些用户体验。</p>

<p>PS. 也使用过一段时间的Xiami和网易云音乐，因为种种原因放弃了。</p>

<h3 id="toc_1">古典音乐</h3>

<p>关于古典音乐，其实我只有很少的了解，也只听过很少的入门曲目，最开始听古典是因为「The 50 Most Essential Pieces of Classical Music」这张专辑，这张专辑里面基本上都是一些非常经典的曲目，例如当初看《V字仇杀队》中的「1812 Festival Overture」，以及每个人都熟悉的「Canon in D Major」，如果从来没听过古典，推荐去听一下这个专辑，一定会发现很多熟悉的音乐。</p>

<p>上学期选修了一门《西方古典音乐鉴赏》，然而并没有很认真地听课，不过还是了解了一些知识。然后看了木遥在博客上的一系列<a href="http://blog.farmostwood.net/305.html">介绍古典音乐的文章</a>，算是对古典音乐有了一个初步的认识。</p>

<p>如果说是欣赏古典音乐，还是达不到那个层次的，因为现在古典音乐的作用就是在阅读或者写代码的时候提供一个相对较安静的环境，说白了，还是出于一种功利的目的在听（为了更好地完成其他工作）。</p>

<p>今天听AM的Classical Radio听到很很多以前听过，但是忘了名字的曲子（不得不说，古典音乐的曲子名字太难记了），统统加心添加进Library中。现在听音乐的基本流程就是，先范听，听到喜欢的在去把Artist的所有作品依次听下去，这样会找到不少喜欢的内容。</p>

<h3 id="toc_2">阅读</h3>

<p>前几天Kindle上突然推送了有关Kindle Unlimited的内容，类似于AM，按月订阅，然后可以阅读所有的订阅内容。刚开始还是蛮高兴的，不过看了一下在计划中的书目，基本上没有想看的，果然想看的书还是需要付费啊。不过有7天的试用时间，不用白不用，昨天读了一本漫画书《时间管理：如何充分利用你的24小时》，很有趣的一本小册子。这个漫画好像是一个系列，准备最近把感兴趣的都看一遍。</p>

<p>最近看书的时间有点少了，而更多的时间都在看RSS订阅的内容，Pocket上存档的文章，以及知乎、Quora、Reddit、Hacker News上的一些文字。毫无疑问，书籍的信噪比肯定是大于后者之流的，如果要搞一个排名的话，信噪比的大小应该是这样的：书籍 &gt; Pocket上存档的文章 &gt; Hacker News = Reddit &gt; RSS订阅内容 &gt; Quora &gt;= 知乎（至少Quora可以练习一下英语，笑）。当然，如果你是整天阅读微信朋友圈以及QQ空间，那么信噪比可能会 &lt; 1。</p>

<hr/>

<p>以上是深夜的无聊吐槽内容，本来这段时间应该是去写代码或者阅读其他内容的，只不过因为结构化拖延的原因才来写Blog……</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学院派编程自学指南]]></title>
    <link href="http://forrestchang.com/14824091738545.html"/>
    <updated>2016-12-22T20:19:33+08:00</updated>
    <id>http://forrestchang.com/14824091738545.html</id>
    <content type="html">
<![CDATA[<p>由于本人目前也处在学习的阶段，文章中列出来的内容也并未全部学习过，所以文章的客观性可能存在一些问题，还望读者自行判断。</p>

<p>这份指南会不定期更新，有好的建议也可以留言或者给我发邮件。</p>

<h1 id="toc_0">准备</h1>

<p>需要的所有工具就是一台可以连接上网络的电脑以及你本人。</p>

<h2 id="toc_1">科学上网</h2>

<p>很可惜，即使是现在，大部分学习计算机的学生还是不会科学上网。在当前的网络环境下，不会科学上网，意味着你不能用Google查资料，不能再Reddit看最新的资讯，需要忍受龟速的GitHub，云云。然而，科学上网本身却是一件成本非常低的事情，不想折腾的话，一年花个几百块钱买个现成的服务；有折腾精神的人，可以买个服务器自己假设架设上网工具。这一步很重要，不能跳过，否则后面指南中的许多内容对你来说只能是404了。</p>

<p>关于科学上网的具体内容，就不再多说了，给你一个关键词：<strong>Lantern</strong>。</p>

<h2 id="toc_2">学会使用Google搜索</h2>

<p>学会了科学上网，你就能够使用Google了，为什么不是Baidu？相信你用了Google之后就自然明白了。</p>

<p>当了一个学期的助教之后发现，很多的同学其实是没有使用搜索引擎的意识的，遇到问题要么自己死磕，或者就直接求助于他人。这两种都不是很好的办法，正确的做法是<strong>在自己思考后没有结果，然后使用搜索引擎查找问题</strong>，现阶段，你遇到的所有问题（几乎）都能在Google上找到现成的答案，如果没找到，肯定是你搜索的方式不正确。</p>

<p>使用Google的基本搜索功能就能够解决大部分问题了，当然，如果想要学习更加高级的技巧，这里有一份指南：<a href="https://www.zhihu.com/question/20161362">如何用好Google等搜索引擎？</a>。</p>

<h2 id="toc_3">英语</h2>

<p>你不得不承认，目前为止，编程世界的主流语言还是英文，所以英语能力的好坏决定了你编程能力的上界。中文资料和英文资料相比，实在是太匮乏了，就质量而言，也相对较低。比如我后面提到的很多的课程，都是英文的内容。</p>

<p>值得庆幸的是，阅读编程资料所需要的英文水平并不需要很高，就个人经验来说，基本上四级水平就足够了，可能还会存在一些生词，但是基本上并不妨碍理解。</p>

<p>英文的学习应该一直贯穿于编程的学习之中，作为一门工具语言，只需要花少量时间就可以带来比较大的收益（2/8法则）。</p>

<p>本人的英文水平也不算好，但是基本上能够阅读技术书籍和文档，能够听懂公开课，所以还是有一些简单的经验可以分享一下。</p>

<h3 id="toc_4">把系统换成英文的</h3>

<p>有些同学可能看到英文就头疼，这很正常，因为在中文的环境下面生活的太久了。为此，可以试着将平常用的系统换成英文的，虽说不能学到几个单词（Copy/Paste 之类的词），但是可以让你不那么排斥英文，<del>顺便还可以提升一下B格</del>。</p>

<h3 id="toc_5">安装电子词典</h3>

<p>OS X下推荐欧路词典，在APP Store中购买完整版的，因为需要添加外部的词典。</p>

<p>这里推荐一部比较好的词典：《Collins 英汉双解词典》，它是这个样子的：</p>

<p><img src="media/14824091738545/eudic.jpg" alt="eudi"/></p>

<p>主要看它的英文解释，一个词看得次数多了也就记住了。</p>

<h3 id="toc_6">每天阅读英文的资料</h3>

<p>一些个人经常阅读的网站：</p>

<ul>
<li><a href="http://quora.com/">Quora</a>：一个类似于知乎的问答类网站，可以挑自己感兴趣的内容来阅读。</li>
<li><a href="https://news.ycombinator.com/">Hacker News</a>：IT资讯，IT界发生的最新的事件都会在上面。</li>
<li><a href="http://www.reddit.com/r/programming/">PROGRAMMING</a>：Reddit的Programming板块，和Hacker News类似，不过更加专注于技术内容方面。</li>
</ul>

<p><strong>不要花太多时间在上面，每天浏览一下就行。</strong></p>

<h2 id="toc_7">英文学习的总结</h2>

<p>英语不是能够速成的东西，也不是三言两语能够讲完的东西，这里只是提供一个简单的指导，具体的学习计划还请自行搜索更加专业的学习指南。</p>

<h1 id="toc_8">编程基础</h1>

<p>完成了这一部分内容的学习后你应该具备：</p>

<ul>
<li>了解什么是Computer Science</li>
<li>基本的计算机数学能力</li>
<li>基本的程序开发能力</li>
<li>基本的算法与数据结构的知识</li>
</ul>

<h2 id="toc_9">计算机科学导论</h2>

<ul>
<li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/">Introduction to Computer Science and Programming</a>：面向<strong>无编程基础或者只有一点基础的人群</strong>，使用<strong>Python</strong>作为教学语言。</li>
<li><a href="http://www.extension.harvard.edu/open-learning-initiative/intensive-introduction-computer-science">Intensive Introduction to Computer Science Open Learning Course</a>：CS50，哈佛很火的一门课，在网易公开课上可以找到翻译的视频内容。涵盖的主题有算法（设计、应用、分析）；软件开发（抽象、封装、数据结构、Debug、测试）；计算机体系结构等等。基本上是一门大杂烩的导论课。使用的语言是<strong>C</strong>、<strong>PHP</strong>、<strong>JavaScript</strong>。</li>
<li><a href="https://www.youtube.com/view_play_list?p=FE6E58F856038C69">Programming Abstractions</a>：介绍了更加高级的编程主题（递归、算法分析、数据抽象等等），使用C++作为教学语言。</li>
</ul>

<h2 id="toc_10">数学</h2>

<ul>
<li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/">Mathematics for Computer Science</a>：介绍了学习计算机所需要的一些数学知识，内容包括集合、关系、证明方法、数论、图论等等。</li>
<li><a href="https://www.youtube.com/watch?v=h_9WjWENWV8&amp;feature=share&amp;list=PLTdIp1DywMlUpLHEg3ADhE6rrxhW_T5Rx">Discrete Mathematics</a>：离散数学。</li>
</ul>

<h2 id="toc_11">编程语言</h2>

<ul>
<li><a href="https://www.coursera.org/course/programming1">Learn to Program: The Fundamentals</a>：面向<strong>无编程基础或者只有一点基础的人群</strong>，使用<strong>Python</strong>作为教学语言。</li>
<li><a href="https://www.coursera.org/course/programming2">Learn to Program: Crafting Quality Code</a>：如何编写高效与正确的代码。需要有<a href="https://www.coursera.org/course/programming1">Learn to Program: The Fundamentals</a>的基础。</li>
<li><a href="http://cs61a.org/">The Structure and Interpretation of Computer Programs</a>：经典的SICP的Python版。</li>
</ul>

<h2 id="toc_12">计算理论</h2>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PL601FC994BDD963E4">Introduction to the Theory of Computation</a></li>
<li><a href="https://www.coursera.org/course/principlescomputing1">Principles of Computing (Part 1)</a>：介绍了CS中基本的数学和编程理论，需要有<strong>Python</strong>基础。</li>
</ul>

<h2 id="toc_13">算法与数据结构</h2>

<ul>
<li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/">Introduction to Algorithms</a>：MIT的算法导论课，用《算法导论》作为教材，网上可以找到视频资源，网易公开课上有老版的翻译。</li>
</ul>

<h1 id="toc_14">核心课程</h1>

<p>学完了「编程基础」部分的内容后，应该已经可以开发一些简单的程序了，「核心课程」的内容将深入学习计算机科学理论的几个重要的内容。</p>

<h2 id="toc_15">数学</h2>

<ul>
<li><a href="https://www.coursera.org/course/matrix">Coding the Matrix: Linear Algebra through Computer Science Applications</a>：线性代数以及在计算机中的应用。</li>
<li><a href="http://inst.eecs.berkeley.edu/%7Ecs70/sp16/">Discrete Mathematics and Probability Theory</a>：离散数学与概率论。</li>
</ul>

<h2 id="toc_16">计算理论</h2>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PLslgisHe5tBM8UTCt1f66oMkpmjCblzkt">Theory of Computation - Fall 2011</a>：介绍了机器模型、上下文无关文法、图灵机等，使用的教材是Michael Sipser的*<a href="http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X">Introduction to the Theory of Computation</a>。</li>
</ul>

<h2 id="toc_17">算法与数据结构</h2>

<ul>
<li><a href="http://www-inst.eecs.berkeley.edu/%7Ecs61b/fa15/">Data Structures and Advanced Programming</a></li>
<li><a href="http://www.cs.berkeley.edu/%7Ejrs/170/">Efficient Algorithms and Intractable Problems</a></li>
</ul>

<h2 id="toc_18">操作系统</h2>

<ul>
<li><a href="https://cs162.eecs.berkeley.edu/">Operating Systems and Systems Programming</a>：UCB经典的操作系统课程，介绍了操作系统的基本概念、系统编程、网络、分布式系统、内存分配、多线程等等。</li>
<li><a href="https://www.edx.org/course/introduction-linux-linuxfoundationx-lfs101x-2#!">Introduction to Linux</a>：介绍了Linux以及一些简单的命令行使用。</li>
</ul>

<h2 id="toc_19">程序语言理论</h2>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PL9D558D49CA734A02">Programming Paradigms</a>：编程范式。</li>
<li><a href="https://www.coursera.org/course/compilers">Compilers</a>：Stanford的编译原理课。</li>
<li><a href="http://freevideolectures.com/Course/2249/Principles-of-Programming-Languages/1">Principles of Programming Languages</a></li>
</ul>

<h2 id="toc_20">计算机体系结构</h2>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmgVhh8CHAu9N76TShJqfYDt">Computer Architecture</a>：CMU</li>
<li><a href="https://www.coursera.org/course/comparch">Computer Architecture</a></li>
</ul>

<h2 id="toc_21">计算机网络</h2>

<ul>
<li><a href="http://www.cs.berkeley.edu/%7Eistoica/classes/cs268/10/">Computer Networks</a></li>
<li><a href="https://www.youtube.com/channel/UCb1OiccPJ0wbMZMOleCvhWQ">Fundamentals of Computer Networking</a></li>
</ul>

<h1 id="toc_22">编程工具</h1>

<h2 id="toc_23">IDE</h2>

<ul>
<li>Python: <a href="https://www.jetbrains.com/pycharm/">PyCharm</a></li>
<li>Java:<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a></li>
<li>C/C++: <a href="https://www.visualstudio.com/en-us/visual-studio-homepage-vs.aspx">Visual Studio</a></li>
</ul>

<h2 id="toc_24">编辑器</h2>

<ul>
<li>Emacs/Vim</li>
<li>Sublime Text 3</li>
<li>VS Code</li>
<li>Atom</li>
</ul>

<p>并不一定要用Emacs或者Vim，ST其实已经很强大了，足够做日常简单的编辑工作。（这里黑一下Atom，启动速度太感人了，所以放在最后一个。）</p>

<h2 id="toc_25">Git &amp; GitHub</h2>

<p>使用版本控制来管理自己平时写的代码。</p>

<p>推荐阅读：</p>

<ul>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki">git-recipes</a></li>
<li><a href="http://git-scm.com/book/zh/v2?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">Pro Git 2nd Edition</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰</a></li>
</ul>

<h1 id="toc_26">如何克服拖延</h1>

<p>资料是有了，但是拖延症不去学怎么办？</p>

<ul>
<li><a href="http://www.pomodorotechnique.com/">番茄工作法</a></li>
</ul>

<h1 id="toc_27">参考资料</h1>

<ul>
<li><a href="https://github.com/prakhar1989/awesome-courses">https://github.com/prakhar1989/awesome-courses</a></li>
<li><a href="http://blog.agupieware.com/2014/05/online-learning-bachelors-level.html">http://blog.agupieware.com/2014/05/online-learning-bachelors-level.html</a></li>
<li><a href="https://docs.google.com/spreadsheets/d/1_kdHrT8izbROJNaxGflpcZm2ivsjRGF8j1hMzl3b8O0/htmlview">https://docs.google.com/spreadsheets/d/1_kdHrT8izbROJNaxGflpcZm2ivsjRGF8j1hMzl3b8O0/htmlview</a></li>
<li><a href="https://www.reddit.com/r/programming/wiki/faq">https://www.reddit.com/r/programming/wiki/faq</a></li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在2015年末]]></title>
    <link href="http://forrestchang.com/14824075781519.html"/>
    <updated>2016-12-22T19:52:58+08:00</updated>
    <id>http://forrestchang.com/14824075781519.html</id>
    <content type="html">
<![CDATA[<p>本来是不打算写所谓的总结文的，一方面没有这个习惯，另一方面过去一年确实过得比较平淡，甚至来说有点失败，不写是有点逃避的意味，不过自欺欺人总不是办法，还是写下来反思一下，也好让新的一年过得比15年好一些。</p>

<p>想从大脑中搜索一下15年发生了什么大事，发现好像并没有，唯一一件比较大的事就是谈了一次恋爱，虽然最后分手了，不过还是从中学到了很多东西，有些事情做得并没有自己想象的那么好。</p>

<p>学习方面似乎已经和学校的课程割裂开来了，基本学校的课程没有怎么花时间，所以GPA是低的可以了。编程水平也没有怎么提高，这学期开始看《算法导论》，不过后来事情比较多了之后就暂停了下来。英文水平也不知道具体处在哪个位置，平常也经常阅读英文的资料，看全英文的公开课问题也不是很大，不过单词量应该不是很大，因为阅读的过程中明显感觉到很多单词不认识；口语也不是很好，基本没有动嘴说过；至于写作水平，估计连高中的水平也没有了（高中的时候好歹也经常写作文）。</p>

<p>过去一年花了太多时间在一些可做可不做的事情上。有一段时间一直在摆弄Emacs，装各种插件，写配置文件，想要什么事情都用Emacs来完成，到头来，效率没有怎么提高，时间却浪费了不少。现在写代码基本不用Emacs了，跟IDE相比，编辑器毕竟只是编辑器，PyCharm写Python甩Emacs好几条街了。还花了很多时间在各种软件的试玩上面，比如各种时间管理工具，各种做笔记的软件，也是发现了一些好的软件，不过按照二八原理来说，收获与付出并不成正比。</p>

<p>阅读方面，买了Kindle后发现读不读书和用什么工具并没有什么关系，不读书买了Kindle也不会读。大概在Kindle上读的书只有20本左右，远远没有读回本。</p>

<p>综上，15年确实没有什么值得惊喜的地方，平平淡淡。还是写一写新年的计划吧，即使知道写下来也不一定能够实现，但至少写下来了，有个参考。</p>

<h2 id="toc_0">2016目标清单</h2>

<h3 id="toc_1">编程</h3>

<ul>
<li>读完《算法导论》，做完上面大部分题目</li>
<li>读完《计算机程序的构造和解释》</li>
<li>读完《深入理解计算机系统》</li>
<li>写一个解释器</li>
<li>上架一个App</li>
<li>在Coursera上多刷几门课</li>
</ul>

<h3 id="toc_2">英语</h3>

<ul>
<li>托福考试100+</li>
</ul>

<p>16年争取把英文作为主力语言，阅读、写作都选择用英文来进行。</p>

<h3 id="toc_3">健身&amp;跑步</h3>

<ul>
<li>养成健身的习惯，每周4次，每次1个小时左右</li>
<li>跑满500KM</li>
<li>参加一次马拉松</li>
</ul>

<p>15年断断续续跑了200公里，没能够坚持每天都跑。</p>

<h3 id="toc_4">阅读</h3>

<ul>
<li>读50本书（非小说），平均下来每个月4本，也就是一周一本</li>
</ul>

<p>把刷知乎的时间用来阅读，多利用零碎时间。书的类型先挑自己感兴趣的方面阅读吧，并不一定要把一本书从头到尾读完，有的书通读一遍就行，实在读不下去就放弃。</p>

<h2 id="toc_5">其他</h2>

<p>这篇总结的文字写了差不多一个小时，还有4个小时就到新的一年了，在这里提前祝大家新年快乐了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客的输入法：Squirrel（鼠须管）]]></title>
    <link href="http://forrestchang.com/14824092772636.html"/>
    <updated>2016-12-22T20:21:17+08:00</updated>
    <id>http://forrestchang.com/14824092772636.html</id>
    <content type="html">
<![CDATA[<p>在OS X平台下，一直没有用到一个很顺手的输入法。系统自带的输入法虽然经过几次的版本更新已经有了很大的改进，但是离能用还有很大的距离。所以之前一直凑合着使用百度输入法，不过最近一直遇到一些奇怪的问题，官方又长时间没有进行更新，恰逢之前听说过<code>Squirrel</code>这个输入法，于是就本着试用的心态用了一下，发现异常顺手，并且还有丰富的定制性，于是写一篇文章来介绍一下，也作为自己配置过程中的笔记。</p>

<p>附上一段Gif效果展示：</p>

<p><img src="media/14824092772636/luoshenfu.gif" alt="luoshenfu"/></p>

<h2 id="toc_0">介绍</h2>

<p>输入法的官方名称是<code>Rime</code>，中文名是<code>中州韵输入法</code>，但是在各自的平台下面又有不一样的别名。</p>

<ul>
<li><p>Linux<br/>
中州韵 ｜ ibus-rime</p></li>
<li><p>Windows<br/>
小狼毫 ｜ Weasel</p></li>
<li><p>OS X<br/>
鼠须管 ｜ Squirrel</p></li>
</ul>

<p>使用了一段时间发现它有以下几个优点其他输入法是比不上的：</p>

<ol>
<li>速度很快，几乎没有延迟的时间</li>
<li>极强的定制性，如果没有想要的功能还可以直接修改源码</li>
<li>跨平台</li>
<li>对于繁体中文支持非常好</li>
</ol>

<h2 id="toc_1">安装</h2>

<p>直接从官网下载安装包安装即可。</p>

<p>Rime官网：<a href="http://rime.im/"></a></p>

<p>使用<code>Ctrl-~</code>进行输入法的选择，这里选择<code>朙月拼音・簡化字</code>即可：</p>

<p><img src="media/14824092772636/rime02.png" alt="rime02"/></p>

<h2 id="toc_2">配置</h2>

<p>默认的的配置其实已经可以使用了，但是为了更加符合自己的使用习惯，我们需要做一些自定义的配置。</p>

<p>所有的配置文件都保存在<code>~/Library/Rime/</code>这个目录下面。</p>

<p>不建议直接修改原先的配置文件，因为这样更新之后会导致修改的内容丢失，正确的做法是建立<code>custom</code>副本，这样自定义的配置内容会覆盖掉原来的。</p>

<p>＊注：所有的修改完成了之后都需要重启输入法，快捷键<code>Option+Ctrl+~</code>。</p>

<h3 id="toc_3">配置外观</h3>

<p>初始的外观不是很符合自己的审美，可以进行更换主题、更改字体和字号大小等操作来配置成自己喜欢的样子。</p>

<p>新建配置文件</p>

<pre><code>touch squirrel.custom.yaml
</code></pre>

<p>然后将以下代码写入配置文件</p>

<pre><code>patch:
  style/color_scheme: dark_temple #主题
  style/font_point: 18 #字号大小
  style/horizontal: true #水平显示待选字
</code></pre>

<h4 id="toc_4">主题列表</h4>

<p>自带的主题代码:</p>

<pre><code>#   注：预设的配色方案及代码（指定为 style/color_scheme ）
#   碧水 - aqua
#   青天 - azure
#   明月 - luna
#   墨池 - ink
#   孤寺 - lost_temple
#   暗堂 - dark_temple
#   星际我争霸 - starcraft
#   谷歌 - google
#   晒经石 - solarized_rock
#   简约白 - clean_white
</code></pre>

<p>想要更换什么主题只要把代码替换掉就可以了。</p>

<h4 id="toc_5">其他一些配置代码及其说明</h4>

<pre><code>  style/page_size: 8                         # 设定候选词数目
  style/inline_preedit: false              # 关闭内嵌编码，这样就可以显示首行的拼音
  style/corner_radius: 10                  # 窗口圆角半径
  style/border_height: 0                   # 窗口边界高度，大于圆角半径才有效果
  style/border_width: 0                    # 窗口边界宽度，大于圆角半径才有效果
  style/line_spacing: 1                    # 候选词的行间距
  style/spacing: 5                         # 在非内嵌编码模式下，预编辑和候选词之间的距
  style/font_face: &quot;Hiragino Sans GB W3&quot;   # 字体名称
</code></pre>

<p>更多的一些配置代码可以在<code>squirrel.yaml</code>中找到。</p>

<h3 id="toc_6">定制标点符号</h3>

<p>鼠须管有一个特别的功能就是输入一个标点的时候可以有很多的候选标点让你选择，比如说中括号：</p>

<p><img src="media/14824092772636/rime03.png" alt="rime03"/></p>

<p>但是有的时候默认就想选择第一个，多出了一个选择的步骤无疑上会增加击键的次数，所以我们可以通过修改配置来解决这个问题，同时也可以自定义想要输入的符号。</p>

<p>这里我们使用的是<code>朙月拼音・簡化字</code>，所以需要建立相应的配置文件：</p>

<pre><code>touch luna_pinyin_simp.custom.yaml
</code></pre>

<p>然后写入以下配置（可根据自己的需要修改，这里的代码的意思是在全角和半角的状态下输入<code>&lt;</code>均以<code>《</code>输出）。</p>

<pre><code>patch:
  punctuator/full_shape:
    &quot;&lt;&quot;: &quot;《&quot;
  punctuator/half_shape:
    &quot;&lt;&quot;: &quot;《&quot;
  punctuator/full_shape:
    &quot;&gt;&quot;: &quot;》&quot;
  punctuator/half_shape:
    &quot;&gt;&quot;: &quot;》&quot;
</code></pre>

<h3 id="toc_7">安静模式</h3>

<p>之前一直使用百度输入法的原因就是因为它有一个安静模式，可以在特定的程序内关闭输入法，比如说<code>Emacs</code>中大部分时间都是不需要输入中文的，所以当切换到这个程序的时候就自动将输入法切换到英文模式。</p>

<p>需要找到应用软件的<code>Bundle Identifier</code>，保存在<code>Info.plist</code>这个文件当中。</p>

<p>修改<code>squirrel.custom.yaml</code>（没有自己创建）：</p>

<pre><code>patch:
  style/color_scheme: dark_temple
  style/font_point: 18
  style/horizontal: true

  app_options/com.apple.Xcode:
    ascii_mode: true
  app_options/com.runningwithcrayons.Alfred-2:
    ascii_mode: true
</code></pre>

<h2 id="toc_8">快捷键</h2>

<p>鼠须管默认支持<code>Emacs</code>的快捷键，所以基本上在<code>Emacs</code>中使用到的一些操作方式都可以在这里使用到。</p>

<ul>
<li>↑：Control+p</li>
<li>↓：Control+n</li>
<li>←：Control+b</li>
<li>→：Control+f</li>
<li>上頁：Alt+v</li>
<li>下頁：Control+v</li>
<li>句首：Control+a</li>
<li>句末：Control+e</li>
<li>回退：Control+h</li>
<li>刪除：Control+d</li>
<li>清空：Control+g</li>
<li>刪詞：Control+k</li>
</ul>

<h2 id="toc_9">其他</h2>

<p>完成以上的配置之后基本上就能够用得很顺手了，更多高级的配置方法可以参考官方的文档：<a href="http://rime.im/docs/">幫助與反饋</a></p>

<h2 id="toc_10">参考资料</h2>

<ul>
<li><a href="http://rime.im/docs/">官方文档</a></li>
<li><a href="http://www.dreamxu.com/install-config-squirrel/">安装及配置 Mac 上的 Rime 输入法——鼠鬚管 (Squirrel)</a></li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Emacs Org-mode + GitHub Pages 来写博客]]></title>
    <link href="http://forrestchang.com/14824097554043.html"/>
    <updated>2016-12-22T20:29:15+08:00</updated>
    <id>http://forrestchang.com/14824097554043.html</id>
    <content type="html">
<![CDATA[<p>这个博客就是使用Emacs org-mode + GitHub Pages搭建的，博客的主题是org-mode官网的主题，非常的简洁；评论采用的disqus，访问统计使用的是Google和Baidu的统计代码。</p>

<p>另外，本文中进行操作的环境是在OSX下完成的，Windows用户请自行参考脑补:)</p>

<h2 id="toc_0">起因</h2>

<p>之前也折腾过好多的博客，Jekyll、Hexo、Farbox等，这些静态博客生成器都有一个共同点，都是采用的Markdown语法来进行书写的，而自己平时记笔记都是使用的Emacs org-mode，这样就导致了记笔记和写博客两个过程分裂开来了。</p>

<p>昨晚偶然看到<a href="http://dirlt.com/">dirtysalt&#39;s homepage</a>，被深深的震撼了，博主写了很多的干货，专注与博客的内容而不是博客的外观。而自己也是一个极简主义者，觉得这样的博客样式还是挺好看的（很有Web1.0时代的复古风啊）。恰巧博主也是使用的Emacs来写博客，于是便花了一个上午的时间搜集相关的资料并把博客搭建起来了。</p>

<h2 id="toc_1">准备</h2>

<h3 id="toc_2">GitHub帐号与GitHub Pages</h3>

<p>首先你需要一个存放博客的地方，这里采用的是GitHub，当让也可以使用其他的服务，只要支持静态页面展示即可。</p>

<p>GitHub的注册过程省略。</p>

<p>注册完GitHub帐号之后建立一个新的仓库，命名为 <code>xxx.github.io</code> ，其中 <code>xxx</code> 为你的用户名。</p>

<h3 id="toc_3">Emacs环境</h3>

<p>我使用的是最近比较火的<a href="https://github.com/syl20bnr/spacemacs">spacemacs</a> ，很多功能都配置好了，基本上手即用。</p>

<p>如果不是用的spacemacs，确保你的Emacs版本为24，org-mode版本为8.0以上，不排除可能因为版本的原因出现各种各样的错误。</p>

<p>什么，你还不知道Emacs是什么，那先去下载一个Emacs吧，使用org-mode基本不需要什么Emacs的基础，只需要记住几个快捷键就可以了。</p>

<h2 id="toc_4">建立目录结构</h2>

<p>随便在哪里建一个心得目录，这个目录就是存放你的org文件和html文件的地方。假设我们已经有了这么一个目录 <code>org</code> ：</p>

<pre><code>$ mkdir notes
$ mkdir public_html
$ mkdir gtd
</code></pre>

<p>当然，那个gtd目录你可以不要，那是用来做时间管理的，如果你不想用Emacs做时间管理的话，可以不用建那个目录。</p>

<ul>
<li>notes: 这个目录就是用来存放元数据的地方，你的org文件、图片、CSS文件、PDF等全都是存放在这里的。</li>
<li>public_html: 这个目录是用来存放导出的HTML文件的，那些非org格式的文件还会原封不动地拷贝过来。</li>
</ul>

<h2 id="toc_5">配置Emacs</h2>

<p>这一步有一些复杂，没有Elisp基础的同学可能看不怎么懂，不过没关系，照着做就是了，现在看不懂可以以后学嘛。</p>

<p>Emacs org-mode自带了很强大的导出功能，可以导出成HTML、markdown、PDF等格式的文件，我们这里使用自带的导出Project的功能，只不过在导出之前，要做一些配置，告诉Emacs要导出哪些东西，导出到哪里，采用什么规则。</p>

<p>首先我们在配置文件中添加以下代码（普通的在.emacs中添加，spacemacs用户在.spacemacs中添加）：</p>

<pre><code class="language-lisp">  (require &#39;ox-publish)
  (setq org-publish-project-alist
        &#39;(

          ;; 把各部分的配置文件写到这里面来

          ))
</code></pre>

<p>然后把其他的配置文件依次添加进来就可以了，主要有生成HTML的部分和原样拷贝的部分。</p>

<p>下面来配置需要转换成HTML的内容：</p>

<pre><code class="language-html">  (&quot;blog-notes&quot;
   :base-directory &quot;~/org/notes&quot;
   :base-extension &quot;org&quot;
   :publishing-directory &quot;~/org/public_html/&quot;
   :recursive t
   :publishing-function org-html-publish-to-html
   :headline-levels 4             ; Just the default for this project.
   :auto-preamble t
   :section-numbers nil
   :author &quot;Yourname&quot;
   :email &quot;example@test.com&quot;
   :auto-sitemap t                ; Generate sitemap.org automagically...
   :sitemap-filename &quot;sitemap.org&quot;  ; ... call it sitemap.org (it&#39;s the default)...
   :sitemap-title &quot;Sitemap&quot;         ; ... with title &#39;Sitemap&#39;.
   :sitemap-sort-files anti-chronologically
   :sitemap-file-entry-format &quot;%d %t&quot;
   )
</code></pre>

<ul>
<li>:base-directory - 你存放笔记的目录（想将哪里的org文件导出成HTML）</li>
<li>:base-extension - 导出的文件格式</li>
<li>:publishing-directory - 导出HTML的目标目录</li>
<li>:recursive - 设置为t会将子目录中的文件也导出</li>
<li>:publishing-function - 使用哪个函数来进行publish（注：org 7与8在这个地方有区别）</li>
<li>:auto-sitemap - 自动生存sitemap</li>
<li>:sitemap-sort-files - 我这里采用的是按照从新到旧的排列方式</li>
<li>:sitemap-file-entry-format - 这里采用时间+标题的方式生成sitemap</li>
</ul>

<p>并不是所有的文件都需要转化为HTML的，比如说一些图片、PDF、CSS样式等，只需要原样拷贝到目标文件就行，配置代码如下：</p>

<pre><code class="language-lisp">  (&quot;blog-static&quot;
   :base-directory &quot;~/org/notes&quot;
   :base-extension &quot;css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf&quot;
   :publishing-directory &quot;~/org/public_html/&quot;
   :recursive t
   :publishing-function org-publish-attachment
   )
</code></pre>

<p>把这两段代码查到刚刚给的框架里面去即可。</p>

<p>最后，我们再加一段代码：</p>

<pre><code class="language-lisp">  (&quot;blog&quot; :components (&quot;blog-notes&quot; &quot;blog-static&quot;))
</code></pre>

<p>至此，基本的配置已经完成了，现在可以写一些org文件来生成HTML了。</p>

<p>比如说我已经写完了一些org文件：</p>

<pre><code>.
├── blog-history.org
├── css
│   └── worg.css
├── cv.org
├── front-end-development
│   ├── css.org
│   └── html.org
├── how-to-use-org-mode-build-blog.org
├── index.org
├── personal
│   ├── how-to-study-efficiently.org
│   └── index.org
└── sitemap.org
</code></pre>

<p>然后使用<code>M-x org-publish-project</code>，输入<code>blog</code>，就会自动开始生成HTML文件了，现在已经可以在public_html文件夹中访问了。</p>

<p>当然，index页面是需要自己来写的，可以参照我的主页来写，或者自由发挥。</p>

<h2 id="toc_6">个性化定制</h2>

<h3 id="toc_7">添加CSS文件</h3>

<p>首先需要在notes文件夹内新建一个css文件夹，里面保存需要用到的CSS文件，这里我使用的是org-mode官网上用的CSS文件，非常的简洁。</p>

<p>然后我们需要在 <code>blog-notes</code> 这个配置中新增一条属性：</p>

<pre><code class="language-lisp"> :html-head &quot;&lt;link rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; href=\&quot;/css/worg.css\&quot;/&gt;&quot;
</code></pre>

<p>这样子的话再每次生成HTML的时候都会自动加上CSS，这里建议使用绝对路径来访问css文件，要不然在notes文件夹中新建文件夹的时候就无效了。</p>

<h3 id="toc_8">添加评论功能</h3>

<p>这里使用的Disqus的评论系统，使用Duoshuo的话配置过程应该也一样。</p>

<p>首先在Disqus中注册一个服务，获得一段代码，在 <code>blog-notes</code> 中新增加一条属性：</p>

<pre><code class="language-lisp">  :html-postamble &quot;&lt;p class=\&quot;postamble\&quot;&gt;Last Updated %C. Created by %a&lt;/p&gt;
  &lt;div id=\&quot;disqus_thread\&quot;&gt;&lt;/div&gt;
  &lt;script type=\&quot;text/javascript\&quot;&gt;
  var disqus_shortname = &#39;yourshortname&#39;;
  (function() {
           var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;
           dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;
           (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);
           })();
  &lt;/script&gt;
  &quot;
</code></pre>

<p>需要注意的是代码中的双引号前面需要加上反斜杠来转义。</p>

<h3 id="toc_9">添加统计功能</h3>

<p>使用百度和Google的统计服务，和添加评论功能类似，还是添加在这条属性里面：</p>

<pre><code class="language-lisp">    :html-postamble &quot;&lt;p class=\&quot;postamble\&quot;&gt;Last Updated %C. Created by %a&lt;/p&gt;
  &lt;script&gt;
  var _hmt = _hmt || [];
  (function() {
           var hm = document.createElement(\&quot;script\&quot;);
           hm.src = \&quot;//hm.baidu.com/hm.js?yourkey\&quot;;
           var s = document.getElementsByTagName(\&quot;script\&quot;)[0];
           s.parentNode.insertBefore(hm, s);
           })();
  &lt;/script&gt;

  &lt;div id=\&quot;disqus_thread\&quot;&gt;&lt;/div&gt;
  &lt;script type=\&quot;text/javascript\&quot;&gt;
  var disqus_shortname = &#39;yourshortname&#39;;
  (function() {
           var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;
           dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;
           (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);
           })();
  &lt;/script&gt;

  &lt;script&gt;
  (function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){
           (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
           m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
           })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);

  ga(&#39;create&#39;, &#39;yourkey&#39;, &#39;auto&#39;);
  ga(&#39;send&#39;, &#39;pageview&#39;);

  &lt;/script&gt;
  &quot;
</code></pre>

<p>同样注意双引号的转义问题即可。</p>

<h2 id="toc_10">托管到GitHub上</h2>

<p>生成了HTML文件之后需要把public_html目录托管到GitHub上：</p>

<pre><code>$ git add .
$ git commit -m &quot;first commit&quot;
$ git remote add origin xxx
$ git push -u origin master
</code></pre>

<p>其中<code>xxx</code>为你之前创建仓库的SSH路径。以后每次generate之后add、commit、push就可以了。</p>

<p>现在访问 <code>xxx.github.io</code> 已经可以看到你的博客啦：）</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈时间管理]]></title>
    <link href="http://forrestchang.com/14824097073807.html"/>
    <updated>2016-12-22T20:28:27+08:00</updated>
    <id>http://forrestchang.com/14824097073807.html</id>
    <content type="html">
<![CDATA[<p>初次看到时间管理这个概念大概是高二的时候，在此之前，我一直在使用所谓的To-do List来管理自己每天的学习任务（那个时候还不知道）。知道了时间管理这个概念后，惊讶于原来自己早就在对时间进行管理了，只不过最简单的管理方式（后来实践表明，仅仅一个任务清单就足够了）。</p>

<p>在知道了时间管理这个概念之后，我开始大量的阅读关于时间管理的文章，期间又接触到了GTD（Getting Things Done）这个个人管理系统，还专门读了一遍David的那本书。然后就是不断地下载软件、使用、删除、下载……从PC端到iOS到纸笔GTD都试过。突然发现，自己陷入到一个怪圈，主要工作不是变成了完成任务，而变成了寻找“更高效”的软件系统。相信人都会陷入到这个怪圈中，然后时间一步一步地被吞噬掉。然后你开始发现，最开始计划好要做的事情依旧没做好，甚至要找的高效软件也没有找到，因为你总是认为还会有更高效更方便的软件。</p>

<p>时间管理的初衷不是最大化的利用时间吗？而现在却浪费了更多的时间。这又是为什么呢？</p>

<p><strong>懒惰</strong>。是的，时间管理只不过是一个借口，一个用来迷惑自己“我是为了更高效的利用时间”的借口。说白了就是自己的懒惰，你就是不想完成任务，然后把“时间管理”当成幌子，找工具、看文章，试想一下，这些事情与你要完成的任务相比，哪一个更加困难？我想应该是你的任务更加困难吧，毕竟看文章只要看就行了。</p>

<p>我是在阅读了李笑来<em>《把时间当作朋友》</em> 一书后突然明白了这个道理，哪里需要那么多花招去管理你的时间啊，JUST DO IT！尽管做就可以了，或者说找到一种方法，就一直用下去，不要换来换去，也不要再找别的方法了，甚至不要再看关于时间管理的文章。</p>

<p>后来，通过李笑来的书，我又知道了<em>《奇特的一生》</em> 这本书（这是一本部头很小的书，几个小时便可以读完，网络上有免费的电子版），用了很快的时间读完了，除了震撼还是震撼。主人公柳比歇夫有一套强大而又完整的时间管理方法，并且坚持了五十几年。这套强大的系统也给他带来了巨大的成就：</p>

<blockquote>
<p>柳比歇夫生前发表了七十来部学术著作。其中有分散分析、生物分类学、昆虫学方面的经典著作；这些著作在国外广为翻译出版。各种各样的论文和专著，他一共写了五百多印张。五百印张，等于一万二千五百张打字稿。即使以专业作家而论，这也是个庞大的数字。</p>
</blockquote>

<p>他的成就定然是不凡的，这本书中还提到了门捷列夫等人，他们都有一个共同的特点：拥有一套独特的管理系统（时间&amp;知识），而且都是不断的改进，最后几乎完美的系统。</p>

<p>原来强大的时间管理系统也能造就如此伟大的成绩啊。这时不禁又要问，到底要不要时间管理呢？经过一段时间的思考，答案是要的。或者说不是管理时间，而是管理你自己，因为时间终究是那么多时间。</p>

<p>所以现在可能已经有了一个较为清晰的结论：我们需要管理时间，真的管理时间，而不是测试工具。坐在屏幕前阅读的你，如果还在为时间管理而困扰，依旧不知道选择哪款软件，我的建议是把注意力放到需要完成的任务上来。对于没有那么多繁杂事务的人（事实上绝大多数人没有），一个简单的任务清单就够了，做完一项任务划去一项，就是这么简单。</p>

<p>还不知道时间管理是什么的同学，只需要阅读一两篇文章就够了，或者只要看一本书就够了，至于看什么书，对于不是“日理万机”的人，个人认为上文提到的两本书或许可以是一个选择。接着，就忘记时间管理这个说法吧，专注于要做的事，开始做！</p>
]]>
    </content>
  </entry>
  
</feed>
